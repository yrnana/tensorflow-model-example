function jC(t,e){return e.forEach(function(n){Object.keys(n).forEach(function(r){if(r!=="default"&&!(r in t)){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}})}),Object.freeze(t)}var tn=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function hX(t){if(t.__esModule)return t;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(t).forEach(function(n){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}),e}var he={exports:{}},xe={};/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var Rx=Object.getOwnPropertySymbols,KC=Object.prototype.hasOwnProperty,qC=Object.prototype.propertyIsEnumerable;function XC(t){if(t==null)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(t)}function YC(){try{if(!Object.assign)return!1;var t=new String("abc");if(t[5]="de",Object.getOwnPropertyNames(t)[0]==="5")return!1;for(var e={},n=0;n<10;n++)e["_"+String.fromCharCode(n)]=n;var r=Object.getOwnPropertyNames(e).map(function(o){return e[o]});if(r.join("")!=="0123456789")return!1;var s={};return"abcdefghijklmnopqrst".split("").forEach(function(o){s[o]=o}),Object.keys(Object.assign({},s)).join("")==="abcdefghijklmnopqrst"}catch{return!1}}var Dx=YC()?Object.assign:function(t,e){for(var n,r=XC(t),s,o=1;o<arguments.length;o++){n=Object(arguments[o]);for(var a in n)KC.call(n,a)&&(r[a]=n[a]);if(Rx){s=Rx(n);for(var i=0;i<s.length;i++)qC.call(n,s[i])&&(r[s[i]]=n[s[i]])}}return r};/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Hf=Dx,zs=60103,Fx=60106;xe.Fragment=60107;xe.StrictMode=60108;xe.Profiler=60114;var Ax=60109,_x=60110,Px=60112;xe.Suspense=60113;var Ox=60115,Mx=60116;if(typeof Symbol=="function"&&Symbol.for){var xn=Symbol.for;zs=xn("react.element"),Fx=xn("react.portal"),xe.Fragment=xn("react.fragment"),xe.StrictMode=xn("react.strict_mode"),xe.Profiler=xn("react.profiler"),Ax=xn("react.provider"),_x=xn("react.context"),Px=xn("react.forward_ref"),xe.Suspense=xn("react.suspense"),Ox=xn("react.memo"),Mx=xn("react.lazy")}var Lx=typeof Symbol=="function"&&Symbol.iterator;function QC(t){return t===null||typeof t!="object"?null:(t=Lx&&t[Lx]||t["@@iterator"],typeof t=="function"?t:null)}function Jo(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var Bx={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},Vx={};function Us(t,e,n){this.props=t,this.context=e,this.refs=Vx,this.updater=n||Bx}Us.prototype.isReactComponent={};Us.prototype.setState=function(t,e){if(typeof t!="object"&&typeof t!="function"&&t!=null)throw Error(Jo(85));this.updater.enqueueSetState(this,t,e,"setState")};Us.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")};function Wx(){}Wx.prototype=Us.prototype;function jf(t,e,n){this.props=t,this.context=e,this.refs=Vx,this.updater=n||Bx}var Kf=jf.prototype=new Wx;Kf.constructor=jf;Hf(Kf,Us.prototype);Kf.isPureReactComponent=!0;var qf={current:null},zx=Object.prototype.hasOwnProperty,Ux={key:!0,ref:!0,__self:!0,__source:!0};function Gx(t,e,n){var r,s={},o=null,a=null;if(e!=null)for(r in e.ref!==void 0&&(a=e.ref),e.key!==void 0&&(o=""+e.key),e)zx.call(e,r)&&!Ux.hasOwnProperty(r)&&(s[r]=e[r]);var i=arguments.length-2;if(i===1)s.children=n;else if(1<i){for(var l=Array(i),c=0;c<i;c++)l[c]=arguments[c+2];s.children=l}if(t&&t.defaultProps)for(r in i=t.defaultProps,i)s[r]===void 0&&(s[r]=i[r]);return{$$typeof:zs,type:t,key:o,ref:a,props:s,_owner:qf.current}}function ZC(t,e){return{$$typeof:zs,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}function Xf(t){return typeof t=="object"&&t!==null&&t.$$typeof===zs}function JC(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,function(n){return e[n]})}var Hx=/\/+/g;function Yf(t,e){return typeof t=="object"&&t!==null&&t.key!=null?JC(""+t.key):e.toString(36)}function Bl(t,e,n,r,s){var o=typeof t;(o==="undefined"||o==="boolean")&&(t=null);var a=!1;if(t===null)a=!0;else switch(o){case"string":case"number":a=!0;break;case"object":switch(t.$$typeof){case zs:case Fx:a=!0}}if(a)return a=t,s=s(a),t=r===""?"."+Yf(a,0):r,Array.isArray(s)?(n="",t!=null&&(n=t.replace(Hx,"$&/")+"/"),Bl(s,e,n,"",function(c){return c})):s!=null&&(Xf(s)&&(s=ZC(s,n+(!s.key||a&&a.key===s.key?"":(""+s.key).replace(Hx,"$&/")+"/")+t)),e.push(s)),1;if(a=0,r=r===""?".":r+":",Array.isArray(t))for(var i=0;i<t.length;i++){o=t[i];var l=r+Yf(o,i);a+=Bl(o,e,n,l,s)}else if(l=QC(t),typeof l=="function")for(t=l.call(t),i=0;!(o=t.next()).done;)o=o.value,l=r+Yf(o,i++),a+=Bl(o,e,n,l,s);else if(o==="object")throw e=""+t,Error(Jo(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e));return a}function Vl(t,e,n){if(t==null)return t;var r=[],s=0;return Bl(t,r,"","",function(o){return e.call(n,o,s++)}),r}function ek(t){if(t._status===-1){var e=t._result;e=e(),t._status=0,t._result=e,e.then(function(n){t._status===0&&(n=n.default,t._status=1,t._result=n)},function(n){t._status===0&&(t._status=2,t._result=n)})}if(t._status===1)return t._result;throw t._result}var jx={current:null};function Gn(){var t=jx.current;if(t===null)throw Error(Jo(321));return t}var tk={ReactCurrentDispatcher:jx,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:qf,IsSomeRendererActing:{current:!1},assign:Hf};xe.Children={map:Vl,forEach:function(t,e,n){Vl(t,function(){e.apply(this,arguments)},n)},count:function(t){var e=0;return Vl(t,function(){e++}),e},toArray:function(t){return Vl(t,function(e){return e})||[]},only:function(t){if(!Xf(t))throw Error(Jo(143));return t}};xe.Component=Us;xe.PureComponent=jf;xe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tk;xe.cloneElement=function(t,e,n){if(t==null)throw Error(Jo(267,t));var r=Hf({},t.props),s=t.key,o=t.ref,a=t._owner;if(e!=null){if(e.ref!==void 0&&(o=e.ref,a=qf.current),e.key!==void 0&&(s=""+e.key),t.type&&t.type.defaultProps)var i=t.type.defaultProps;for(l in e)zx.call(e,l)&&!Ux.hasOwnProperty(l)&&(r[l]=e[l]===void 0&&i!==void 0?i[l]:e[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){i=Array(l);for(var c=0;c<l;c++)i[c]=arguments[c+2];r.children=i}return{$$typeof:zs,type:t.type,key:s,ref:o,props:r,_owner:a}};xe.createContext=function(t,e){return e===void 0&&(e=null),t={$$typeof:_x,_calculateChangedBits:e,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null},t.Provider={$$typeof:Ax,_context:t},t.Consumer=t};xe.createElement=Gx;xe.createFactory=function(t){var e=Gx.bind(null,t);return e.type=t,e};xe.createRef=function(){return{current:null}};xe.forwardRef=function(t){return{$$typeof:Px,render:t}};xe.isValidElement=Xf;xe.lazy=function(t){return{$$typeof:Mx,_payload:{_status:-1,_result:t},_init:ek}};xe.memo=function(t,e){return{$$typeof:Ox,type:t,compare:e===void 0?null:e}};xe.useCallback=function(t,e){return Gn().useCallback(t,e)};xe.useContext=function(t,e){return Gn().useContext(t,e)};xe.useDebugValue=function(){};xe.useEffect=function(t,e){return Gn().useEffect(t,e)};xe.useImperativeHandle=function(t,e,n){return Gn().useImperativeHandle(t,e,n)};xe.useLayoutEffect=function(t,e){return Gn().useLayoutEffect(t,e)};xe.useMemo=function(t,e){return Gn().useMemo(t,e)};xe.useReducer=function(t,e,n){return Gn().useReducer(t,e,n)};xe.useRef=function(t){return Gn().useRef(t)};xe.useState=function(t){return Gn().useState(t)};xe.version="17.0.2";he.exports=xe;var mX=he.exports,Kx={exports:{}},nn={},qx={exports:{}},Xx={};/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(t){var e,n,r,s;if(typeof performance=="object"&&typeof performance.now=="function"){var o=performance;t.unstable_now=function(){return o.now()}}else{var a=Date,i=a.now();t.unstable_now=function(){return a.now()-i}}if(typeof window=="undefined"||typeof MessageChannel!="function"){var l=null,c=null,u=function(){if(l!==null)try{var _=t.unstable_now();l(!0,_),l=null}catch(V){throw setTimeout(u,0),V}};e=function(_){l!==null?setTimeout(e,0,_):(l=_,setTimeout(u,0))},n=function(_,V){c=setTimeout(_,V)},r=function(){clearTimeout(c)},t.unstable_shouldYield=function(){return!1},s=t.unstable_forceFrameRate=function(){}}else{var d=window.setTimeout,f=window.clearTimeout;if(typeof console!="undefined"){var p=window.cancelAnimationFrame;typeof window.requestAnimationFrame!="function"&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),typeof p!="function"&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var h=!1,g=null,m=-1,x=5,y=0;t.unstable_shouldYield=function(){return t.unstable_now()>=y},s=function(){},t.unstable_forceFrameRate=function(_){0>_||125<_?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):x=0<_?Math.floor(1e3/_):5};var w=new MessageChannel,v=w.port2;w.port1.onmessage=function(){if(g!==null){var _=t.unstable_now();y=_+x;try{g(!0,_)?v.postMessage(null):(h=!1,g=null)}catch(V){throw v.postMessage(null),V}}else h=!1},e=function(_){g=_,h||(h=!0,v.postMessage(null))},n=function(_,V){m=d(function(){_(t.unstable_now())},V)},r=function(){f(m),m=-1}}function $(_,V){var W=_.length;_.push(V);e:for(;;){var K=W-1>>>1,q=_[K];if(q!==void 0&&0<I(q,V))_[K]=V,_[W]=q,W=K;else break e}}function b(_){return _=_[0],_===void 0?null:_}function C(_){var V=_[0];if(V!==void 0){var W=_.pop();if(W!==V){_[0]=W;e:for(var K=0,q=_.length;K<q;){var Y=2*(K+1)-1,J=_[Y],se=Y+1,oe=_[se];if(J!==void 0&&0>I(J,W))oe!==void 0&&0>I(oe,J)?(_[K]=oe,_[se]=W,K=se):(_[K]=J,_[Y]=W,K=Y);else if(oe!==void 0&&0>I(oe,W))_[K]=oe,_[se]=W,K=se;else break e}}return V}return null}function I(_,V){var W=_.sortIndex-V.sortIndex;return W!==0?W:_.id-V.id}var E=[],T=[],D=1,F=null,A=3,P=!1,M=!1,O=!1;function U(_){for(var V=b(T);V!==null;){if(V.callback===null)C(T);else if(V.startTime<=_)C(T),V.sortIndex=V.expirationTime,$(E,V);else break;V=b(T)}}function B(_){if(O=!1,U(_),!M)if(b(E)!==null)M=!0,e(G);else{var V=b(T);V!==null&&n(B,V.startTime-_)}}function G(_,V){M=!1,O&&(O=!1,r()),P=!0;var W=A;try{for(U(V),F=b(E);F!==null&&(!(F.expirationTime>V)||_&&!t.unstable_shouldYield());){var K=F.callback;if(typeof K=="function"){F.callback=null,A=F.priorityLevel;var q=K(F.expirationTime<=V);V=t.unstable_now(),typeof q=="function"?F.callback=q:F===b(E)&&C(E),U(V)}else C(E);F=b(E)}if(F!==null)var Y=!0;else{var J=b(T);J!==null&&n(B,J.startTime-V),Y=!1}return Y}finally{F=null,A=W,P=!1}}var j=s;t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(_){_.callback=null},t.unstable_continueExecution=function(){M||P||(M=!0,e(G))},t.unstable_getCurrentPriorityLevel=function(){return A},t.unstable_getFirstCallbackNode=function(){return b(E)},t.unstable_next=function(_){switch(A){case 1:case 2:case 3:var V=3;break;default:V=A}var W=A;A=V;try{return _()}finally{A=W}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=j,t.unstable_runWithPriority=function(_,V){switch(_){case 1:case 2:case 3:case 4:case 5:break;default:_=3}var W=A;A=_;try{return V()}finally{A=W}},t.unstable_scheduleCallback=function(_,V,W){var K=t.unstable_now();switch(typeof W=="object"&&W!==null?(W=W.delay,W=typeof W=="number"&&0<W?K+W:K):W=K,_){case 1:var q=-1;break;case 2:q=250;break;case 5:q=1073741823;break;case 4:q=1e4;break;default:q=5e3}return q=W+q,_={id:D++,callback:V,priorityLevel:_,startTime:W,expirationTime:q,sortIndex:-1},W>K?(_.sortIndex=W,$(T,_),b(E)===null&&_===b(T)&&(O?r():O=!0,n(B,W-K))):(_.sortIndex=q,$(E,_),M||P||(M=!0,e(G))),_},t.unstable_wrapCallback=function(_){var V=A;return function(){var W=A;A=V;try{return _.apply(this,arguments)}finally{A=W}}}})(Xx);qx.exports=Xx;/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Wl=he.exports,Ve=Dx,it=qx.exports;function X(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!Wl)throw Error(X(227));var Yx=new Set,ea={};function Yr(t,e){Gs(t,e),Gs(t+"Capture",e)}function Gs(t,e){for(ea[t]=e,t=0;t<e.length;t++)Yx.add(e[t])}var Hn=!(typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"),nk=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Qx=Object.prototype.hasOwnProperty,Zx={},Jx={};function rk(t){return Qx.call(Jx,t)?!0:Qx.call(Zx,t)?!1:nk.test(t)?Jx[t]=!0:(Zx[t]=!0,!1)}function sk(t,e,n,r){if(n!==null&&n.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(t=t.toLowerCase().slice(0,5),t!=="data-"&&t!=="aria-");default:return!1}}function ok(t,e,n,r){if(e===null||typeof e=="undefined"||sk(t,e,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function Dt(t,e,n,r,s,o,a){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=o,this.removeEmptyString=a}var mt={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t){mt[t]=new Dt(t,0,!1,t,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(t){var e=t[0];mt[e]=new Dt(e,1,!1,t[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(t){mt[t]=new Dt(t,2,!1,t.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(t){mt[t]=new Dt(t,2,!1,t,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t){mt[t]=new Dt(t,3,!1,t.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(t){mt[t]=new Dt(t,3,!0,t,null,!1,!1)});["capture","download"].forEach(function(t){mt[t]=new Dt(t,4,!1,t,null,!1,!1)});["cols","rows","size","span"].forEach(function(t){mt[t]=new Dt(t,6,!1,t,null,!1,!1)});["rowSpan","start"].forEach(function(t){mt[t]=new Dt(t,5,!1,t.toLowerCase(),null,!1,!1)});var Qf=/[\-:]([a-z])/g;function Zf(t){return t[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t){var e=t.replace(Qf,Zf);mt[e]=new Dt(e,1,!1,t,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t){var e=t.replace(Qf,Zf);mt[e]=new Dt(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(t){var e=t.replace(Qf,Zf);mt[e]=new Dt(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(t){mt[t]=new Dt(t,1,!1,t.toLowerCase(),null,!1,!1)});mt.xlinkHref=new Dt("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(t){mt[t]=new Dt(t,1,!1,t.toLowerCase(),null,!0,!0)});function Jf(t,e,n,r){var s=mt.hasOwnProperty(e)?mt[e]:null,o=s!==null?s.type===0:r?!1:!(!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N");o||(ok(e,n,s,r)&&(n=null),r||s===null?rk(e)&&(n===null?t.removeAttribute(e):t.setAttribute(e,""+n)):s.mustUseProperty?t[s.propertyName]=n===null?s.type===3?!1:"":n:(e=s.attributeName,r=s.attributeNamespace,n===null?t.removeAttribute(e):(s=s.type,n=s===3||s===4&&n===!0?"":""+n,r?t.setAttributeNS(r,e,n):t.setAttribute(e,n))))}var Qr=Wl.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,ta=60103,Zr=60106,dr=60107,ep=60108,na=60114,tp=60109,np=60110,zl=60112,ra=60113,Ul=60120,Gl=60115,rp=60116,sp=60121,op=60128,e0=60129,ap=60130,ip=60131;if(typeof Symbol=="function"&&Symbol.for){var lt=Symbol.for;ta=lt("react.element"),Zr=lt("react.portal"),dr=lt("react.fragment"),ep=lt("react.strict_mode"),na=lt("react.profiler"),tp=lt("react.provider"),np=lt("react.context"),zl=lt("react.forward_ref"),ra=lt("react.suspense"),Ul=lt("react.suspense_list"),Gl=lt("react.memo"),rp=lt("react.lazy"),sp=lt("react.block"),lt("react.scope"),op=lt("react.opaque.id"),e0=lt("react.debug_trace_mode"),ap=lt("react.offscreen"),ip=lt("react.legacy_hidden")}var t0=typeof Symbol=="function"&&Symbol.iterator;function sa(t){return t===null||typeof t!="object"?null:(t=t0&&t[t0]||t["@@iterator"],typeof t=="function"?t:null)}var lp;function oa(t){if(lp===void 0)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);lp=e&&e[1]||""}return`
`+lp+t}var cp=!1;function Hl(t,e){if(!t||cp)return"";cp=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(l){var r=l}Reflect.construct(t,[],e)}else{try{e.call()}catch(l){r=l}t.call(e.prototype)}else{try{throw Error()}catch(l){r=l}t()}}catch(l){if(l&&r&&typeof l.stack=="string"){for(var s=l.stack.split(`
`),o=r.stack.split(`
`),a=s.length-1,i=o.length-1;1<=a&&0<=i&&s[a]!==o[i];)i--;for(;1<=a&&0<=i;a--,i--)if(s[a]!==o[i]){if(a!==1||i!==1)do if(a--,i--,0>i||s[a]!==o[i])return`
`+s[a].replace(" at new "," at ");while(1<=a&&0<=i);break}}}finally{cp=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?oa(t):""}function ak(t){switch(t.tag){case 5:return oa(t.type);case 16:return oa("Lazy");case 13:return oa("Suspense");case 19:return oa("SuspenseList");case 0:case 2:case 15:return t=Hl(t.type,!1),t;case 11:return t=Hl(t.type.render,!1),t;case 22:return t=Hl(t.type._render,!1),t;case 1:return t=Hl(t.type,!0),t;default:return""}}function Hs(t){if(t==null)return null;if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case dr:return"Fragment";case Zr:return"Portal";case na:return"Profiler";case ep:return"StrictMode";case ra:return"Suspense";case Ul:return"SuspenseList"}if(typeof t=="object")switch(t.$$typeof){case np:return(t.displayName||"Context")+".Consumer";case tp:return(t._context.displayName||"Context")+".Provider";case zl:var e=t.render;return e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case Gl:return Hs(t.type);case sp:return Hs(t._render);case rp:e=t._payload,t=t._init;try{return Hs(t(e))}catch{}}return null}function fr(t){switch(typeof t){case"boolean":case"number":case"object":case"string":case"undefined":return t;default:return""}}function n0(t){var e=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function ik(t){var e=n0(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),r=""+t[e];if(!t.hasOwnProperty(e)&&typeof n!="undefined"&&typeof n.get=="function"&&typeof n.set=="function"){var s=n.get,o=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return s.call(this)},set:function(a){r=""+a,o.call(this,a)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(a){r=""+a},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}function jl(t){t._valueTracker||(t._valueTracker=ik(t))}function r0(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),r="";return t&&(r=n0(t)?t.checked?"true":"false":t.value),t=r,t!==n?(e.setValue(t),!0):!1}function Kl(t){if(t=t||(typeof document!="undefined"?document:void 0),typeof t=="undefined")return null;try{return t.activeElement||t.body}catch{return t.body}}function up(t,e){var n=e.checked;return Ve({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n!=null?n:t._wrapperState.initialChecked})}function s0(t,e){var n=e.defaultValue==null?"":e.defaultValue,r=e.checked!=null?e.checked:e.defaultChecked;n=fr(e.value!=null?e.value:n),t._wrapperState={initialChecked:r,initialValue:n,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function o0(t,e){e=e.checked,e!=null&&Jf(t,"checked",e,!1)}function dp(t,e){o0(t,e);var n=fr(e.value),r=e.type;if(n!=null)r==="number"?(n===0&&t.value===""||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if(r==="submit"||r==="reset"){t.removeAttribute("value");return}e.hasOwnProperty("value")?fp(t,e.type,n):e.hasOwnProperty("defaultValue")&&fp(t,e.type,fr(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(t.defaultChecked=!!e.defaultChecked)}function a0(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!(r!=="submit"&&r!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}n=t.name,n!==""&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,n!==""&&(t.name=n)}function fp(t,e,n){(e!=="number"||Kl(t.ownerDocument)!==t)&&(n==null?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}function lk(t){var e="";return Wl.Children.forEach(t,function(n){n!=null&&(e+=n)}),e}function pp(t,e){return t=Ve({children:void 0},e),(e=lk(e.children))&&(t.children=e),t}function js(t,e,n,r){if(t=t.options,e){e={};for(var s=0;s<n.length;s++)e["$"+n[s]]=!0;for(n=0;n<t.length;n++)s=e.hasOwnProperty("$"+t[n].value),t[n].selected!==s&&(t[n].selected=s),s&&r&&(t[n].defaultSelected=!0)}else{for(n=""+fr(n),e=null,s=0;s<t.length;s++){if(t[s].value===n){t[s].selected=!0,r&&(t[s].defaultSelected=!0);return}e!==null||t[s].disabled||(e=t[s])}e!==null&&(e.selected=!0)}}function hp(t,e){if(e.dangerouslySetInnerHTML!=null)throw Error(X(91));return Ve({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function i0(t,e){var n=e.value;if(n==null){if(n=e.children,e=e.defaultValue,n!=null){if(e!=null)throw Error(X(92));if(Array.isArray(n)){if(!(1>=n.length))throw Error(X(93));n=n[0]}e=n}e==null&&(e=""),n=e}t._wrapperState={initialValue:fr(n)}}function l0(t,e){var n=fr(e.value),r=fr(e.defaultValue);n!=null&&(n=""+n,n!==t.value&&(t.value=n),e.defaultValue==null&&t.defaultValue!==n&&(t.defaultValue=n)),r!=null&&(t.defaultValue=""+r)}function c0(t){var e=t.textContent;e===t._wrapperState.initialValue&&e!==""&&e!==null&&(t.value=e)}var mp={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};function u0(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function gp(t,e){return t==null||t==="http://www.w3.org/1999/xhtml"?u0(e):t==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":t}var ql,d0=function(t){return typeof MSApp!="undefined"&&MSApp.execUnsafeLocalFunction?function(e,n,r,s){MSApp.execUnsafeLocalFunction(function(){return t(e,n,r,s)})}:t}(function(t,e){if(t.namespaceURI!==mp.svg||"innerHTML"in t)t.innerHTML=e;else{for(ql=ql||document.createElement("div"),ql.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=ql.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}});function aa(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&n.nodeType===3){n.nodeValue=e;return}}t.textContent=e}var ia={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ck=["Webkit","ms","Moz","O"];Object.keys(ia).forEach(function(t){ck.forEach(function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),ia[e]=ia[t]})});function f0(t,e,n){return e==null||typeof e=="boolean"||e===""?"":n||typeof e!="number"||e===0||ia.hasOwnProperty(t)&&ia[t]?(""+e).trim():e+"px"}function p0(t,e){t=t.style;for(var n in e)if(e.hasOwnProperty(n)){var r=n.indexOf("--")===0,s=f0(n,e[n],r);n==="float"&&(n="cssFloat"),r?t.setProperty(n,s):t[n]=s}}var uk=Ve({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function xp(t,e){if(e){if(uk[t]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(X(137,t));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(X(60));if(!(typeof e.dangerouslySetInnerHTML=="object"&&"__html"in e.dangerouslySetInnerHTML))throw Error(X(61))}if(e.style!=null&&typeof e.style!="object")throw Error(X(62))}}function yp(t,e){if(t.indexOf("-")===-1)return typeof e.is=="string";switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function vp(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var wp=null,Ks=null,qs=null;function h0(t){if(t=Ia(t)){if(typeof wp!="function")throw Error(X(280));var e=t.stateNode;e&&(e=fc(e),wp(t.stateNode,t.type,e))}}function m0(t){Ks?qs?qs.push(t):qs=[t]:Ks=t}function g0(){if(Ks){var t=Ks,e=qs;if(qs=Ks=null,h0(t),e)for(t=0;t<e.length;t++)h0(e[t])}}function $p(t,e){return t(e)}function x0(t,e,n,r,s){return t(e,n,r,s)}function bp(){}var y0=$p,Jr=!1,Cp=!1;function kp(){(Ks!==null||qs!==null)&&(bp(),g0())}function dk(t,e,n){if(Cp)return t(e,n);Cp=!0;try{return y0(t,e,n)}finally{Cp=!1,kp()}}function la(t,e){var n=t.stateNode;if(n===null)return null;var r=fc(n);if(r===null)return null;n=r[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(t=t.type,r=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!r;break e;default:t=!1}if(t)return null;if(n&&typeof n!="function")throw Error(X(231,e,typeof n));return n}var Sp=!1;if(Hn)try{var ca={};Object.defineProperty(ca,"passive",{get:function(){Sp=!0}}),window.addEventListener("test",ca,ca),window.removeEventListener("test",ca,ca)}catch{Sp=!1}function fk(t,e,n,r,s,o,a,i,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(n,c)}catch(u){this.onError(u)}}var ua=!1,Xl=null,Yl=!1,Ip=null,pk={onError:function(t){ua=!0,Xl=t}};function hk(t,e,n,r,s,o,a,i,l){ua=!1,Xl=null,fk.apply(pk,arguments)}function mk(t,e,n,r,s,o,a,i,l){if(hk.apply(this,arguments),ua){if(ua){var c=Xl;ua=!1,Xl=null}else throw Error(X(198));Yl||(Yl=!0,Ip=c)}}function es(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do e=t,(e.flags&1026)!=0&&(n=e.return),t=e.return;while(t)}return e.tag===3?n:null}function v0(t){if(t.tag===13){var e=t.memoizedState;if(e===null&&(t=t.alternate,t!==null&&(e=t.memoizedState)),e!==null)return e.dehydrated}return null}function w0(t){if(es(t)!==t)throw Error(X(188))}function gk(t){var e=t.alternate;if(!e){if(e=es(t),e===null)throw Error(X(188));return e!==t?null:t}for(var n=t,r=e;;){var s=n.return;if(s===null)break;var o=s.alternate;if(o===null){if(r=s.return,r!==null){n=r;continue}break}if(s.child===o.child){for(o=s.child;o;){if(o===n)return w0(s),t;if(o===r)return w0(s),e;o=o.sibling}throw Error(X(188))}if(n.return!==r.return)n=s,r=o;else{for(var a=!1,i=s.child;i;){if(i===n){a=!0,n=s,r=o;break}if(i===r){a=!0,r=s,n=o;break}i=i.sibling}if(!a){for(i=o.child;i;){if(i===n){a=!0,n=o,r=s;break}if(i===r){a=!0,r=o,n=s;break}i=i.sibling}if(!a)throw Error(X(189))}}if(n.alternate!==r)throw Error(X(190))}if(n.tag!==3)throw Error(X(188));return n.stateNode.current===n?t:e}function $0(t){if(t=gk(t),!t)return null;for(var e=t;;){if(e.tag===5||e.tag===6)return e;if(e.child)e.child.return=e,e=e.child;else{if(e===t)break;for(;!e.sibling;){if(!e.return||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}}return null}function b0(t,e){for(var n=t.alternate;e!==null;){if(e===t||e===n)return!0;e=e.return}return!1}var C0,Ep,k0,S0,Tp=!1,En=[],pr=null,hr=null,mr=null,da=new Map,fa=new Map,pa=[],I0="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Np(t,e,n,r,s){return{blockedOn:t,domEventName:e,eventSystemFlags:n|16,nativeEvent:s,targetContainers:[r]}}function E0(t,e){switch(t){case"focusin":case"focusout":pr=null;break;case"dragenter":case"dragleave":hr=null;break;case"mouseover":case"mouseout":mr=null;break;case"pointerover":case"pointerout":da.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":fa.delete(e.pointerId)}}function ha(t,e,n,r,s,o){return t===null||t.nativeEvent!==o?(t=Np(e,n,r,s,o),e!==null&&(e=Ia(e),e!==null&&Ep(e)),t):(t.eventSystemFlags|=r,e=t.targetContainers,s!==null&&e.indexOf(s)===-1&&e.push(s),t)}function xk(t,e,n,r,s){switch(e){case"focusin":return pr=ha(pr,t,e,n,r,s),!0;case"dragenter":return hr=ha(hr,t,e,n,r,s),!0;case"mouseover":return mr=ha(mr,t,e,n,r,s),!0;case"pointerover":var o=s.pointerId;return da.set(o,ha(da.get(o)||null,t,e,n,r,s)),!0;case"gotpointercapture":return o=s.pointerId,fa.set(o,ha(fa.get(o)||null,t,e,n,r,s)),!0}return!1}function yk(t){var e=ts(t.target);if(e!==null){var n=es(e);if(n!==null){if(e=n.tag,e===13){if(e=v0(n),e!==null){t.blockedOn=e,S0(t.lanePriority,function(){it.unstable_runWithPriority(t.priority,function(){k0(n)})});return}}else if(e===3&&n.stateNode.hydrate){t.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}t.blockedOn=null}function Ql(t){if(t.blockedOn!==null)return!1;for(var e=t.targetContainers;0<e.length;){var n=Pp(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(n!==null)return e=Ia(n),e!==null&&Ep(e),t.blockedOn=n,!1;e.shift()}return!0}function T0(t,e,n){Ql(t)&&n.delete(e)}function vk(){for(Tp=!1;0<En.length;){var t=En[0];if(t.blockedOn!==null){t=Ia(t.blockedOn),t!==null&&C0(t);break}for(var e=t.targetContainers;0<e.length;){var n=Pp(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(n!==null){t.blockedOn=n;break}e.shift()}t.blockedOn===null&&En.shift()}pr!==null&&Ql(pr)&&(pr=null),hr!==null&&Ql(hr)&&(hr=null),mr!==null&&Ql(mr)&&(mr=null),da.forEach(T0),fa.forEach(T0)}function ma(t,e){t.blockedOn===e&&(t.blockedOn=null,Tp||(Tp=!0,it.unstable_scheduleCallback(it.unstable_NormalPriority,vk)))}function N0(t){function e(s){return ma(s,t)}if(0<En.length){ma(En[0],t);for(var n=1;n<En.length;n++){var r=En[n];r.blockedOn===t&&(r.blockedOn=null)}}for(pr!==null&&ma(pr,t),hr!==null&&ma(hr,t),mr!==null&&ma(mr,t),da.forEach(e),fa.forEach(e),n=0;n<pa.length;n++)r=pa[n],r.blockedOn===t&&(r.blockedOn=null);for(;0<pa.length&&(n=pa[0],n.blockedOn===null);)yk(n),n.blockedOn===null&&pa.shift()}function Zl(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var Xs={animationend:Zl("Animation","AnimationEnd"),animationiteration:Zl("Animation","AnimationIteration"),animationstart:Zl("Animation","AnimationStart"),transitionend:Zl("Transition","TransitionEnd")},Rp={},R0={};Hn&&(R0=document.createElement("div").style,"AnimationEvent"in window||(delete Xs.animationend.animation,delete Xs.animationiteration.animation,delete Xs.animationstart.animation),"TransitionEvent"in window||delete Xs.transitionend.transition);function Jl(t){if(Rp[t])return Rp[t];if(!Xs[t])return t;var e=Xs[t],n;for(n in e)if(e.hasOwnProperty(n)&&n in R0)return Rp[t]=e[n];return t}var D0=Jl("animationend"),F0=Jl("animationiteration"),A0=Jl("animationstart"),_0=Jl("transitionend"),P0=new Map,Dp=new Map,wk=["abort","abort",D0,"animationEnd",F0,"animationIteration",A0,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",_0,"transitionEnd","waiting","waiting"];function Fp(t,e){for(var n=0;n<t.length;n+=2){var r=t[n],s=t[n+1];s="on"+(s[0].toUpperCase()+s.slice(1)),Dp.set(r,e),P0.set(r,s),Yr(s,[r])}}var $k=it.unstable_now;$k();var Re=8;function Ys(t){if((1&t)!=0)return Re=15,1;if((2&t)!=0)return Re=14,2;if((4&t)!=0)return Re=13,4;var e=24&t;return e!==0?(Re=12,e):(t&32)!=0?(Re=11,32):(e=192&t,e!==0?(Re=10,e):(t&256)!=0?(Re=9,256):(e=3584&t,e!==0?(Re=8,e):(t&4096)!=0?(Re=7,4096):(e=4186112&t,e!==0?(Re=6,e):(e=62914560&t,e!==0?(Re=5,e):t&67108864?(Re=4,67108864):(t&134217728)!=0?(Re=3,134217728):(e=805306368&t,e!==0?(Re=2,e):(1073741824&t)!=0?(Re=1,1073741824):(Re=8,t))))))}function bk(t){switch(t){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}function Ck(t){switch(t){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(X(358,t))}}function ga(t,e){var n=t.pendingLanes;if(n===0)return Re=0;var r=0,s=0,o=t.expiredLanes,a=t.suspendedLanes,i=t.pingedLanes;if(o!==0)r=o,s=Re=15;else if(o=n&134217727,o!==0){var l=o&~a;l!==0?(r=Ys(l),s=Re):(i&=o,i!==0&&(r=Ys(i),s=Re))}else o=n&~a,o!==0?(r=Ys(o),s=Re):i!==0&&(r=Ys(i),s=Re);if(r===0)return 0;if(r=31-gr(r),r=n&((0>r?0:1<<r)<<1)-1,e!==0&&e!==r&&(e&a)==0){if(Ys(e),s<=Re)return e;Re=s}if(e=t.entangledLanes,e!==0)for(t=t.entanglements,e&=r;0<e;)n=31-gr(e),s=1<<n,r|=t[n],e&=~s;return r}function O0(t){return t=t.pendingLanes&-1073741825,t!==0?t:t&1073741824?1073741824:0}function ec(t,e){switch(t){case 15:return 1;case 14:return 2;case 12:return t=Qs(24&~e),t===0?ec(10,e):t;case 10:return t=Qs(192&~e),t===0?ec(8,e):t;case 8:return t=Qs(3584&~e),t===0&&(t=Qs(4186112&~e),t===0&&(t=512)),t;case 2:return e=Qs(805306368&~e),e===0&&(e=268435456),e}throw Error(X(358,t))}function Qs(t){return t&-t}function Ap(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function tc(t,e,n){t.pendingLanes|=e;var r=e-1;t.suspendedLanes&=r,t.pingedLanes&=r,t=t.eventTimes,e=31-gr(e),t[e]=n}var gr=Math.clz32?Math.clz32:Ik,kk=Math.log,Sk=Math.LN2;function Ik(t){return t===0?32:31-(kk(t)/Sk|0)|0}var Ek=it.unstable_UserBlockingPriority,Tk=it.unstable_runWithPriority,nc=!0;function Nk(t,e,n,r){Jr||bp();var s=_p,o=Jr;Jr=!0;try{x0(s,t,e,n,r)}finally{(Jr=o)||kp()}}function Rk(t,e,n,r){Tk(Ek,_p.bind(null,t,e,n,r))}function _p(t,e,n,r){if(nc){var s;if((s=(e&4)==0)&&0<En.length&&-1<I0.indexOf(t))t=Np(null,t,e,n,r),En.push(t);else{var o=Pp(t,e,n,r);if(o===null)s&&E0(t,r);else{if(s){if(-1<I0.indexOf(t)){t=Np(o,t,e,n,r),En.push(t);return}if(xk(o,t,e,n,r))return;E0(t,r)}f1(t,e,r,null,n)}}}}function Pp(t,e,n,r){var s=vp(r);if(s=ts(s),s!==null){var o=es(s);if(o===null)s=null;else{var a=o.tag;if(a===13){if(s=v0(o),s!==null)return s;s=null}else if(a===3){if(o.stateNode.hydrate)return o.tag===3?o.stateNode.containerInfo:null;s=null}else o!==s&&(s=null)}}return f1(t,e,r,s,n),null}var xr=null,Op=null,rc=null;function M0(){if(rc)return rc;var t,e=Op,n=e.length,r,s="value"in xr?xr.value:xr.textContent,o=s.length;for(t=0;t<n&&e[t]===s[t];t++);var a=n-t;for(r=1;r<=a&&e[n-r]===s[o-r];r++);return rc=s.slice(t,1<r?1-r:void 0)}function sc(t){var e=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&e===13&&(t=13)):t=e,t===10&&(t=13),32<=t||t===13?t:0}function oc(){return!0}function L0(){return!1}function qt(t){function e(n,r,s,o,a){this._reactName=n,this._targetInst=s,this.type=r,this.nativeEvent=o,this.target=a,this.currentTarget=null;for(var i in t)t.hasOwnProperty(i)&&(n=t[i],this[i]=n?n(o):o[i]);return this.isDefaultPrevented=(o.defaultPrevented!=null?o.defaultPrevented:o.returnValue===!1)?oc:L0,this.isPropagationStopped=L0,this}return Ve(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=oc)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=oc)},persist:function(){},isPersistent:oc}),e}var Zs={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Mp=qt(Zs),xa=Ve({},Zs,{view:0,detail:0}),Dk=qt(xa),Lp,Bp,ya,ac=Ve({},xa,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Wp,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==ya&&(ya&&t.type==="mousemove"?(Lp=t.screenX-ya.screenX,Bp=t.screenY-ya.screenY):Bp=Lp=0,ya=t),Lp)},movementY:function(t){return"movementY"in t?t.movementY:Bp}}),B0=qt(ac),Fk=Ve({},ac,{dataTransfer:0}),Ak=qt(Fk),_k=Ve({},xa,{relatedTarget:0}),Vp=qt(_k),Pk=Ve({},Zs,{animationName:0,elapsedTime:0,pseudoElement:0}),Ok=qt(Pk),Mk=Ve({},Zs,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),Lk=qt(Mk),Bk=Ve({},Zs,{data:0}),V0=qt(Bk),Vk={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Wk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},zk={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Uk(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):(t=zk[t])?!!e[t]:!1}function Wp(){return Uk}var Gk=Ve({},xa,{key:function(t){if(t.key){var e=Vk[t.key]||t.key;if(e!=="Unidentified")return e}return t.type==="keypress"?(t=sc(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?Wk[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Wp,charCode:function(t){return t.type==="keypress"?sc(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?sc(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),Hk=qt(Gk),jk=Ve({},ac,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),W0=qt(jk),Kk=Ve({},xa,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Wp}),qk=qt(Kk),Xk=Ve({},Zs,{propertyName:0,elapsedTime:0,pseudoElement:0}),Yk=qt(Xk),Qk=Ve({},ac,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),Zk=qt(Qk),Jk=[9,13,27,32],zp=Hn&&"CompositionEvent"in window,va=null;Hn&&"documentMode"in document&&(va=document.documentMode);var e2=Hn&&"TextEvent"in window&&!va,z0=Hn&&(!zp||va&&8<va&&11>=va),U0=String.fromCharCode(32),G0=!1;function H0(t,e){switch(t){case"keyup":return Jk.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function j0(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var Js=!1;function t2(t,e){switch(t){case"compositionend":return j0(e);case"keypress":return e.which!==32?null:(G0=!0,U0);case"textInput":return t=e.data,t===U0&&G0?null:t;default:return null}}function n2(t,e){if(Js)return t==="compositionend"||!zp&&H0(t,e)?(t=M0(),rc=Op=xr=null,Js=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return z0&&e.locale!=="ko"?null:e.data;default:return null}}var r2={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function K0(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e==="input"?!!r2[t.type]:e==="textarea"}function q0(t,e,n,r){m0(r),e=lc(e,"onChange"),0<e.length&&(n=new Mp("onChange","change",null,n,r),t.push({event:n,listeners:e}))}var wa=null,$a=null;function s2(t){i1(t,0)}function ic(t){var e=so(t);if(r0(e))return t}function o2(t,e){if(t==="change")return e}var X0=!1;if(Hn){var Up;if(Hn){var Gp="oninput"in document;if(!Gp){var Y0=document.createElement("div");Y0.setAttribute("oninput","return;"),Gp=typeof Y0.oninput=="function"}Up=Gp}else Up=!1;X0=Up&&(!document.documentMode||9<document.documentMode)}function Q0(){wa&&(wa.detachEvent("onpropertychange",Z0),$a=wa=null)}function Z0(t){if(t.propertyName==="value"&&ic($a)){var e=[];if(q0(e,$a,t,vp(t)),t=s2,Jr)t(e);else{Jr=!0;try{$p(t,e)}finally{Jr=!1,kp()}}}}function a2(t,e,n){t==="focusin"?(Q0(),wa=e,$a=n,wa.attachEvent("onpropertychange",Z0)):t==="focusout"&&Q0()}function i2(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return ic($a)}function l2(t,e){if(t==="click")return ic(e)}function c2(t,e){if(t==="input"||t==="change")return ic(e)}function u2(t,e){return t===e&&(t!==0||1/t==1/e)||t!==t&&e!==e}var rn=typeof Object.is=="function"?Object.is:u2,d2=Object.prototype.hasOwnProperty;function ba(t,e){if(rn(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;var n=Object.keys(t),r=Object.keys(e);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++)if(!d2.call(e,n[r])||!rn(t[n[r]],e[n[r]]))return!1;return!0}function J0(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function e1(t,e){var n=J0(t);t=0;for(var r;n;){if(n.nodeType===3){if(r=t+n.textContent.length,t<=e&&r>=e)return{node:n,offset:e-t};t=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=J0(n)}}function t1(t,e){return t&&e?t===e?!0:t&&t.nodeType===3?!1:e&&e.nodeType===3?t1(t,e.parentNode):"contains"in t?t.contains(e):t.compareDocumentPosition?!!(t.compareDocumentPosition(e)&16):!1:!1}function n1(){for(var t=window,e=Kl();e instanceof t.HTMLIFrameElement;){try{var n=typeof e.contentWindow.location.href=="string"}catch{n=!1}if(n)t=e.contentWindow;else break;e=Kl(t.document)}return e}function Hp(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&(e==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||e==="textarea"||t.contentEditable==="true")}var f2=Hn&&"documentMode"in document&&11>=document.documentMode,eo=null,jp=null,Ca=null,Kp=!1;function r1(t,e,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;Kp||eo==null||eo!==Kl(r)||(r=eo,"selectionStart"in r&&Hp(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Ca&&ba(Ca,r)||(Ca=r,r=lc(jp,"onSelect"),0<r.length&&(e=new Mp("onSelect","select",null,e,n),t.push({event:e,listeners:r}),e.target=eo)))}Fp("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0);Fp("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Fp(wk,2);for(var s1="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),qp=0;qp<s1.length;qp++)Dp.set(s1[qp],0);Gs("onMouseEnter",["mouseout","mouseover"]);Gs("onMouseLeave",["mouseout","mouseover"]);Gs("onPointerEnter",["pointerout","pointerover"]);Gs("onPointerLeave",["pointerout","pointerover"]);Yr("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Yr("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Yr("onBeforeInput",["compositionend","keypress","textInput","paste"]);Yr("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Yr("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Yr("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var ka="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),o1=new Set("cancel close invalid load scroll toggle".split(" ").concat(ka));function a1(t,e,n){var r=t.type||"unknown-event";t.currentTarget=n,mk(r,e,void 0,t),t.currentTarget=null}function i1(t,e){e=(e&4)!=0;for(var n=0;n<t.length;n++){var r=t[n],s=r.event;r=r.listeners;e:{var o=void 0;if(e)for(var a=r.length-1;0<=a;a--){var i=r[a],l=i.instance,c=i.currentTarget;if(i=i.listener,l!==o&&s.isPropagationStopped())break e;a1(s,i,c),o=l}else for(a=0;a<r.length;a++){if(i=r[a],l=i.instance,c=i.currentTarget,i=i.listener,l!==o&&s.isPropagationStopped())break e;a1(s,i,c),o=l}}}if(Yl)throw t=Ip,Yl=!1,Ip=null,t}function Pe(t,e){var n=y1(e),r=t+"__bubble";n.has(r)||(d1(e,t,2,!1),n.add(r))}var l1="_reactListening"+Math.random().toString(36).slice(2);function c1(t){t[l1]||(t[l1]=!0,Yx.forEach(function(e){o1.has(e)||u1(e,!1,t,null),u1(e,!0,t,null)}))}function u1(t,e,n,r){var s=4<arguments.length&&arguments[4]!==void 0?arguments[4]:0,o=n;if(t==="selectionchange"&&n.nodeType!==9&&(o=n.ownerDocument),r!==null&&!e&&o1.has(t)){if(t!=="scroll")return;s|=2,o=r}var a=y1(o),i=t+"__"+(e?"capture":"bubble");a.has(i)||(e&&(s|=4),d1(o,t,s,e),a.add(i))}function d1(t,e,n,r){var s=Dp.get(e);switch(s===void 0?2:s){case 0:s=Nk;break;case 1:s=Rk;break;default:s=_p}n=s.bind(null,e,n,t),s=void 0,!Sp||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(s=!0),r?s!==void 0?t.addEventListener(e,n,{capture:!0,passive:s}):t.addEventListener(e,n,!0):s!==void 0?t.addEventListener(e,n,{passive:s}):t.addEventListener(e,n,!1)}function f1(t,e,n,r,s){var o=r;if((e&1)==0&&(e&2)==0&&r!==null)e:for(;;){if(r===null)return;var a=r.tag;if(a===3||a===4){var i=r.stateNode.containerInfo;if(i===s||i.nodeType===8&&i.parentNode===s)break;if(a===4)for(a=r.return;a!==null;){var l=a.tag;if((l===3||l===4)&&(l=a.stateNode.containerInfo,l===s||l.nodeType===8&&l.parentNode===s))return;a=a.return}for(;i!==null;){if(a=ts(i),a===null)return;if(l=a.tag,l===5||l===6){r=o=a;continue e}i=i.parentNode}}r=r.return}dk(function(){var c=o,u=vp(n),d=[];e:{var f=P0.get(t);if(f!==void 0){var p=Mp,h=t;switch(t){case"keypress":if(sc(n)===0)break e;case"keydown":case"keyup":p=Hk;break;case"focusin":h="focus",p=Vp;break;case"focusout":h="blur",p=Vp;break;case"beforeblur":case"afterblur":p=Vp;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=B0;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=Ak;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=qk;break;case D0:case F0:case A0:p=Ok;break;case _0:p=Yk;break;case"scroll":p=Dk;break;case"wheel":p=Zk;break;case"copy":case"cut":case"paste":p=Lk;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=W0}var g=(e&4)!=0,m=!g&&t==="scroll",x=g?f!==null?f+"Capture":null:f;g=[];for(var y=c,w;y!==null;){w=y;var v=w.stateNode;if(w.tag===5&&v!==null&&(w=v,x!==null&&(v=la(y,x),v!=null&&g.push(Sa(y,v,w)))),m)break;y=y.return}0<g.length&&(f=new p(f,h,null,n,u),d.push({event:f,listeners:g}))}}if((e&7)==0){e:{if(f=t==="mouseover"||t==="pointerover",p=t==="mouseout"||t==="pointerout",f&&(e&16)==0&&(h=n.relatedTarget||n.fromElement)&&(ts(h)||h[ro]))break e;if((p||f)&&(f=u.window===u?u:(f=u.ownerDocument)?f.defaultView||f.parentWindow:window,p?(h=n.relatedTarget||n.toElement,p=c,h=h?ts(h):null,h!==null&&(m=es(h),h!==m||h.tag!==5&&h.tag!==6)&&(h=null)):(p=null,h=c),p!==h)){if(g=B0,v="onMouseLeave",x="onMouseEnter",y="mouse",(t==="pointerout"||t==="pointerover")&&(g=W0,v="onPointerLeave",x="onPointerEnter",y="pointer"),m=p==null?f:so(p),w=h==null?f:so(h),f=new g(v,y+"leave",p,n,u),f.target=m,f.relatedTarget=w,v=null,ts(u)===c&&(g=new g(x,y+"enter",h,n,u),g.target=w,g.relatedTarget=m,v=g),m=v,p&&h)t:{for(g=p,x=h,y=0,w=g;w;w=to(w))y++;for(w=0,v=x;v;v=to(v))w++;for(;0<y-w;)g=to(g),y--;for(;0<w-y;)x=to(x),w--;for(;y--;){if(g===x||x!==null&&g===x.alternate)break t;g=to(g),x=to(x)}g=null}else g=null;p!==null&&p1(d,f,p,g,!1),h!==null&&m!==null&&p1(d,m,h,g,!0)}}e:{if(f=c?so(c):window,p=f.nodeName&&f.nodeName.toLowerCase(),p==="select"||p==="input"&&f.type==="file")var $=o2;else if(K0(f))if(X0)$=c2;else{$=i2;var b=a2}else(p=f.nodeName)&&p.toLowerCase()==="input"&&(f.type==="checkbox"||f.type==="radio")&&($=l2);if($&&($=$(t,c))){q0(d,$,n,u);break e}b&&b(t,f,c),t==="focusout"&&(b=f._wrapperState)&&b.controlled&&f.type==="number"&&fp(f,"number",f.value)}switch(b=c?so(c):window,t){case"focusin":(K0(b)||b.contentEditable==="true")&&(eo=b,jp=c,Ca=null);break;case"focusout":Ca=jp=eo=null;break;case"mousedown":Kp=!0;break;case"contextmenu":case"mouseup":case"dragend":Kp=!1,r1(d,n,u);break;case"selectionchange":if(f2)break;case"keydown":case"keyup":r1(d,n,u)}var C;if(zp)e:{switch(t){case"compositionstart":var I="onCompositionStart";break e;case"compositionend":I="onCompositionEnd";break e;case"compositionupdate":I="onCompositionUpdate";break e}I=void 0}else Js?H0(t,n)&&(I="onCompositionEnd"):t==="keydown"&&n.keyCode===229&&(I="onCompositionStart");I&&(z0&&n.locale!=="ko"&&(Js||I!=="onCompositionStart"?I==="onCompositionEnd"&&Js&&(C=M0()):(xr=u,Op="value"in xr?xr.value:xr.textContent,Js=!0)),b=lc(c,I),0<b.length&&(I=new V0(I,t,null,n,u),d.push({event:I,listeners:b}),C?I.data=C:(C=j0(n),C!==null&&(I.data=C)))),(C=e2?t2(t,n):n2(t,n))&&(c=lc(c,"onBeforeInput"),0<c.length&&(u=new V0("onBeforeInput","beforeinput",null,n,u),d.push({event:u,listeners:c}),u.data=C))}i1(d,e)})}function Sa(t,e,n){return{instance:t,listener:e,currentTarget:n}}function lc(t,e){for(var n=e+"Capture",r=[];t!==null;){var s=t,o=s.stateNode;s.tag===5&&o!==null&&(s=o,o=la(t,n),o!=null&&r.unshift(Sa(t,o,s)),o=la(t,e),o!=null&&r.push(Sa(t,o,s))),t=t.return}return r}function to(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5);return t||null}function p1(t,e,n,r,s){for(var o=e._reactName,a=[];n!==null&&n!==r;){var i=n,l=i.alternate,c=i.stateNode;if(l!==null&&l===r)break;i.tag===5&&c!==null&&(i=c,s?(l=la(n,o),l!=null&&a.unshift(Sa(n,l,i))):s||(l=la(n,o),l!=null&&a.push(Sa(n,l,i)))),n=n.return}a.length!==0&&t.push({event:e,listeners:a})}function cc(){}var Xp=null,Yp=null;function h1(t,e){switch(t){case"button":case"input":case"select":case"textarea":return!!e.autoFocus}return!1}function Qp(t,e){return t==="textarea"||t==="option"||t==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var m1=typeof setTimeout=="function"?setTimeout:void 0,p2=typeof clearTimeout=="function"?clearTimeout:void 0;function Zp(t){t.nodeType===1?t.textContent="":t.nodeType===9&&(t=t.body,t!=null&&(t.textContent=""))}function no(t){for(;t!=null;t=t.nextSibling){var e=t.nodeType;if(e===1||e===3)break}return t}function g1(t){t=t.previousSibling;for(var e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="$"||n==="$!"||n==="$?"){if(e===0)return t;e--}else n==="/$"&&e++}t=t.previousSibling}return null}var Jp=0;function h2(t){return{$$typeof:op,toString:t,valueOf:t}}var uc=Math.random().toString(36).slice(2),yr="__reactFiber$"+uc,dc="__reactProps$"+uc,ro="__reactContainer$"+uc,x1="__reactEvents$"+uc;function ts(t){var e=t[yr];if(e)return e;for(var n=t.parentNode;n;){if(e=n[ro]||n[yr]){if(n=e.alternate,e.child!==null||n!==null&&n.child!==null)for(t=g1(t);t!==null;){if(n=t[yr])return n;t=g1(t)}return e}t=n,n=t.parentNode}return null}function Ia(t){return t=t[yr]||t[ro],!t||t.tag!==5&&t.tag!==6&&t.tag!==13&&t.tag!==3?null:t}function so(t){if(t.tag===5||t.tag===6)return t.stateNode;throw Error(X(33))}function fc(t){return t[dc]||null}function y1(t){var e=t[x1];return e===void 0&&(e=t[x1]=new Set),e}var eh=[],oo=-1;function vr(t){return{current:t}}function Oe(t){0>oo||(t.current=eh[oo],eh[oo]=null,oo--)}function He(t,e){oo++,eh[oo]=t.current,t.current=e}var wr={},wt=vr(wr),Pt=vr(!1),ns=wr;function ao(t,e){var n=t.type.contextTypes;if(!n)return wr;var r=t.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var s={},o;for(o in n)s[o]=e[o];return r&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=s),s}function Ot(t){return t=t.childContextTypes,t!=null}function pc(){Oe(Pt),Oe(wt)}function v1(t,e,n){if(wt.current!==wr)throw Error(X(168));He(wt,e),He(Pt,n)}function w1(t,e,n){var r=t.stateNode;if(t=e.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var s in r)if(!(s in t))throw Error(X(108,Hs(e)||"Unknown",s));return Ve({},n,r)}function hc(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||wr,ns=wt.current,He(wt,t),He(Pt,Pt.current),!0}function $1(t,e,n){var r=t.stateNode;if(!r)throw Error(X(169));n?(t=w1(t,e,ns),r.__reactInternalMemoizedMergedChildContext=t,Oe(Pt),Oe(wt),He(wt,t)):Oe(Pt),He(Pt,n)}var th=null,rs=null,m2=it.unstable_runWithPriority,nh=it.unstable_scheduleCallback,rh=it.unstable_cancelCallback,g2=it.unstable_shouldYield,b1=it.unstable_requestPaint,sh=it.unstable_now,x2=it.unstable_getCurrentPriorityLevel,mc=it.unstable_ImmediatePriority,C1=it.unstable_UserBlockingPriority,k1=it.unstable_NormalPriority,S1=it.unstable_LowPriority,I1=it.unstable_IdlePriority,oh={},y2=b1!==void 0?b1:function(){},jn=null,gc=null,ah=!1,E1=sh(),$t=1e4>E1?sh:function(){return sh()-E1};function io(){switch(x2()){case mc:return 99;case C1:return 98;case k1:return 97;case S1:return 96;case I1:return 95;default:throw Error(X(332))}}function T1(t){switch(t){case 99:return mc;case 98:return C1;case 97:return k1;case 96:return S1;case 95:return I1;default:throw Error(X(332))}}function ss(t,e){return t=T1(t),m2(t,e)}function Ea(t,e,n){return t=T1(t),nh(t,e,n)}function Tn(){if(gc!==null){var t=gc;gc=null,rh(t)}N1()}function N1(){if(!ah&&jn!==null){ah=!0;var t=0;try{var e=jn;ss(99,function(){for(;t<e.length;t++){var n=e[t];do n=n(!0);while(n!==null)}}),jn=null}catch(n){throw jn!==null&&(jn=jn.slice(t+1)),nh(mc,Tn),n}finally{ah=!1}}}var v2=Qr.ReactCurrentBatchConfig;function yn(t,e){if(t&&t.defaultProps){e=Ve({},e),t=t.defaultProps;for(var n in t)e[n]===void 0&&(e[n]=t[n]);return e}return e}var xc=vr(null),yc=null,lo=null,vc=null;function ih(){vc=lo=yc=null}function lh(t){var e=xc.current;Oe(xc),t.type._context._currentValue=e}function R1(t,e){for(;t!==null;){var n=t.alternate;if((t.childLanes&e)===e){if(n===null||(n.childLanes&e)===e)break;n.childLanes|=e}else t.childLanes|=e,n!==null&&(n.childLanes|=e);t=t.return}}function co(t,e){yc=t,vc=lo=null,t=t.dependencies,t!==null&&t.firstContext!==null&&((t.lanes&e)!=0&&(vn=!0),t.firstContext=null)}function sn(t,e){if(vc!==t&&e!==!1&&e!==0)if((typeof e!="number"||e===1073741823)&&(vc=t,e=1073741823),e={context:t,observedBits:e,next:null},lo===null){if(yc===null)throw Error(X(308));lo=e,yc.dependencies={lanes:0,firstContext:e,responders:null}}else lo=lo.next=e;return t._currentValue}var $r=!1;function ch(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function D1(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function br(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function Cr(t,e){if(t=t.updateQueue,t!==null){t=t.shared;var n=t.pending;n===null?e.next=e:(e.next=n.next,n.next=e),t.pending=e}}function F1(t,e){var n=t.updateQueue,r=t.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var s=null,o=null;if(n=n.firstBaseUpdate,n!==null){do{var a={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};o===null?s=o=a:o=o.next=a,n=n.next}while(n!==null);o===null?s=o=e:o=o.next=e}else s=o=e;n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:o,shared:r.shared,effects:r.effects},t.updateQueue=n;return}t=n.lastBaseUpdate,t===null?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function Ta(t,e,n,r){var s=t.updateQueue;$r=!1;var o=s.firstBaseUpdate,a=s.lastBaseUpdate,i=s.shared.pending;if(i!==null){s.shared.pending=null;var l=i,c=l.next;l.next=null,a===null?o=c:a.next=c,a=l;var u=t.alternate;if(u!==null){u=u.updateQueue;var d=u.lastBaseUpdate;d!==a&&(d===null?u.firstBaseUpdate=c:d.next=c,u.lastBaseUpdate=l)}}if(o!==null){d=s.baseState,a=0,u=c=l=null;do{i=o.lane;var f=o.eventTime;if((r&i)===i){u!==null&&(u=u.next={eventTime:f,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var p=t,h=o;switch(i=e,f=n,h.tag){case 1:if(p=h.payload,typeof p=="function"){d=p.call(f,d,i);break e}d=p;break e;case 3:p.flags=p.flags&-4097|64;case 0:if(p=h.payload,i=typeof p=="function"?p.call(f,d,i):p,i==null)break e;d=Ve({},d,i);break e;case 2:$r=!0}}o.callback!==null&&(t.flags|=32,i=s.effects,i===null?s.effects=[o]:i.push(o))}else f={eventTime:f,lane:i,tag:o.tag,payload:o.payload,callback:o.callback,next:null},u===null?(c=u=f,l=d):u=u.next=f,a|=i;if(o=o.next,o===null){if(i=s.shared.pending,i===null)break;o=i.next,i.next=null,s.lastBaseUpdate=i,s.shared.pending=null}}while(1);u===null&&(l=d),s.baseState=l,s.firstBaseUpdate=c,s.lastBaseUpdate=u,Va|=a,t.lanes=a,t.memoizedState=d}}function A1(t,e,n){if(t=e.effects,e.effects=null,t!==null)for(e=0;e<t.length;e++){var r=t[e],s=r.callback;if(s!==null){if(r.callback=null,r=n,typeof s!="function")throw Error(X(191,s));s.call(r)}}}var _1=new Wl.Component().refs;function wc(t,e,n,r){e=t.memoizedState,n=n(r,e),n=n==null?e:Ve({},e,n),t.memoizedState=n,t.lanes===0&&(t.updateQueue.baseState=n)}var $c={isMounted:function(t){return(t=t._reactInternals)?es(t)===t:!1},enqueueSetState:function(t,e,n){t=t._reactInternals;var r=Xt(),s=Ir(t),o=br(r,s);o.payload=e,n!=null&&(o.callback=n),Cr(t,o),Er(t,s,r)},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var r=Xt(),s=Ir(t),o=br(r,s);o.tag=1,o.payload=e,n!=null&&(o.callback=n),Cr(t,o),Er(t,s,r)},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=Xt(),r=Ir(t),s=br(n,r);s.tag=2,e!=null&&(s.callback=e),Cr(t,s),Er(t,r,n)}};function P1(t,e,n,r,s,o,a){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(r,o,a):e.prototype&&e.prototype.isPureReactComponent?!ba(n,r)||!ba(s,o):!0}function O1(t,e,n){var r=!1,s=wr,o=e.contextType;return typeof o=="object"&&o!==null?o=sn(o):(s=Ot(e)?ns:wt.current,r=e.contextTypes,o=(r=r!=null)?ao(t,s):wr),e=new e(n,o),t.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=$c,t.stateNode=e,e._reactInternals=t,r&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=s,t.__reactInternalMemoizedMaskedChildContext=o),e}function M1(t,e,n,r){t=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(n,r),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(n,r),e.state!==t&&$c.enqueueReplaceState(e,e.state,null)}function uh(t,e,n,r){var s=t.stateNode;s.props=n,s.state=t.memoizedState,s.refs=_1,ch(t);var o=e.contextType;typeof o=="object"&&o!==null?s.context=sn(o):(o=Ot(e)?ns:wt.current,s.context=ao(t,o)),Ta(t,n,s,r),s.state=t.memoizedState,o=e.getDerivedStateFromProps,typeof o=="function"&&(wc(t,e,o,n),s.state=t.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof s.getSnapshotBeforeUpdate=="function"||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(e=s.state,typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount(),e!==s.state&&$c.enqueueReplaceState(s,s.state,null),Ta(t,n,s,r),s.state=t.memoizedState),typeof s.componentDidMount=="function"&&(t.flags|=4)}var bc=Array.isArray;function Na(t,e,n){if(t=n.ref,t!==null&&typeof t!="function"&&typeof t!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(X(309));var r=n.stateNode}if(!r)throw Error(X(147,t));var s=""+t;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===s?e.ref:(e=function(o){var a=r.refs;a===_1&&(a=r.refs={}),o===null?delete a[s]:a[s]=o},e._stringRef=s,e)}if(typeof t!="string")throw Error(X(284));if(!n._owner)throw Error(X(290,t))}return t}function Cc(t,e){if(t.type!=="textarea")throw Error(X(31,Object.prototype.toString.call(e)==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":e))}function L1(t){function e(m,x){if(t){var y=m.lastEffect;y!==null?(y.nextEffect=x,m.lastEffect=x):m.firstEffect=m.lastEffect=x,x.nextEffect=null,x.flags=8}}function n(m,x){if(!t)return null;for(;x!==null;)e(m,x),x=x.sibling;return null}function r(m,x){for(m=new Map;x!==null;)x.key!==null?m.set(x.key,x):m.set(x.index,x),x=x.sibling;return m}function s(m,x){return m=Rr(m,x),m.index=0,m.sibling=null,m}function o(m,x,y){return m.index=y,t?(y=m.alternate,y!==null?(y=y.index,y<x?(m.flags=2,x):y):(m.flags=2,x)):x}function a(m){return t&&m.alternate===null&&(m.flags=2),m}function i(m,x,y,w){return x===null||x.tag!==6?(x=jh(y,m.mode,w),x.return=m,x):(x=s(x,y),x.return=m,x)}function l(m,x,y,w){return x!==null&&x.elementType===y.type?(w=s(x,y.props),w.ref=Na(m,x,y),w.return=m,w):(w=Wc(y.type,y.key,y.props,null,m.mode,w),w.ref=Na(m,x,y),w.return=m,w)}function c(m,x,y,w){return x===null||x.tag!==4||x.stateNode.containerInfo!==y.containerInfo||x.stateNode.implementation!==y.implementation?(x=Kh(y,m.mode,w),x.return=m,x):(x=s(x,y.children||[]),x.return=m,x)}function u(m,x,y,w,v){return x===null||x.tag!==7?(x=yo(y,m.mode,w,v),x.return=m,x):(x=s(x,y),x.return=m,x)}function d(m,x,y){if(typeof x=="string"||typeof x=="number")return x=jh(""+x,m.mode,y),x.return=m,x;if(typeof x=="object"&&x!==null){switch(x.$$typeof){case ta:return y=Wc(x.type,x.key,x.props,null,m.mode,y),y.ref=Na(m,null,x),y.return=m,y;case Zr:return x=Kh(x,m.mode,y),x.return=m,x}if(bc(x)||sa(x))return x=yo(x,m.mode,y,null),x.return=m,x;Cc(m,x)}return null}function f(m,x,y,w){var v=x!==null?x.key:null;if(typeof y=="string"||typeof y=="number")return v!==null?null:i(m,x,""+y,w);if(typeof y=="object"&&y!==null){switch(y.$$typeof){case ta:return y.key===v?y.type===dr?u(m,x,y.props.children,w,v):l(m,x,y,w):null;case Zr:return y.key===v?c(m,x,y,w):null}if(bc(y)||sa(y))return v!==null?null:u(m,x,y,w,null);Cc(m,y)}return null}function p(m,x,y,w,v){if(typeof w=="string"||typeof w=="number")return m=m.get(y)||null,i(x,m,""+w,v);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case ta:return m=m.get(w.key===null?y:w.key)||null,w.type===dr?u(x,m,w.props.children,v,w.key):l(x,m,w,v);case Zr:return m=m.get(w.key===null?y:w.key)||null,c(x,m,w,v)}if(bc(w)||sa(w))return m=m.get(y)||null,u(x,m,w,v,null);Cc(x,w)}return null}function h(m,x,y,w){for(var v=null,$=null,b=x,C=x=0,I=null;b!==null&&C<y.length;C++){b.index>C?(I=b,b=null):I=b.sibling;var E=f(m,b,y[C],w);if(E===null){b===null&&(b=I);break}t&&b&&E.alternate===null&&e(m,b),x=o(E,x,C),$===null?v=E:$.sibling=E,$=E,b=I}if(C===y.length)return n(m,b),v;if(b===null){for(;C<y.length;C++)b=d(m,y[C],w),b!==null&&(x=o(b,x,C),$===null?v=b:$.sibling=b,$=b);return v}for(b=r(m,b);C<y.length;C++)I=p(b,m,C,y[C],w),I!==null&&(t&&I.alternate!==null&&b.delete(I.key===null?C:I.key),x=o(I,x,C),$===null?v=I:$.sibling=I,$=I);return t&&b.forEach(function(T){return e(m,T)}),v}function g(m,x,y,w){var v=sa(y);if(typeof v!="function")throw Error(X(150));if(y=v.call(y),y==null)throw Error(X(151));for(var $=v=null,b=x,C=x=0,I=null,E=y.next();b!==null&&!E.done;C++,E=y.next()){b.index>C?(I=b,b=null):I=b.sibling;var T=f(m,b,E.value,w);if(T===null){b===null&&(b=I);break}t&&b&&T.alternate===null&&e(m,b),x=o(T,x,C),$===null?v=T:$.sibling=T,$=T,b=I}if(E.done)return n(m,b),v;if(b===null){for(;!E.done;C++,E=y.next())E=d(m,E.value,w),E!==null&&(x=o(E,x,C),$===null?v=E:$.sibling=E,$=E);return v}for(b=r(m,b);!E.done;C++,E=y.next())E=p(b,m,C,E.value,w),E!==null&&(t&&E.alternate!==null&&b.delete(E.key===null?C:E.key),x=o(E,x,C),$===null?v=E:$.sibling=E,$=E);return t&&b.forEach(function(D){return e(m,D)}),v}return function(m,x,y,w){var v=typeof y=="object"&&y!==null&&y.type===dr&&y.key===null;v&&(y=y.props.children);var $=typeof y=="object"&&y!==null;if($)switch(y.$$typeof){case ta:e:{for($=y.key,v=x;v!==null;){if(v.key===$){switch(v.tag){case 7:if(y.type===dr){n(m,v.sibling),x=s(v,y.props.children),x.return=m,m=x;break e}break;default:if(v.elementType===y.type){n(m,v.sibling),x=s(v,y.props),x.ref=Na(m,v,y),x.return=m,m=x;break e}}n(m,v);break}else e(m,v);v=v.sibling}y.type===dr?(x=yo(y.props.children,m.mode,w,y.key),x.return=m,m=x):(w=Wc(y.type,y.key,y.props,null,m.mode,w),w.ref=Na(m,x,y),w.return=m,m=w)}return a(m);case Zr:e:{for(v=y.key;x!==null;){if(x.key===v)if(x.tag===4&&x.stateNode.containerInfo===y.containerInfo&&x.stateNode.implementation===y.implementation){n(m,x.sibling),x=s(x,y.children||[]),x.return=m,m=x;break e}else{n(m,x);break}else e(m,x);x=x.sibling}x=Kh(y,m.mode,w),x.return=m,m=x}return a(m)}if(typeof y=="string"||typeof y=="number")return y=""+y,x!==null&&x.tag===6?(n(m,x.sibling),x=s(x,y),x.return=m,m=x):(n(m,x),x=jh(y,m.mode,w),x.return=m,m=x),a(m);if(bc(y))return h(m,x,y,w);if(sa(y))return g(m,x,y,w);if($&&Cc(m,y),typeof y=="undefined"&&!v)switch(m.tag){case 1:case 22:case 0:case 11:case 15:throw Error(X(152,Hs(m.type)||"Component"))}return n(m,x)}}var kc=L1(!0),B1=L1(!1),Ra={},Nn=vr(Ra),Da=vr(Ra),Fa=vr(Ra);function os(t){if(t===Ra)throw Error(X(174));return t}function dh(t,e){switch(He(Fa,e),He(Da,t),He(Nn,Ra),t=e.nodeType,t){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:gp(null,"");break;default:t=t===8?e.parentNode:e,e=t.namespaceURI||null,t=t.tagName,e=gp(e,t)}Oe(Nn),He(Nn,e)}function uo(){Oe(Nn),Oe(Da),Oe(Fa)}function V1(t){os(Fa.current);var e=os(Nn.current),n=gp(e,t.type);e!==n&&(He(Da,t),He(Nn,n))}function fh(t){Da.current===t&&(Oe(Nn),Oe(Da))}var je=vr(0);function Sc(t){for(var e=t;e!==null;){if(e.tag===13){var n=e.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if((e.flags&64)!=0)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Kn=null,kr=null,Rn=!1;function W1(t,e){var n=ln(5,null,null,0);n.elementType="DELETED",n.type="DELETED",n.stateNode=e,n.return=t,n.flags=8,t.lastEffect!==null?(t.lastEffect.nextEffect=n,t.lastEffect=n):t.firstEffect=t.lastEffect=n}function z1(t,e){switch(t.tag){case 5:var n=t.type;return e=e.nodeType!==1||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(t.stateNode=e,!0):!1;case 6:return e=t.pendingProps===""||e.nodeType!==3?null:e,e!==null?(t.stateNode=e,!0):!1;case 13:return!1;default:return!1}}function ph(t){if(Rn){var e=kr;if(e){var n=e;if(!z1(t,e)){if(e=no(n.nextSibling),!e||!z1(t,e)){t.flags=t.flags&-1025|2,Rn=!1,Kn=t;return}W1(Kn,n)}Kn=t,kr=no(e.firstChild)}else t.flags=t.flags&-1025|2,Rn=!1,Kn=t}}function U1(t){for(t=t.return;t!==null&&t.tag!==5&&t.tag!==3&&t.tag!==13;)t=t.return;Kn=t}function Ic(t){if(t!==Kn)return!1;if(!Rn)return U1(t),Rn=!0,!1;var e=t.type;if(t.tag!==5||e!=="head"&&e!=="body"&&!Qp(e,t.memoizedProps))for(e=kr;e;)W1(t,e),e=no(e.nextSibling);if(U1(t),t.tag===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(X(317));e:{for(t=t.nextSibling,e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="/$"){if(e===0){kr=no(t.nextSibling);break e}e--}else n!=="$"&&n!=="$!"&&n!=="$?"||e++}t=t.nextSibling}kr=null}}else kr=Kn?no(t.stateNode.nextSibling):null;return!0}function hh(){kr=Kn=null,Rn=!1}var fo=[];function mh(){for(var t=0;t<fo.length;t++)fo[t]._workInProgressVersionPrimary=null;fo.length=0}var Aa=Qr.ReactCurrentDispatcher,on=Qr.ReactCurrentBatchConfig,_a=0,Ke=null,bt=null,gt=null,Ec=!1,Pa=!1;function Mt(){throw Error(X(321))}function gh(t,e){if(e===null)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!rn(t[n],e[n]))return!1;return!0}function xh(t,e,n,r,s,o){if(_a=o,Ke=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,Aa.current=t===null||t.memoizedState===null?$2:b2,t=n(r,s),Pa){o=0;do{if(Pa=!1,!(25>o))throw Error(X(301));o+=1,gt=bt=null,e.updateQueue=null,Aa.current=C2,t=n(r,s)}while(Pa)}if(Aa.current=Dc,e=bt!==null&&bt.next!==null,_a=0,gt=bt=Ke=null,Ec=!1,e)throw Error(X(300));return t}function as(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return gt===null?Ke.memoizedState=gt=t:gt=gt.next=t,gt}function is(){if(bt===null){var t=Ke.alternate;t=t!==null?t.memoizedState:null}else t=bt.next;var e=gt===null?Ke.memoizedState:gt.next;if(e!==null)gt=e,bt=t;else{if(t===null)throw Error(X(310));bt=t,t={memoizedState:bt.memoizedState,baseState:bt.baseState,baseQueue:bt.baseQueue,queue:bt.queue,next:null},gt===null?Ke.memoizedState=gt=t:gt=gt.next=t}return gt}function Dn(t,e){return typeof e=="function"?e(t):e}function Oa(t){var e=is(),n=e.queue;if(n===null)throw Error(X(311));n.lastRenderedReducer=t;var r=bt,s=r.baseQueue,o=n.pending;if(o!==null){if(s!==null){var a=s.next;s.next=o.next,o.next=a}r.baseQueue=s=o,n.pending=null}if(s!==null){s=s.next,r=r.baseState;var i=a=o=null,l=s;do{var c=l.lane;if((_a&c)===c)i!==null&&(i=i.next={lane:0,action:l.action,eagerReducer:l.eagerReducer,eagerState:l.eagerState,next:null}),r=l.eagerReducer===t?l.eagerState:t(r,l.action);else{var u={lane:c,action:l.action,eagerReducer:l.eagerReducer,eagerState:l.eagerState,next:null};i===null?(a=i=u,o=r):i=i.next=u,Ke.lanes|=c,Va|=c}l=l.next}while(l!==null&&l!==s);i===null?o=r:i.next=a,rn(r,e.memoizedState)||(vn=!0),e.memoizedState=r,e.baseState=o,e.baseQueue=i,n.lastRenderedState=r}return[e.memoizedState,n.dispatch]}function Ma(t){var e=is(),n=e.queue;if(n===null)throw Error(X(311));n.lastRenderedReducer=t;var r=n.dispatch,s=n.pending,o=e.memoizedState;if(s!==null){n.pending=null;var a=s=s.next;do o=t(o,a.action),a=a.next;while(a!==s);rn(o,e.memoizedState)||(vn=!0),e.memoizedState=o,e.baseQueue===null&&(e.baseState=o),n.lastRenderedState=o}return[o,r]}function G1(t,e,n){var r=e._getVersion;r=r(e._source);var s=e._workInProgressVersionPrimary;if(s!==null?t=s===r:(t=t.mutableReadLanes,(t=(_a&t)===t)&&(e._workInProgressVersionPrimary=r,fo.push(e))),t)return n(e._source);throw fo.push(e),Error(X(350))}function H1(t,e,n,r){var s=Ft;if(s===null)throw Error(X(349));var o=e._getVersion,a=o(e._source),i=Aa.current,l=i.useState(function(){return G1(s,e,n)}),c=l[1],u=l[0];l=gt;var d=t.memoizedState,f=d.refs,p=f.getSnapshot,h=d.source;d=d.subscribe;var g=Ke;return t.memoizedState={refs:f,source:e,subscribe:r},i.useEffect(function(){f.getSnapshot=n,f.setSnapshot=c;var m=o(e._source);if(!rn(a,m)){m=n(e._source),rn(u,m)||(c(m),m=Ir(g),s.mutableReadLanes|=m&s.pendingLanes),m=s.mutableReadLanes,s.entangledLanes|=m;for(var x=s.entanglements,y=m;0<y;){var w=31-gr(y),v=1<<w;x[w]|=m,y&=~v}}},[n,e,r]),i.useEffect(function(){return r(e._source,function(){var m=f.getSnapshot,x=f.setSnapshot;try{x(m(e._source));var y=Ir(g);s.mutableReadLanes|=y&s.pendingLanes}catch(w){x(function(){throw w})}})},[e,r]),rn(p,n)&&rn(h,e)&&rn(d,r)||(t={pending:null,dispatch:null,lastRenderedReducer:Dn,lastRenderedState:u},t.dispatch=c=$h.bind(null,Ke,t),l.queue=t,l.baseQueue=null,u=G1(s,e,n),l.memoizedState=l.baseState=u),u}function j1(t,e,n){var r=is();return H1(r,t,e,n)}function La(t){var e=as();return typeof t=="function"&&(t=t()),e.memoizedState=e.baseState=t,t=e.queue={pending:null,dispatch:null,lastRenderedReducer:Dn,lastRenderedState:t},t=t.dispatch=$h.bind(null,Ke,t),[e.memoizedState,t]}function Tc(t,e,n,r){return t={tag:t,create:e,destroy:n,deps:r,next:null},e=Ke.updateQueue,e===null?(e={lastEffect:null},Ke.updateQueue=e,e.lastEffect=t.next=t):(n=e.lastEffect,n===null?e.lastEffect=t.next=t:(r=n.next,n.next=t,t.next=r,e.lastEffect=t)),t}function K1(t){var e=as();return t={current:t},e.memoizedState=t}function Nc(){return is().memoizedState}function yh(t,e,n,r){var s=as();Ke.flags|=t,s.memoizedState=Tc(1|e,n,void 0,r===void 0?null:r)}function vh(t,e,n,r){var s=is();r=r===void 0?null:r;var o=void 0;if(bt!==null){var a=bt.memoizedState;if(o=a.destroy,r!==null&&gh(r,a.deps)){Tc(e,n,o,r);return}}Ke.flags|=t,s.memoizedState=Tc(1|e,n,o,r)}function q1(t,e){return yh(516,4,t,e)}function Rc(t,e){return vh(516,4,t,e)}function X1(t,e){return vh(4,2,t,e)}function Y1(t,e){if(typeof e=="function")return t=t(),e(t),function(){e(null)};if(e!=null)return t=t(),e.current=t,function(){e.current=null}}function Q1(t,e,n){return n=n!=null?n.concat([t]):null,vh(4,2,Y1.bind(null,e,t),n)}function wh(){}function Z1(t,e){var n=is();e=e===void 0?null:e;var r=n.memoizedState;return r!==null&&e!==null&&gh(e,r[1])?r[0]:(n.memoizedState=[t,e],t)}function J1(t,e){var n=is();e=e===void 0?null:e;var r=n.memoizedState;return r!==null&&e!==null&&gh(e,r[1])?r[0]:(t=t(),n.memoizedState=[t,e],t)}function w2(t,e){var n=io();ss(98>n?98:n,function(){t(!0)}),ss(97<n?97:n,function(){var r=on.transition;on.transition=1;try{t(!1),e()}finally{on.transition=r}})}function $h(t,e,n){var r=Xt(),s=Ir(t),o={lane:s,action:n,eagerReducer:null,eagerState:null,next:null},a=e.pending;if(a===null?o.next=o:(o.next=a.next,a.next=o),e.pending=o,a=t.alternate,t===Ke||a!==null&&a===Ke)Pa=Ec=!0;else{if(t.lanes===0&&(a===null||a.lanes===0)&&(a=e.lastRenderedReducer,a!==null))try{var i=e.lastRenderedState,l=a(i,n);if(o.eagerReducer=a,o.eagerState=l,rn(l,i))return}catch{}finally{}Er(t,s,r)}}var Dc={readContext:sn,useCallback:Mt,useContext:Mt,useEffect:Mt,useImperativeHandle:Mt,useLayoutEffect:Mt,useMemo:Mt,useReducer:Mt,useRef:Mt,useState:Mt,useDebugValue:Mt,useDeferredValue:Mt,useTransition:Mt,useMutableSource:Mt,useOpaqueIdentifier:Mt,unstable_isNewReconciler:!1},$2={readContext:sn,useCallback:function(t,e){return as().memoizedState=[t,e===void 0?null:e],t},useContext:sn,useEffect:q1,useImperativeHandle:function(t,e,n){return n=n!=null?n.concat([t]):null,yh(4,2,Y1.bind(null,e,t),n)},useLayoutEffect:function(t,e){return yh(4,2,t,e)},useMemo:function(t,e){var n=as();return e=e===void 0?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var r=as();return e=n!==void 0?n(e):e,r.memoizedState=r.baseState=e,t=r.queue={pending:null,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},t=t.dispatch=$h.bind(null,Ke,t),[r.memoizedState,t]},useRef:K1,useState:La,useDebugValue:wh,useDeferredValue:function(t){var e=La(t),n=e[0],r=e[1];return q1(function(){var s=on.transition;on.transition=1;try{r(t)}finally{on.transition=s}},[t]),n},useTransition:function(){var t=La(!1),e=t[0];return t=w2.bind(null,t[1]),K1(t),[t,e]},useMutableSource:function(t,e,n){var r=as();return r.memoizedState={refs:{getSnapshot:e,setSnapshot:null},source:t,subscribe:n},H1(r,t,e,n)},useOpaqueIdentifier:function(){if(Rn){var t=!1,e=h2(function(){throw t||(t=!0,n("r:"+(Jp++).toString(36))),Error(X(355))}),n=La(e)[1];return(Ke.mode&2)==0&&(Ke.flags|=516,Tc(5,function(){n("r:"+(Jp++).toString(36))},void 0,null)),e}return e="r:"+(Jp++).toString(36),La(e),e},unstable_isNewReconciler:!1},b2={readContext:sn,useCallback:Z1,useContext:sn,useEffect:Rc,useImperativeHandle:Q1,useLayoutEffect:X1,useMemo:J1,useReducer:Oa,useRef:Nc,useState:function(){return Oa(Dn)},useDebugValue:wh,useDeferredValue:function(t){var e=Oa(Dn),n=e[0],r=e[1];return Rc(function(){var s=on.transition;on.transition=1;try{r(t)}finally{on.transition=s}},[t]),n},useTransition:function(){var t=Oa(Dn)[0];return[Nc().current,t]},useMutableSource:j1,useOpaqueIdentifier:function(){return Oa(Dn)[0]},unstable_isNewReconciler:!1},C2={readContext:sn,useCallback:Z1,useContext:sn,useEffect:Rc,useImperativeHandle:Q1,useLayoutEffect:X1,useMemo:J1,useReducer:Ma,useRef:Nc,useState:function(){return Ma(Dn)},useDebugValue:wh,useDeferredValue:function(t){var e=Ma(Dn),n=e[0],r=e[1];return Rc(function(){var s=on.transition;on.transition=1;try{r(t)}finally{on.transition=s}},[t]),n},useTransition:function(){var t=Ma(Dn)[0];return[Nc().current,t]},useMutableSource:j1,useOpaqueIdentifier:function(){return Ma(Dn)[0]},unstable_isNewReconciler:!1},k2=Qr.ReactCurrentOwner,vn=!1;function Lt(t,e,n,r){e.child=t===null?B1(e,null,n,r):kc(e,t.child,n,r)}function ey(t,e,n,r,s){n=n.render;var o=e.ref;return co(e,s),r=xh(t,e,n,r,o,s),t!==null&&!vn?(e.updateQueue=t.updateQueue,e.flags&=-517,t.lanes&=~s,qn(t,e,s)):(e.flags|=1,Lt(t,e,r,s),e.child)}function ty(t,e,n,r,s,o){if(t===null){var a=n.type;return typeof a=="function"&&!Gh(a)&&a.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(e.tag=15,e.type=a,ny(t,e,a,r,s,o)):(t=Wc(n.type,null,r,e,e.mode,o),t.ref=e.ref,t.return=e,e.child=t)}return a=t.child,(s&o)==0&&(s=a.memoizedProps,n=n.compare,n=n!==null?n:ba,n(s,r)&&t.ref===e.ref)?qn(t,e,o):(e.flags|=1,t=Rr(a,r),t.ref=e.ref,t.return=e,e.child=t)}function ny(t,e,n,r,s,o){if(t!==null&&ba(t.memoizedProps,r)&&t.ref===e.ref)if(vn=!1,(o&s)!=0)(t.flags&16384)!=0&&(vn=!0);else return e.lanes=t.lanes,qn(t,e,o);return Ch(t,e,n,r,o)}function bh(t,e,n){var r=e.pendingProps,s=r.children,o=t!==null?t.memoizedState:null;if(r.mode==="hidden"||r.mode==="unstable-defer-without-hiding")if((e.mode&4)==0)e.memoizedState={baseLanes:0},Vc(e,n);else if((n&1073741824)!=0)e.memoizedState={baseLanes:0},Vc(e,o!==null?o.baseLanes:n);else return t=o!==null?o.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t},Vc(e,t),null;else o!==null?(r=o.baseLanes|n,e.memoizedState=null):r=n,Vc(e,r);return Lt(t,e,s,n),e.child}function ry(t,e){var n=e.ref;(t===null&&n!==null||t!==null&&t.ref!==n)&&(e.flags|=128)}function Ch(t,e,n,r,s){var o=Ot(n)?ns:wt.current;return o=ao(e,o),co(e,s),n=xh(t,e,n,r,o,s),t!==null&&!vn?(e.updateQueue=t.updateQueue,e.flags&=-517,t.lanes&=~s,qn(t,e,s)):(e.flags|=1,Lt(t,e,n,s),e.child)}function sy(t,e,n,r,s){if(Ot(n)){var o=!0;hc(e)}else o=!1;if(co(e,s),e.stateNode===null)t!==null&&(t.alternate=null,e.alternate=null,e.flags|=2),O1(e,n,r),uh(e,n,r,s),r=!0;else if(t===null){var a=e.stateNode,i=e.memoizedProps;a.props=i;var l=a.context,c=n.contextType;typeof c=="object"&&c!==null?c=sn(c):(c=Ot(n)?ns:wt.current,c=ao(e,c));var u=n.getDerivedStateFromProps,d=typeof u=="function"||typeof a.getSnapshotBeforeUpdate=="function";d||typeof a.UNSAFE_componentWillReceiveProps!="function"&&typeof a.componentWillReceiveProps!="function"||(i!==r||l!==c)&&M1(e,a,r,c),$r=!1;var f=e.memoizedState;a.state=f,Ta(e,r,a,s),l=e.memoizedState,i!==r||f!==l||Pt.current||$r?(typeof u=="function"&&(wc(e,n,u,r),l=e.memoizedState),(i=$r||P1(e,n,i,r,f,l,c))?(d||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount()),typeof a.componentDidMount=="function"&&(e.flags|=4)):(typeof a.componentDidMount=="function"&&(e.flags|=4),e.memoizedProps=r,e.memoizedState=l),a.props=r,a.state=l,a.context=c,r=i):(typeof a.componentDidMount=="function"&&(e.flags|=4),r=!1)}else{a=e.stateNode,D1(t,e),i=e.memoizedProps,c=e.type===e.elementType?i:yn(e.type,i),a.props=c,d=e.pendingProps,f=a.context,l=n.contextType,typeof l=="object"&&l!==null?l=sn(l):(l=Ot(n)?ns:wt.current,l=ao(e,l));var p=n.getDerivedStateFromProps;(u=typeof p=="function"||typeof a.getSnapshotBeforeUpdate=="function")||typeof a.UNSAFE_componentWillReceiveProps!="function"&&typeof a.componentWillReceiveProps!="function"||(i!==d||f!==l)&&M1(e,a,r,l),$r=!1,f=e.memoizedState,a.state=f,Ta(e,r,a,s);var h=e.memoizedState;i!==d||f!==h||Pt.current||$r?(typeof p=="function"&&(wc(e,n,p,r),h=e.memoizedState),(c=$r||P1(e,n,c,r,f,h,l))?(u||typeof a.UNSAFE_componentWillUpdate!="function"&&typeof a.componentWillUpdate!="function"||(typeof a.componentWillUpdate=="function"&&a.componentWillUpdate(r,h,l),typeof a.UNSAFE_componentWillUpdate=="function"&&a.UNSAFE_componentWillUpdate(r,h,l)),typeof a.componentDidUpdate=="function"&&(e.flags|=4),typeof a.getSnapshotBeforeUpdate=="function"&&(e.flags|=256)):(typeof a.componentDidUpdate!="function"||i===t.memoizedProps&&f===t.memoizedState||(e.flags|=4),typeof a.getSnapshotBeforeUpdate!="function"||i===t.memoizedProps&&f===t.memoizedState||(e.flags|=256),e.memoizedProps=r,e.memoizedState=h),a.props=r,a.state=h,a.context=l,r=c):(typeof a.componentDidUpdate!="function"||i===t.memoizedProps&&f===t.memoizedState||(e.flags|=4),typeof a.getSnapshotBeforeUpdate!="function"||i===t.memoizedProps&&f===t.memoizedState||(e.flags|=256),r=!1)}return kh(t,e,n,r,o,s)}function kh(t,e,n,r,s,o){ry(t,e);var a=(e.flags&64)!=0;if(!r&&!a)return s&&$1(e,n,!1),qn(t,e,o);r=e.stateNode,k2.current=e;var i=a&&typeof n.getDerivedStateFromError!="function"?null:r.render();return e.flags|=1,t!==null&&a?(e.child=kc(e,t.child,null,o),e.child=kc(e,null,i,o)):Lt(t,e,i,o),e.memoizedState=r.state,s&&$1(e,n,!0),e.child}function oy(t){var e=t.stateNode;e.pendingContext?v1(t,e.pendingContext,e.pendingContext!==e.context):e.context&&v1(t,e.context,!1),dh(t,e.containerInfo)}var Fc={dehydrated:null,retryLane:0};function ay(t,e,n){var r=e.pendingProps,s=je.current,o=!1,a;return(a=(e.flags&64)!=0)||(a=t!==null&&t.memoizedState===null?!1:(s&2)!=0),a?(o=!0,e.flags&=-65):t!==null&&t.memoizedState===null||r.fallback===void 0||r.unstable_avoidThisFallback===!0||(s|=1),He(je,s&1),t===null?(r.fallback!==void 0&&ph(e),t=r.children,s=r.fallback,o?(t=iy(e,t,s,n),e.child.memoizedState={baseLanes:n},e.memoizedState=Fc,t):typeof r.unstable_expectedLoadTime=="number"?(t=iy(e,t,s,n),e.child.memoizedState={baseLanes:n},e.memoizedState=Fc,e.lanes=33554432,t):(n=Hh({mode:"visible",children:t},e.mode,n,null),n.return=e,e.child=n)):t.memoizedState!==null?o?(r=cy(t,e,r.children,r.fallback,n),o=e.child,s=t.child.memoizedState,o.memoizedState=s===null?{baseLanes:n}:{baseLanes:s.baseLanes|n},o.childLanes=t.childLanes&~n,e.memoizedState=Fc,r):(n=ly(t,e,r.children,n),e.memoizedState=null,n):o?(r=cy(t,e,r.children,r.fallback,n),o=e.child,s=t.child.memoizedState,o.memoizedState=s===null?{baseLanes:n}:{baseLanes:s.baseLanes|n},o.childLanes=t.childLanes&~n,e.memoizedState=Fc,r):(n=ly(t,e,r.children,n),e.memoizedState=null,n)}function iy(t,e,n,r){var s=t.mode,o=t.child;return e={mode:"hidden",children:e},(s&2)==0&&o!==null?(o.childLanes=0,o.pendingProps=e):o=Hh(e,s,0,null),n=yo(n,s,r,null),o.return=t,n.return=t,o.sibling=n,t.child=o,n}function ly(t,e,n,r){var s=t.child;return t=s.sibling,n=Rr(s,{mode:"visible",children:n}),(e.mode&2)==0&&(n.lanes=r),n.return=e,n.sibling=null,t!==null&&(t.nextEffect=null,t.flags=8,e.firstEffect=e.lastEffect=t),e.child=n}function cy(t,e,n,r,s){var o=e.mode,a=t.child;t=a.sibling;var i={mode:"hidden",children:n};return(o&2)==0&&e.child!==a?(n=e.child,n.childLanes=0,n.pendingProps=i,a=n.lastEffect,a!==null?(e.firstEffect=n.firstEffect,e.lastEffect=a,a.nextEffect=null):e.firstEffect=e.lastEffect=null):n=Rr(a,i),t!==null?r=Rr(t,r):(r=yo(r,o,s,null),r.flags|=2),r.return=e,n.return=e,n.sibling=r,e.child=n,r}function uy(t,e){t.lanes|=e;var n=t.alternate;n!==null&&(n.lanes|=e),R1(t.return,e)}function Sh(t,e,n,r,s,o){var a=t.memoizedState;a===null?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s,lastEffect:o}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s,a.lastEffect=o)}function dy(t,e,n){var r=e.pendingProps,s=r.revealOrder,o=r.tail;if(Lt(t,e,r.children,n),r=je.current,(r&2)!=0)r=r&1|2,e.flags|=64;else{if(t!==null&&(t.flags&64)!=0)e:for(t=e.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&uy(t,n);else if(t.tag===19)uy(t,n);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;t=t.return}t.sibling.return=t.return,t=t.sibling}r&=1}if(He(je,r),(e.mode&2)==0)e.memoizedState=null;else switch(s){case"forwards":for(n=e.child,s=null;n!==null;)t=n.alternate,t!==null&&Sc(t)===null&&(s=n),n=n.sibling;n=s,n===null?(s=e.child,e.child=null):(s=n.sibling,n.sibling=null),Sh(e,!1,s,n,o,e.lastEffect);break;case"backwards":for(n=null,s=e.child,e.child=null;s!==null;){if(t=s.alternate,t!==null&&Sc(t)===null){e.child=s;break}t=s.sibling,s.sibling=n,n=s,s=t}Sh(e,!0,n,null,o,e.lastEffect);break;case"together":Sh(e,!1,null,null,void 0,e.lastEffect);break;default:e.memoizedState=null}return e.child}function qn(t,e,n){if(t!==null&&(e.dependencies=t.dependencies),Va|=e.lanes,(n&e.childLanes)!=0){if(t!==null&&e.child!==t.child)throw Error(X(153));if(e.child!==null){for(t=e.child,n=Rr(t,t.pendingProps),e.child=n,n.return=e;t.sibling!==null;)t=t.sibling,n=n.sibling=Rr(t,t.pendingProps),n.return=e;n.sibling=null}return e.child}return null}var fy,Ih,py,hy;fy=function(t,e){for(var n=e.child;n!==null;){if(n.tag===5||n.tag===6)t.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break;for(;n.sibling===null;){if(n.return===null||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};Ih=function(){};py=function(t,e,n,r){var s=t.memoizedProps;if(s!==r){t=e.stateNode,os(Nn.current);var o=null;switch(n){case"input":s=up(t,s),r=up(t,r),o=[];break;case"option":s=pp(t,s),r=pp(t,r),o=[];break;case"select":s=Ve({},s,{value:void 0}),r=Ve({},r,{value:void 0}),o=[];break;case"textarea":s=hp(t,s),r=hp(t,r),o=[];break;default:typeof s.onClick!="function"&&typeof r.onClick=="function"&&(t.onclick=cc)}xp(n,r);var a;n=null;for(c in s)if(!r.hasOwnProperty(c)&&s.hasOwnProperty(c)&&s[c]!=null)if(c==="style"){var i=s[c];for(a in i)i.hasOwnProperty(a)&&(n||(n={}),n[a]="")}else c!=="dangerouslySetInnerHTML"&&c!=="children"&&c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(ea.hasOwnProperty(c)?o||(o=[]):(o=o||[]).push(c,null));for(c in r){var l=r[c];if(i=s!=null?s[c]:void 0,r.hasOwnProperty(c)&&l!==i&&(l!=null||i!=null))if(c==="style")if(i){for(a in i)!i.hasOwnProperty(a)||l&&l.hasOwnProperty(a)||(n||(n={}),n[a]="");for(a in l)l.hasOwnProperty(a)&&i[a]!==l[a]&&(n||(n={}),n[a]=l[a])}else n||(o||(o=[]),o.push(c,n)),n=l;else c==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,i=i?i.__html:void 0,l!=null&&i!==l&&(o=o||[]).push(c,l)):c==="children"?typeof l!="string"&&typeof l!="number"||(o=o||[]).push(c,""+l):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&(ea.hasOwnProperty(c)?(l!=null&&c==="onScroll"&&Pe("scroll",t),o||i===l||(o=[])):typeof l=="object"&&l!==null&&l.$$typeof===op?l.toString():(o=o||[]).push(c,l))}n&&(o=o||[]).push("style",n);var c=o;(e.updateQueue=c)&&(e.flags|=4)}};hy=function(t,e,n,r){n!==r&&(e.flags|=4)};function Ba(t,e){if(!Rn)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;e!==null;)e.alternate!==null&&(n=e),e=e.sibling;n===null?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?e||t.tail===null?t.tail=null:t.tail.sibling=null:r.sibling=null}}function S2(t,e,n){var r=e.pendingProps;switch(e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return Ot(e.type)&&pc(),null;case 3:return uo(),Oe(Pt),Oe(wt),mh(),r=e.stateNode,r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(t===null||t.child===null)&&(Ic(e)?e.flags|=4:r.hydrate||(e.flags|=256)),Ih(e),null;case 5:fh(e);var s=os(Fa.current);if(n=e.type,t!==null&&e.stateNode!=null)py(t,e,n,r,s),t.ref!==e.ref&&(e.flags|=128);else{if(!r){if(e.stateNode===null)throw Error(X(166));return null}if(t=os(Nn.current),Ic(e)){r=e.stateNode,n=e.type;var o=e.memoizedProps;switch(r[yr]=e,r[dc]=o,n){case"dialog":Pe("cancel",r),Pe("close",r);break;case"iframe":case"object":case"embed":Pe("load",r);break;case"video":case"audio":for(t=0;t<ka.length;t++)Pe(ka[t],r);break;case"source":Pe("error",r);break;case"img":case"image":case"link":Pe("error",r),Pe("load",r);break;case"details":Pe("toggle",r);break;case"input":s0(r,o),Pe("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!o.multiple},Pe("invalid",r);break;case"textarea":i0(r,o),Pe("invalid",r)}xp(n,o),t=null;for(var a in o)o.hasOwnProperty(a)&&(s=o[a],a==="children"?typeof s=="string"?r.textContent!==s&&(t=["children",s]):typeof s=="number"&&r.textContent!==""+s&&(t=["children",""+s]):ea.hasOwnProperty(a)&&s!=null&&a==="onScroll"&&Pe("scroll",r));switch(n){case"input":jl(r),a0(r,o,!0);break;case"textarea":jl(r),c0(r);break;case"select":case"option":break;default:typeof o.onClick=="function"&&(r.onclick=cc)}r=t,e.updateQueue=r,r!==null&&(e.flags|=4)}else{switch(a=s.nodeType===9?s:s.ownerDocument,t===mp.html&&(t=u0(n)),t===mp.html?n==="script"?(t=a.createElement("div"),t.innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):typeof r.is=="string"?t=a.createElement(n,{is:r.is}):(t=a.createElement(n),n==="select"&&(a=t,r.multiple?a.multiple=!0:r.size&&(a.size=r.size))):t=a.createElementNS(t,n),t[yr]=e,t[dc]=r,fy(t,e,!1,!1),e.stateNode=t,a=yp(n,r),n){case"dialog":Pe("cancel",t),Pe("close",t),s=r;break;case"iframe":case"object":case"embed":Pe("load",t),s=r;break;case"video":case"audio":for(s=0;s<ka.length;s++)Pe(ka[s],t);s=r;break;case"source":Pe("error",t),s=r;break;case"img":case"image":case"link":Pe("error",t),Pe("load",t),s=r;break;case"details":Pe("toggle",t),s=r;break;case"input":s0(t,r),s=up(t,r),Pe("invalid",t);break;case"option":s=pp(t,r);break;case"select":t._wrapperState={wasMultiple:!!r.multiple},s=Ve({},r,{value:void 0}),Pe("invalid",t);break;case"textarea":i0(t,r),s=hp(t,r),Pe("invalid",t);break;default:s=r}xp(n,s);var i=s;for(o in i)if(i.hasOwnProperty(o)){var l=i[o];o==="style"?p0(t,l):o==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&d0(t,l)):o==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&aa(t,l):typeof l=="number"&&aa(t,""+l):o!=="suppressContentEditableWarning"&&o!=="suppressHydrationWarning"&&o!=="autoFocus"&&(ea.hasOwnProperty(o)?l!=null&&o==="onScroll"&&Pe("scroll",t):l!=null&&Jf(t,o,l,a))}switch(n){case"input":jl(t),a0(t,r,!1);break;case"textarea":jl(t),c0(t);break;case"option":r.value!=null&&t.setAttribute("value",""+fr(r.value));break;case"select":t.multiple=!!r.multiple,o=r.value,o!=null?js(t,!!r.multiple,o,!1):r.defaultValue!=null&&js(t,!!r.multiple,r.defaultValue,!0);break;default:typeof s.onClick=="function"&&(t.onclick=cc)}h1(n,r)&&(e.flags|=4)}e.ref!==null&&(e.flags|=128)}return null;case 6:if(t&&e.stateNode!=null)hy(t,e,t.memoizedProps,r);else{if(typeof r!="string"&&e.stateNode===null)throw Error(X(166));n=os(Fa.current),os(Nn.current),Ic(e)?(r=e.stateNode,n=e.memoizedProps,r[yr]=e,r.nodeValue!==n&&(e.flags|=4)):(r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[yr]=e,e.stateNode=r)}return null;case 13:return Oe(je),r=e.memoizedState,(e.flags&64)!=0?(e.lanes=n,e):(r=r!==null,n=!1,t===null?e.memoizedProps.fallback!==void 0&&Ic(e):n=t.memoizedState!==null,r&&!n&&(e.mode&2)!=0&&(t===null&&e.memoizedProps.unstable_avoidThisFallback!==!0||(je.current&1)!=0?xt===0&&(xt=3):((xt===0||xt===3)&&(xt=4),Ft===null||(Va&134217727)==0&&(ho&134217727)==0||go(Ft,Ct))),(r||n)&&(e.flags|=4),null);case 4:return uo(),Ih(e),t===null&&c1(e.stateNode.containerInfo),null;case 10:return lh(e),null;case 17:return Ot(e.type)&&pc(),null;case 19:if(Oe(je),r=e.memoizedState,r===null)return null;if(o=(e.flags&64)!=0,a=r.rendering,a===null)if(o)Ba(r,!1);else{if(xt!==0||t!==null&&(t.flags&64)!=0)for(t=e.child;t!==null;){if(a=Sc(t),a!==null){for(e.flags|=64,Ba(r,!1),o=a.updateQueue,o!==null&&(e.updateQueue=o,e.flags|=4),r.lastEffect===null&&(e.firstEffect=null),e.lastEffect=r.lastEffect,r=n,n=e.child;n!==null;)o=n,t=r,o.flags&=2,o.nextEffect=null,o.firstEffect=null,o.lastEffect=null,a=o.alternate,a===null?(o.childLanes=0,o.lanes=t,o.child=null,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=a.childLanes,o.lanes=a.lanes,o.child=a.child,o.memoizedProps=a.memoizedProps,o.memoizedState=a.memoizedState,o.updateQueue=a.updateQueue,o.type=a.type,t=a.dependencies,o.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return He(je,je.current&1|2),e.child}t=t.sibling}r.tail!==null&&$t()>Mh&&(e.flags|=64,o=!0,Ba(r,!1),e.lanes=33554432)}else{if(!o)if(t=Sc(a),t!==null){if(e.flags|=64,o=!0,n=t.updateQueue,n!==null&&(e.updateQueue=n,e.flags|=4),Ba(r,!0),r.tail===null&&r.tailMode==="hidden"&&!a.alternate&&!Rn)return e=e.lastEffect=r.lastEffect,e!==null&&(e.nextEffect=null),null}else 2*$t()-r.renderingStartTime>Mh&&n!==1073741824&&(e.flags|=64,o=!0,Ba(r,!1),e.lanes=33554432);r.isBackwards?(a.sibling=e.child,e.child=a):(n=r.last,n!==null?n.sibling=a:e.child=a,r.last=a)}return r.tail!==null?(n=r.tail,r.rendering=n,r.tail=n.sibling,r.lastEffect=e.lastEffect,r.renderingStartTime=$t(),n.sibling=null,e=je.current,He(je,o?e&1|2:e&1),n):null;case 23:case 24:return Uh(),t!==null&&t.memoizedState!==null!=(e.memoizedState!==null)&&r.mode!=="unstable-defer-without-hiding"&&(e.flags|=4),null}throw Error(X(156,e.tag))}function I2(t){switch(t.tag){case 1:Ot(t.type)&&pc();var e=t.flags;return e&4096?(t.flags=e&-4097|64,t):null;case 3:if(uo(),Oe(Pt),Oe(wt),mh(),e=t.flags,(e&64)!=0)throw Error(X(285));return t.flags=e&-4097|64,t;case 5:return fh(t),null;case 13:return Oe(je),e=t.flags,e&4096?(t.flags=e&-4097|64,t):null;case 19:return Oe(je),null;case 4:return uo(),null;case 10:return lh(t),null;case 23:case 24:return Uh(),null;default:return null}}function Eh(t,e){try{var n="",r=e;do n+=ak(r),r=r.return;while(r);var s=n}catch(o){s=`
Error generating stack: `+o.message+`
`+o.stack}return{value:t,source:e,stack:s}}function Th(t,e){try{console.error(e.value)}catch(n){setTimeout(function(){throw n})}}var E2=typeof WeakMap=="function"?WeakMap:Map;function my(t,e,n){n=br(-1,n),n.tag=3,n.payload={element:null};var r=e.value;return n.callback=function(){Pc||(Pc=!0,Lh=r),Th(t,e)},n}function gy(t,e,n){n=br(-1,n),n.tag=3;var r=t.type.getDerivedStateFromError;if(typeof r=="function"){var s=e.value;n.payload=function(){return Th(t,e),r(s)}}var o=t.stateNode;return o!==null&&typeof o.componentDidCatch=="function"&&(n.callback=function(){typeof r!="function"&&(Fn===null?Fn=new Set([this]):Fn.add(this),Th(t,e));var a=e.stack;this.componentDidCatch(e.value,{componentStack:a!==null?a:""})}),n}var T2=typeof WeakSet=="function"?WeakSet:Set;function xy(t){var e=t.ref;if(e!==null)if(typeof e=="function")try{e(null)}catch(n){Nr(t,n)}else e.current=null}function N2(t,e){switch(e.tag){case 0:case 11:case 15:case 22:return;case 1:if(e.flags&256&&t!==null){var n=t.memoizedProps,r=t.memoizedState;t=e.stateNode,e=t.getSnapshotBeforeUpdate(e.elementType===e.type?n:yn(e.type,n),r),t.__reactInternalSnapshotBeforeUpdate=e}return;case 3:e.flags&256&&Zp(e.stateNode.containerInfo);return;case 5:case 6:case 4:case 17:return}throw Error(X(163))}function R2(t,e,n){switch(n.tag){case 0:case 11:case 15:case 22:if(e=n.updateQueue,e=e!==null?e.lastEffect:null,e!==null){t=e=e.next;do{if((t.tag&3)==3){var r=t.create;t.destroy=r()}t=t.next}while(t!==e)}if(e=n.updateQueue,e=e!==null?e.lastEffect:null,e!==null){t=e=e.next;do{var s=t;r=s.next,s=s.tag,(s&4)!=0&&(s&1)!=0&&(Fy(n,t),L2(n,t)),t=r}while(t!==e)}return;case 1:t=n.stateNode,n.flags&4&&(e===null?t.componentDidMount():(r=n.elementType===n.type?e.memoizedProps:yn(n.type,e.memoizedProps),t.componentDidUpdate(r,e.memoizedState,t.__reactInternalSnapshotBeforeUpdate))),e=n.updateQueue,e!==null&&A1(n,e,t);return;case 3:if(e=n.updateQueue,e!==null){if(t=null,n.child!==null)switch(n.child.tag){case 5:t=n.child.stateNode;break;case 1:t=n.child.stateNode}A1(n,e,t)}return;case 5:t=n.stateNode,e===null&&n.flags&4&&h1(n.type,n.memoizedProps)&&t.focus();return;case 6:return;case 4:return;case 12:return;case 13:n.memoizedState===null&&(n=n.alternate,n!==null&&(n=n.memoizedState,n!==null&&(n=n.dehydrated,n!==null&&N0(n))));return;case 19:case 17:case 20:case 21:case 23:case 24:return}throw Error(X(163))}function yy(t,e){for(var n=t;;){if(n.tag===5){var r=n.stateNode;if(e)r=r.style,typeof r.setProperty=="function"?r.setProperty("display","none","important"):r.display="none";else{r=n.stateNode;var s=n.memoizedProps.style;s=s!=null&&s.hasOwnProperty("display")?s.display:null,r.style.display=f0("display",s)}}else if(n.tag===6)n.stateNode.nodeValue=e?"":n.memoizedProps;else if((n.tag!==23&&n.tag!==24||n.memoizedState===null||n===t)&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}}function vy(t,e){if(rs&&typeof rs.onCommitFiberUnmount=="function")try{rs.onCommitFiberUnmount(th,e)}catch{}switch(e.tag){case 0:case 11:case 14:case 15:case 22:if(t=e.updateQueue,t!==null&&(t=t.lastEffect,t!==null)){var n=t=t.next;do{var r=n,s=r.destroy;if(r=r.tag,s!==void 0)if((r&4)!=0)Fy(e,n);else{r=e;try{s()}catch(o){Nr(r,o)}}n=n.next}while(n!==t)}break;case 1:if(xy(e),t=e.stateNode,typeof t.componentWillUnmount=="function")try{t.props=e.memoizedProps,t.state=e.memoizedState,t.componentWillUnmount()}catch(o){Nr(e,o)}break;case 5:xy(e);break;case 4:Cy(t,e)}}function wy(t){t.alternate=null,t.child=null,t.dependencies=null,t.firstEffect=null,t.lastEffect=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.return=null,t.updateQueue=null}function $y(t){return t.tag===5||t.tag===3||t.tag===4}function by(t){e:{for(var e=t.return;e!==null;){if($y(e))break e;e=e.return}throw Error(X(160))}var n=e;switch(e=n.stateNode,n.tag){case 5:var r=!1;break;case 3:e=e.containerInfo,r=!0;break;case 4:e=e.containerInfo,r=!0;break;default:throw Error(X(161))}n.flags&16&&(aa(e,""),n.flags&=-17);e:t:for(n=t;;){for(;n.sibling===null;){if(n.return===null||$y(n.return)){n=null;break e}n=n.return}for(n.sibling.return=n.return,n=n.sibling;n.tag!==5&&n.tag!==6&&n.tag!==18;){if(n.flags&2||n.child===null||n.tag===4)continue t;n.child.return=n,n=n.child}if(!(n.flags&2)){n=n.stateNode;break e}}r?Nh(t,n,e):Rh(t,n,e)}function Nh(t,e,n){var r=t.tag,s=r===5||r===6;if(s)t=s?t.stateNode:t.stateNode.instance,e?n.nodeType===8?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(n.nodeType===8?(e=n.parentNode,e.insertBefore(t,n)):(e=n,e.appendChild(t)),n=n._reactRootContainer,n!=null||e.onclick!==null||(e.onclick=cc));else if(r!==4&&(t=t.child,t!==null))for(Nh(t,e,n),t=t.sibling;t!==null;)Nh(t,e,n),t=t.sibling}function Rh(t,e,n){var r=t.tag,s=r===5||r===6;if(s)t=s?t.stateNode:t.stateNode.instance,e?n.insertBefore(t,e):n.appendChild(t);else if(r!==4&&(t=t.child,t!==null))for(Rh(t,e,n),t=t.sibling;t!==null;)Rh(t,e,n),t=t.sibling}function Cy(t,e){for(var n=e,r=!1,s,o;;){if(!r){r=n.return;e:for(;;){if(r===null)throw Error(X(160));switch(s=r.stateNode,r.tag){case 5:o=!1;break e;case 3:s=s.containerInfo,o=!0;break e;case 4:s=s.containerInfo,o=!0;break e}r=r.return}r=!0}if(n.tag===5||n.tag===6){e:for(var a=t,i=n,l=i;;)if(vy(a,l),l.child!==null&&l.tag!==4)l.child.return=l,l=l.child;else{if(l===i)break e;for(;l.sibling===null;){if(l.return===null||l.return===i)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}o?(a=s,i=n.stateNode,a.nodeType===8?a.parentNode.removeChild(i):a.removeChild(i)):s.removeChild(n.stateNode)}else if(n.tag===4){if(n.child!==null){s=n.stateNode.containerInfo,o=!0,n.child.return=n,n=n.child;continue}}else if(vy(t,n),n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break;for(;n.sibling===null;){if(n.return===null||n.return===e)return;n=n.return,n.tag===4&&(r=!1)}n.sibling.return=n.return,n=n.sibling}}function Dh(t,e){switch(e.tag){case 0:case 11:case 14:case 15:case 22:var n=e.updateQueue;if(n=n!==null?n.lastEffect:null,n!==null){var r=n=n.next;do(r.tag&3)==3&&(t=r.destroy,r.destroy=void 0,t!==void 0&&t()),r=r.next;while(r!==n)}return;case 1:return;case 5:if(n=e.stateNode,n!=null){r=e.memoizedProps;var s=t!==null?t.memoizedProps:r;t=e.type;var o=e.updateQueue;if(e.updateQueue=null,o!==null){for(n[dc]=r,t==="input"&&r.type==="radio"&&r.name!=null&&o0(n,r),yp(t,s),e=yp(t,r),s=0;s<o.length;s+=2){var a=o[s],i=o[s+1];a==="style"?p0(n,i):a==="dangerouslySetInnerHTML"?d0(n,i):a==="children"?aa(n,i):Jf(n,a,i,e)}switch(t){case"input":dp(n,r);break;case"textarea":l0(n,r);break;case"select":t=n._wrapperState.wasMultiple,n._wrapperState.wasMultiple=!!r.multiple,o=r.value,o!=null?js(n,!!r.multiple,o,!1):t!==!!r.multiple&&(r.defaultValue!=null?js(n,!!r.multiple,r.defaultValue,!0):js(n,!!r.multiple,r.multiple?[]:"",!1))}}}return;case 6:if(e.stateNode===null)throw Error(X(162));e.stateNode.nodeValue=e.memoizedProps;return;case 3:n=e.stateNode,n.hydrate&&(n.hydrate=!1,N0(n.containerInfo));return;case 12:return;case 13:e.memoizedState!==null&&(Oh=$t(),yy(e.child,!0)),ky(e);return;case 19:ky(e);return;case 17:return;case 23:case 24:yy(e,e.memoizedState!==null);return}throw Error(X(163))}function ky(t){var e=t.updateQueue;if(e!==null){t.updateQueue=null;var n=t.stateNode;n===null&&(n=t.stateNode=new T2),e.forEach(function(r){var s=W2.bind(null,t,r);n.has(r)||(n.add(r),r.then(s,s))})}}function D2(t,e){return t!==null&&(t=t.memoizedState,t===null||t.dehydrated!==null)?(e=e.memoizedState,e!==null&&e.dehydrated===null):!1}var F2=Math.ceil,Ac=Qr.ReactCurrentDispatcher,Fh=Qr.ReactCurrentOwner,ce=0,Ft=null,nt=null,Ct=0,ls=0,Ah=vr(0),xt=0,_c=null,po=0,Va=0,ho=0,_h=0,Ph=null,Oh=0,Mh=1/0;function mo(){Mh=$t()+500}var te=null,Pc=!1,Lh=null,Fn=null,Sr=!1,Wa=null,za=90,Bh=[],Vh=[],Xn=null,Ua=0,Wh=null,Oc=-1,Yn=0,Mc=0,Ga=null,Lc=!1;function Xt(){return(ce&48)!=0?$t():Oc!==-1?Oc:Oc=$t()}function Ir(t){if(t=t.mode,(t&2)==0)return 1;if((t&4)==0)return io()===99?1:2;if(Yn===0&&(Yn=po),v2.transition!==0){Mc!==0&&(Mc=Ph!==null?Ph.pendingLanes:0),t=Yn;var e=4186112&~Mc;return e&=-e,e===0&&(t=4186112&~t,e=t&-t,e===0&&(e=8192)),e}return t=io(),(ce&4)!=0&&t===98?t=ec(12,Yn):(t=bk(t),t=ec(t,Yn)),t}function Er(t,e,n){if(50<Ua)throw Ua=0,Wh=null,Error(X(185));if(t=Bc(t,e),t===null)return null;tc(t,e,n),t===Ft&&(ho|=e,xt===4&&go(t,Ct));var r=io();e===1?(ce&8)!=0&&(ce&48)==0?zh(t):(an(t,n),ce===0&&(mo(),Tn())):((ce&4)==0||r!==98&&r!==99||(Xn===null?Xn=new Set([t]):Xn.add(t)),an(t,n)),Ph=t}function Bc(t,e){t.lanes|=e;var n=t.alternate;for(n!==null&&(n.lanes|=e),n=t,t=t.return;t!==null;)t.childLanes|=e,n=t.alternate,n!==null&&(n.childLanes|=e),n=t,t=t.return;return n.tag===3?n.stateNode:null}function an(t,e){for(var n=t.callbackNode,r=t.suspendedLanes,s=t.pingedLanes,o=t.expirationTimes,a=t.pendingLanes;0<a;){var i=31-gr(a),l=1<<i,c=o[i];if(c===-1){if((l&r)==0||(l&s)!=0){c=e,Ys(l);var u=Re;o[i]=10<=u?c+250:6<=u?c+5e3:-1}}else c<=e&&(t.expiredLanes|=l);a&=~l}if(r=ga(t,t===Ft?Ct:0),e=Re,r===0)n!==null&&(n!==oh&&rh(n),t.callbackNode=null,t.callbackPriority=0);else{if(n!==null){if(t.callbackPriority===e)return;n!==oh&&rh(n)}e===15?(n=zh.bind(null,t),jn===null?(jn=[n],gc=nh(mc,N1)):jn.push(n),n=oh):e===14?n=Ea(99,zh.bind(null,t)):(n=Ck(e),n=Ea(n,Sy.bind(null,t))),t.callbackPriority=e,t.callbackNode=n}}function Sy(t){if(Oc=-1,Mc=Yn=0,(ce&48)!=0)throw Error(X(327));var e=t.callbackNode;if(Tr()&&t.callbackNode!==e)return null;var n=ga(t,t===Ft?Ct:0);if(n===0)return null;var r=n,s=ce;ce|=16;var o=Ny();(Ft!==t||Ct!==r)&&(mo(),xo(t,r));do try{P2();break}catch(i){Ty(t,i)}while(1);if(ih(),Ac.current=o,ce=s,nt!==null?r=0:(Ft=null,Ct=0,r=xt),(po&ho)!=0)xo(t,0);else if(r!==0){if(r===2&&(ce|=64,t.hydrate&&(t.hydrate=!1,Zp(t.containerInfo)),n=O0(t),n!==0&&(r=Ha(t,n))),r===1)throw e=_c,xo(t,0),go(t,n),an(t,$t()),e;switch(t.finishedWork=t.current.alternate,t.finishedLanes=n,r){case 0:case 1:throw Error(X(345));case 2:cs(t);break;case 3:if(go(t,n),(n&62914560)===n&&(r=Oh+500-$t(),10<r)){if(ga(t,0)!==0)break;if(s=t.suspendedLanes,(s&n)!==n){Xt(),t.pingedLanes|=t.suspendedLanes&s;break}t.timeoutHandle=m1(cs.bind(null,t),r);break}cs(t);break;case 4:if(go(t,n),(n&4186112)===n)break;for(r=t.eventTimes,s=-1;0<n;){var a=31-gr(n);o=1<<a,a=r[a],a>s&&(s=a),n&=~o}if(n=s,n=$t()-n,n=(120>n?120:480>n?480:1080>n?1080:1920>n?1920:3e3>n?3e3:4320>n?4320:1960*F2(n/1960))-n,10<n){t.timeoutHandle=m1(cs.bind(null,t),n);break}cs(t);break;case 5:cs(t);break;default:throw Error(X(329))}}return an(t,$t()),t.callbackNode===e?Sy.bind(null,t):null}function go(t,e){for(e&=~_h,e&=~ho,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-gr(e),r=1<<n;t[n]=-1,e&=~r}}function zh(t){if((ce&48)!=0)throw Error(X(327));if(Tr(),t===Ft&&(t.expiredLanes&Ct)!=0){var e=Ct,n=Ha(t,e);(po&ho)!=0&&(e=ga(t,e),n=Ha(t,e))}else e=ga(t,0),n=Ha(t,e);if(t.tag!==0&&n===2&&(ce|=64,t.hydrate&&(t.hydrate=!1,Zp(t.containerInfo)),e=O0(t),e!==0&&(n=Ha(t,e))),n===1)throw n=_c,xo(t,0),go(t,e),an(t,$t()),n;return t.finishedWork=t.current.alternate,t.finishedLanes=e,cs(t),an(t,$t()),null}function A2(){if(Xn!==null){var t=Xn;Xn=null,t.forEach(function(e){e.expiredLanes|=24&e.pendingLanes,an(e,$t())})}Tn()}function Iy(t,e){var n=ce;ce|=1;try{return t(e)}finally{ce=n,ce===0&&(mo(),Tn())}}function Ey(t,e){var n=ce;ce&=-2,ce|=8;try{return t(e)}finally{ce=n,ce===0&&(mo(),Tn())}}function Vc(t,e){He(Ah,ls),ls|=e,po|=e}function Uh(){ls=Ah.current,Oe(Ah)}function xo(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(n!==-1&&(t.timeoutHandle=-1,p2(n)),nt!==null)for(n=nt.return;n!==null;){var r=n;switch(r.tag){case 1:r=r.type.childContextTypes,r!=null&&pc();break;case 3:uo(),Oe(Pt),Oe(wt),mh();break;case 5:fh(r);break;case 4:uo();break;case 13:Oe(je);break;case 19:Oe(je);break;case 10:lh(r);break;case 23:case 24:Uh()}n=n.return}Ft=t,nt=Rr(t.current,null),Ct=ls=po=e,xt=0,_c=null,_h=ho=Va=0}function Ty(t,e){do{var n=nt;try{if(ih(),Aa.current=Dc,Ec){for(var r=Ke.memoizedState;r!==null;){var s=r.queue;s!==null&&(s.pending=null),r=r.next}Ec=!1}if(_a=0,gt=bt=Ke=null,Pa=!1,Fh.current=null,n===null||n.return===null){xt=1,_c=e,nt=null;break}e:{var o=t,a=n.return,i=n,l=e;if(e=Ct,i.flags|=2048,i.firstEffect=i.lastEffect=null,l!==null&&typeof l=="object"&&typeof l.then=="function"){var c=l;if((i.mode&2)==0){var u=i.alternate;u?(i.updateQueue=u.updateQueue,i.memoizedState=u.memoizedState,i.lanes=u.lanes):(i.updateQueue=null,i.memoizedState=null)}var d=(je.current&1)!=0,f=a;do{var p;if(p=f.tag===13){var h=f.memoizedState;if(h!==null)p=h.dehydrated!==null;else{var g=f.memoizedProps;p=g.fallback===void 0?!1:g.unstable_avoidThisFallback!==!0?!0:!d}}if(p){var m=f.updateQueue;if(m===null){var x=new Set;x.add(c),f.updateQueue=x}else m.add(c);if((f.mode&2)==0){if(f.flags|=64,i.flags|=16384,i.flags&=-2981,i.tag===1)if(i.alternate===null)i.tag=17;else{var y=br(-1,1);y.tag=2,Cr(i,y)}i.lanes|=1;break e}l=void 0,i=e;var w=o.pingCache;if(w===null?(w=o.pingCache=new E2,l=new Set,w.set(c,l)):(l=w.get(c),l===void 0&&(l=new Set,w.set(c,l))),!l.has(i)){l.add(i);var v=V2.bind(null,o,c,i);c.then(v,v)}f.flags|=4096,f.lanes=e;break e}f=f.return}while(f!==null);l=Error((Hs(i.type)||"A React component")+` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`)}xt!==5&&(xt=2),l=Eh(l,i),f=a;do{switch(f.tag){case 3:o=l,f.flags|=4096,e&=-e,f.lanes|=e;var $=my(f,o,e);F1(f,$);break e;case 1:o=l;var b=f.type,C=f.stateNode;if((f.flags&64)==0&&(typeof b.getDerivedStateFromError=="function"||C!==null&&typeof C.componentDidCatch=="function"&&(Fn===null||!Fn.has(C)))){f.flags|=4096,e&=-e,f.lanes|=e;var I=gy(f,o,e);F1(f,I);break e}}f=f.return}while(f!==null)}Dy(n)}catch(E){e=E,nt===n&&n!==null&&(nt=n=n.return);continue}break}while(1)}function Ny(){var t=Ac.current;return Ac.current=Dc,t===null?Dc:t}function Ha(t,e){var n=ce;ce|=16;var r=Ny();Ft===t&&Ct===e||xo(t,e);do try{_2();break}catch(s){Ty(t,s)}while(1);if(ih(),ce=n,Ac.current=r,nt!==null)throw Error(X(261));return Ft=null,Ct=0,xt}function _2(){for(;nt!==null;)Ry(nt)}function P2(){for(;nt!==null&&!g2();)Ry(nt)}function Ry(t){var e=_y(t.alternate,t,ls);t.memoizedProps=t.pendingProps,e===null?Dy(t):nt=e,Fh.current=null}function Dy(t){var e=t;do{var n=e.alternate;if(t=e.return,(e.flags&2048)==0){if(n=S2(n,e,ls),n!==null){nt=n;return}if(n=e,n.tag!==24&&n.tag!==23||n.memoizedState===null||(ls&1073741824)!=0||(n.mode&4)==0){for(var r=0,s=n.child;s!==null;)r|=s.lanes|s.childLanes,s=s.sibling;n.childLanes=r}t!==null&&(t.flags&2048)==0&&(t.firstEffect===null&&(t.firstEffect=e.firstEffect),e.lastEffect!==null&&(t.lastEffect!==null&&(t.lastEffect.nextEffect=e.firstEffect),t.lastEffect=e.lastEffect),1<e.flags&&(t.lastEffect!==null?t.lastEffect.nextEffect=e:t.firstEffect=e,t.lastEffect=e))}else{if(n=I2(e),n!==null){n.flags&=2047,nt=n;return}t!==null&&(t.firstEffect=t.lastEffect=null,t.flags|=2048)}if(e=e.sibling,e!==null){nt=e;return}nt=e=t}while(e!==null);xt===0&&(xt=5)}function cs(t){var e=io();return ss(99,O2.bind(null,t,e)),null}function O2(t,e){do Tr();while(Wa!==null);if((ce&48)!=0)throw Error(X(327));var n=t.finishedWork;if(n===null)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(X(177));t.callbackNode=null;var r=n.lanes|n.childLanes,s=r,o=t.pendingLanes&~s;t.pendingLanes=s,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=s,t.mutableReadLanes&=s,t.entangledLanes&=s,s=t.entanglements;for(var a=t.eventTimes,i=t.expirationTimes;0<o;){var l=31-gr(o),c=1<<l;s[l]=0,a[l]=-1,i[l]=-1,o&=~c}if(Xn!==null&&(r&24)==0&&Xn.has(t)&&Xn.delete(t),t===Ft&&(nt=Ft=null,Ct=0),1<n.flags?n.lastEffect!==null?(n.lastEffect.nextEffect=n,r=n.firstEffect):r=n:r=n.firstEffect,r!==null){if(s=ce,ce|=32,Fh.current=null,Xp=nc,a=n1(),Hp(a)){if("selectionStart"in a)i={start:a.selectionStart,end:a.selectionEnd};else e:if(i=(i=a.ownerDocument)&&i.defaultView||window,(c=i.getSelection&&i.getSelection())&&c.rangeCount!==0){i=c.anchorNode,o=c.anchorOffset,l=c.focusNode,c=c.focusOffset;try{i.nodeType,l.nodeType}catch{i=null;break e}var u=0,d=-1,f=-1,p=0,h=0,g=a,m=null;t:for(;;){for(var x;g!==i||o!==0&&g.nodeType!==3||(d=u+o),g!==l||c!==0&&g.nodeType!==3||(f=u+c),g.nodeType===3&&(u+=g.nodeValue.length),(x=g.firstChild)!==null;)m=g,g=x;for(;;){if(g===a)break t;if(m===i&&++p===o&&(d=u),m===l&&++h===c&&(f=u),(x=g.nextSibling)!==null)break;g=m,m=g.parentNode}g=x}i=d===-1||f===-1?null:{start:d,end:f}}else i=null;i=i||{start:0,end:0}}else i=null;Yp={focusedElem:a,selectionRange:i},nc=!1,Ga=null,Lc=!1,te=r;do try{M2()}catch(E){if(te===null)throw Error(X(330));Nr(te,E),te=te.nextEffect}while(te!==null);Ga=null,te=r;do try{for(a=t;te!==null;){var y=te.flags;if(y&16&&aa(te.stateNode,""),y&128){var w=te.alternate;if(w!==null){var v=w.ref;v!==null&&(typeof v=="function"?v(null):v.current=null)}}switch(y&1038){case 2:by(te),te.flags&=-3;break;case 6:by(te),te.flags&=-3,Dh(te.alternate,te);break;case 1024:te.flags&=-1025;break;case 1028:te.flags&=-1025,Dh(te.alternate,te);break;case 4:Dh(te.alternate,te);break;case 8:i=te,Cy(a,i);var $=i.alternate;wy(i),$!==null&&wy($)}te=te.nextEffect}}catch(E){if(te===null)throw Error(X(330));Nr(te,E),te=te.nextEffect}while(te!==null);if(v=Yp,w=n1(),y=v.focusedElem,a=v.selectionRange,w!==y&&y&&y.ownerDocument&&t1(y.ownerDocument.documentElement,y)){for(a!==null&&Hp(y)&&(w=a.start,v=a.end,v===void 0&&(v=w),"selectionStart"in y?(y.selectionStart=w,y.selectionEnd=Math.min(v,y.value.length)):(v=(w=y.ownerDocument||document)&&w.defaultView||window,v.getSelection&&(v=v.getSelection(),i=y.textContent.length,$=Math.min(a.start,i),a=a.end===void 0?$:Math.min(a.end,i),!v.extend&&$>a&&(i=a,a=$,$=i),i=e1(y,$),o=e1(y,a),i&&o&&(v.rangeCount!==1||v.anchorNode!==i.node||v.anchorOffset!==i.offset||v.focusNode!==o.node||v.focusOffset!==o.offset)&&(w=w.createRange(),w.setStart(i.node,i.offset),v.removeAllRanges(),$>a?(v.addRange(w),v.extend(o.node,o.offset)):(w.setEnd(o.node,o.offset),v.addRange(w)))))),w=[],v=y;v=v.parentNode;)v.nodeType===1&&w.push({element:v,left:v.scrollLeft,top:v.scrollTop});for(typeof y.focus=="function"&&y.focus(),y=0;y<w.length;y++)v=w[y],v.element.scrollLeft=v.left,v.element.scrollTop=v.top}nc=!!Xp,Yp=Xp=null,t.current=n,te=r;do try{for(y=t;te!==null;){var b=te.flags;if(b&36&&R2(y,te.alternate,te),b&128){w=void 0;var C=te.ref;if(C!==null){var I=te.stateNode;switch(te.tag){case 5:w=I;break;default:w=I}typeof C=="function"?C(w):C.current=w}}te=te.nextEffect}}catch(E){if(te===null)throw Error(X(330));Nr(te,E),te=te.nextEffect}while(te!==null);te=null,y2(),ce=s}else t.current=n;if(Sr)Sr=!1,Wa=t,za=e;else for(te=r;te!==null;)e=te.nextEffect,te.nextEffect=null,te.flags&8&&(b=te,b.sibling=null,b.stateNode=null),te=e;if(r=t.pendingLanes,r===0&&(Fn=null),r===1?t===Wh?Ua++:(Ua=0,Wh=t):Ua=0,n=n.stateNode,rs&&typeof rs.onCommitFiberRoot=="function")try{rs.onCommitFiberRoot(th,n,void 0,(n.current.flags&64)==64)}catch{}if(an(t,$t()),Pc)throw Pc=!1,t=Lh,Lh=null,t;return(ce&8)!=0||Tn(),null}function M2(){for(;te!==null;){var t=te.alternate;Lc||Ga===null||((te.flags&8)!=0?b0(te,Ga)&&(Lc=!0):te.tag===13&&D2(t,te)&&b0(te,Ga)&&(Lc=!0));var e=te.flags;(e&256)!=0&&N2(t,te),(e&512)==0||Sr||(Sr=!0,Ea(97,function(){return Tr(),null})),te=te.nextEffect}}function Tr(){if(za!==90){var t=97<za?97:za;return za=90,ss(t,B2)}return!1}function L2(t,e){Bh.push(e,t),Sr||(Sr=!0,Ea(97,function(){return Tr(),null}))}function Fy(t,e){Vh.push(e,t),Sr||(Sr=!0,Ea(97,function(){return Tr(),null}))}function B2(){if(Wa===null)return!1;var t=Wa;if(Wa=null,(ce&48)!=0)throw Error(X(331));var e=ce;ce|=32;var n=Vh;Vh=[];for(var r=0;r<n.length;r+=2){var s=n[r],o=n[r+1],a=s.destroy;if(s.destroy=void 0,typeof a=="function")try{a()}catch(l){if(o===null)throw Error(X(330));Nr(o,l)}}for(n=Bh,Bh=[],r=0;r<n.length;r+=2){s=n[r],o=n[r+1];try{var i=s.create;s.destroy=i()}catch(l){if(o===null)throw Error(X(330));Nr(o,l)}}for(i=t.current.firstEffect;i!==null;)t=i.nextEffect,i.nextEffect=null,i.flags&8&&(i.sibling=null,i.stateNode=null),i=t;return ce=e,Tn(),!0}function Ay(t,e,n){e=Eh(n,e),e=my(t,e,1),Cr(t,e),e=Xt(),t=Bc(t,1),t!==null&&(tc(t,1,e),an(t,e))}function Nr(t,e){if(t.tag===3)Ay(t,t,e);else for(var n=t.return;n!==null;){if(n.tag===3){Ay(n,t,e);break}else if(n.tag===1){var r=n.stateNode;if(typeof n.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(Fn===null||!Fn.has(r))){t=Eh(e,t);var s=gy(n,t,1);if(Cr(n,s),s=Xt(),n=Bc(n,1),n!==null)tc(n,1,s),an(n,s);else if(typeof r.componentDidCatch=="function"&&(Fn===null||!Fn.has(r)))try{r.componentDidCatch(e,t)}catch{}break}}n=n.return}}function V2(t,e,n){var r=t.pingCache;r!==null&&r.delete(e),e=Xt(),t.pingedLanes|=t.suspendedLanes&n,Ft===t&&(Ct&n)===n&&(xt===4||xt===3&&(Ct&62914560)===Ct&&500>$t()-Oh?xo(t,0):_h|=n),an(t,e)}function W2(t,e){var n=t.stateNode;n!==null&&n.delete(e),e=0,e===0&&(e=t.mode,(e&2)==0?e=1:(e&4)==0?e=io()===99?1:2:(Yn===0&&(Yn=po),e=Qs(62914560&~Yn),e===0&&(e=4194304))),n=Xt(),t=Bc(t,e),t!==null&&(tc(t,e,n),an(t,n))}var _y;_y=function(t,e,n){var r=e.lanes;if(t!==null)if(t.memoizedProps!==e.pendingProps||Pt.current)vn=!0;else if((n&r)!=0)vn=(t.flags&16384)!=0;else{switch(vn=!1,e.tag){case 3:oy(e),hh();break;case 5:V1(e);break;case 1:Ot(e.type)&&hc(e);break;case 4:dh(e,e.stateNode.containerInfo);break;case 10:r=e.memoizedProps.value;var s=e.type._context;He(xc,s._currentValue),s._currentValue=r;break;case 13:if(e.memoizedState!==null)return(n&e.child.childLanes)!=0?ay(t,e,n):(He(je,je.current&1),e=qn(t,e,n),e!==null?e.sibling:null);He(je,je.current&1);break;case 19:if(r=(n&e.childLanes)!=0,(t.flags&64)!=0){if(r)return dy(t,e,n);e.flags|=64}if(s=e.memoizedState,s!==null&&(s.rendering=null,s.tail=null,s.lastEffect=null),He(je,je.current),r)break;return null;case 23:case 24:return e.lanes=0,bh(t,e,n)}return qn(t,e,n)}else vn=!1;switch(e.lanes=0,e.tag){case 2:if(r=e.type,t!==null&&(t.alternate=null,e.alternate=null,e.flags|=2),t=e.pendingProps,s=ao(e,wt.current),co(e,n),s=xh(null,e,r,t,s,n),e.flags|=1,typeof s=="object"&&s!==null&&typeof s.render=="function"&&s.$$typeof===void 0){if(e.tag=1,e.memoizedState=null,e.updateQueue=null,Ot(r)){var o=!0;hc(e)}else o=!1;e.memoizedState=s.state!==null&&s.state!==void 0?s.state:null,ch(e);var a=r.getDerivedStateFromProps;typeof a=="function"&&wc(e,r,a,t),s.updater=$c,e.stateNode=s,s._reactInternals=e,uh(e,r,t,n),e=kh(null,e,r,!0,o,n)}else e.tag=0,Lt(null,e,s,n),e=e.child;return e;case 16:s=e.elementType;e:{switch(t!==null&&(t.alternate=null,e.alternate=null,e.flags|=2),t=e.pendingProps,o=s._init,s=o(s._payload),e.type=s,o=e.tag=U2(s),t=yn(s,t),o){case 0:e=Ch(null,e,s,t,n);break e;case 1:e=sy(null,e,s,t,n);break e;case 11:e=ey(null,e,s,t,n);break e;case 14:e=ty(null,e,s,yn(s.type,t),r,n);break e}throw Error(X(306,s,""))}return e;case 0:return r=e.type,s=e.pendingProps,s=e.elementType===r?s:yn(r,s),Ch(t,e,r,s,n);case 1:return r=e.type,s=e.pendingProps,s=e.elementType===r?s:yn(r,s),sy(t,e,r,s,n);case 3:if(oy(e),r=e.updateQueue,t===null||r===null)throw Error(X(282));if(r=e.pendingProps,s=e.memoizedState,s=s!==null?s.element:null,D1(t,e),Ta(e,r,null,n),r=e.memoizedState.element,r===s)hh(),e=qn(t,e,n);else{if(s=e.stateNode,(o=s.hydrate)&&(kr=no(e.stateNode.containerInfo.firstChild),Kn=e,o=Rn=!0),o){if(t=s.mutableSourceEagerHydrationData,t!=null)for(s=0;s<t.length;s+=2)o=t[s],o._workInProgressVersionPrimary=t[s+1],fo.push(o);for(n=B1(e,null,r,n),e.child=n;n;)n.flags=n.flags&-3|1024,n=n.sibling}else Lt(t,e,r,n),hh();e=e.child}return e;case 5:return V1(e),t===null&&ph(e),r=e.type,s=e.pendingProps,o=t!==null?t.memoizedProps:null,a=s.children,Qp(r,s)?a=null:o!==null&&Qp(r,o)&&(e.flags|=16),ry(t,e),Lt(t,e,a,n),e.child;case 6:return t===null&&ph(e),null;case 13:return ay(t,e,n);case 4:return dh(e,e.stateNode.containerInfo),r=e.pendingProps,t===null?e.child=kc(e,null,r,n):Lt(t,e,r,n),e.child;case 11:return r=e.type,s=e.pendingProps,s=e.elementType===r?s:yn(r,s),ey(t,e,r,s,n);case 7:return Lt(t,e,e.pendingProps,n),e.child;case 8:return Lt(t,e,e.pendingProps.children,n),e.child;case 12:return Lt(t,e,e.pendingProps.children,n),e.child;case 10:e:{r=e.type._context,s=e.pendingProps,a=e.memoizedProps,o=s.value;var i=e.type._context;if(He(xc,i._currentValue),i._currentValue=o,a!==null)if(i=a.value,o=rn(i,o)?0:(typeof r._calculateChangedBits=="function"?r._calculateChangedBits(i,o):1073741823)|0,o===0){if(a.children===s.children&&!Pt.current){e=qn(t,e,n);break e}}else for(i=e.child,i!==null&&(i.return=e);i!==null;){var l=i.dependencies;if(l!==null){a=i.child;for(var c=l.firstContext;c!==null;){if(c.context===r&&(c.observedBits&o)!=0){i.tag===1&&(c=br(-1,n&-n),c.tag=2,Cr(i,c)),i.lanes|=n,c=i.alternate,c!==null&&(c.lanes|=n),R1(i.return,n),l.lanes|=n;break}c=c.next}}else a=i.tag===10&&i.type===e.type?null:i.child;if(a!==null)a.return=i;else for(a=i;a!==null;){if(a===e){a=null;break}if(i=a.sibling,i!==null){i.return=a.return,a=i;break}a=a.return}i=a}Lt(t,e,s.children,n),e=e.child}return e;case 9:return s=e.type,o=e.pendingProps,r=o.children,co(e,n),s=sn(s,o.unstable_observedBits),r=r(s),e.flags|=1,Lt(t,e,r,n),e.child;case 14:return s=e.type,o=yn(s,e.pendingProps),o=yn(s.type,o),ty(t,e,s,o,r,n);case 15:return ny(t,e,e.type,e.pendingProps,r,n);case 17:return r=e.type,s=e.pendingProps,s=e.elementType===r?s:yn(r,s),t!==null&&(t.alternate=null,e.alternate=null,e.flags|=2),e.tag=1,Ot(r)?(t=!0,hc(e)):t=!1,co(e,n),O1(e,r,s),uh(e,r,s,n),kh(null,e,r,!0,t,n);case 19:return dy(t,e,n);case 23:return bh(t,e,n);case 24:return bh(t,e,n)}throw Error(X(156,e.tag))};function z2(t,e,n,r){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function ln(t,e,n,r){return new z2(t,e,n,r)}function Gh(t){return t=t.prototype,!(!t||!t.isReactComponent)}function U2(t){if(typeof t=="function")return Gh(t)?1:0;if(t!=null){if(t=t.$$typeof,t===zl)return 11;if(t===Gl)return 14}return 2}function Rr(t,e){var n=t.alternate;return n===null?(n=ln(t.tag,e,t.key,t.mode),n.elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.nextEffect=null,n.firstEffect=null,n.lastEffect=null),n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function Wc(t,e,n,r,s,o){var a=2;if(r=t,typeof t=="function")Gh(t)&&(a=1);else if(typeof t=="string")a=5;else e:switch(t){case dr:return yo(n.children,s,o,e);case e0:a=8,s|=16;break;case ep:a=8,s|=1;break;case na:return t=ln(12,n,e,s|8),t.elementType=na,t.type=na,t.lanes=o,t;case ra:return t=ln(13,n,e,s),t.type=ra,t.elementType=ra,t.lanes=o,t;case Ul:return t=ln(19,n,e,s),t.elementType=Ul,t.lanes=o,t;case ap:return Hh(n,s,o,e);case ip:return t=ln(24,n,e,s),t.elementType=ip,t.lanes=o,t;default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case tp:a=10;break e;case np:a=9;break e;case zl:a=11;break e;case Gl:a=14;break e;case rp:a=16,r=null;break e;case sp:a=22;break e}throw Error(X(130,t==null?t:typeof t,""))}return e=ln(a,n,e,s),e.elementType=t,e.type=r,e.lanes=o,e}function yo(t,e,n,r){return t=ln(7,t,r,e),t.lanes=n,t}function Hh(t,e,n,r){return t=ln(23,t,r,e),t.elementType=ap,t.lanes=n,t}function jh(t,e,n){return t=ln(6,t,null,e),t.lanes=n,t}function Kh(t,e,n){return e=ln(4,t.children!==null?t.children:[],t.key,e),e.lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function G2(t,e,n){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=n,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=Ap(0),this.expirationTimes=Ap(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ap(0),this.mutableSourceEagerHydrationData=null}function H2(t,e,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Zr,key:r==null?null:""+r,children:t,containerInfo:e,implementation:n}}function zc(t,e,n,r){var s=e.current,o=Xt(),a=Ir(s);e:if(n){n=n._reactInternals;t:{if(es(n)!==n||n.tag!==1)throw Error(X(170));var i=n;do{switch(i.tag){case 3:i=i.stateNode.context;break t;case 1:if(Ot(i.type)){i=i.stateNode.__reactInternalMemoizedMergedChildContext;break t}}i=i.return}while(i!==null);throw Error(X(171))}if(n.tag===1){var l=n.type;if(Ot(l)){n=w1(n,l,i);break e}}n=i}else n=wr;return e.context===null?e.context=n:e.pendingContext=n,e=br(o,a),e.payload={element:t},r=r===void 0?null:r,r!==null&&(e.callback=r),Cr(s,e),Er(s,a,o),a}function qh(t){if(t=t.current,!t.child)return null;switch(t.child.tag){case 5:return t.child.stateNode;default:return t.child.stateNode}}function Py(t,e){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var n=t.retryLane;t.retryLane=n!==0&&n<e?n:e}}function Xh(t,e){Py(t,e),(t=t.alternate)&&Py(t,e)}function j2(){return null}function Yh(t,e,n){var r=n!=null&&n.hydrationOptions!=null&&n.hydrationOptions.mutableSources||null;if(n=new G2(t,e,n!=null&&n.hydrate===!0),e=ln(3,null,null,e===2?7:e===1?3:0),n.current=e,e.stateNode=n,ch(e),t[ro]=n.current,c1(t.nodeType===8?t.parentNode:t),r)for(t=0;t<r.length;t++){e=r[t];var s=e._getVersion;s=s(e._source),n.mutableSourceEagerHydrationData==null?n.mutableSourceEagerHydrationData=[e,s]:n.mutableSourceEagerHydrationData.push(e,s)}this._internalRoot=n}Yh.prototype.render=function(t){zc(t,this._internalRoot,null,null)};Yh.prototype.unmount=function(){var t=this._internalRoot,e=t.containerInfo;zc(null,t,null,function(){e[ro]=null})};function ja(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11&&(t.nodeType!==8||t.nodeValue!==" react-mount-point-unstable "))}function K2(t,e){if(e||(e=t?t.nodeType===9?t.documentElement:t.firstChild:null,e=!(!e||e.nodeType!==1||!e.hasAttribute("data-reactroot"))),!e)for(var n;n=t.lastChild;)t.removeChild(n);return new Yh(t,0,e?{hydrate:!0}:void 0)}function Uc(t,e,n,r,s){var o=n._reactRootContainer;if(o){var a=o._internalRoot;if(typeof s=="function"){var i=s;s=function(){var c=qh(a);i.call(c)}}zc(e,a,t,s)}else{if(o=n._reactRootContainer=K2(n,r),a=o._internalRoot,typeof s=="function"){var l=s;s=function(){var c=qh(a);l.call(c)}}Ey(function(){zc(e,a,t,s)})}return qh(a)}C0=function(t){if(t.tag===13){var e=Xt();Er(t,4,e),Xh(t,4)}};Ep=function(t){if(t.tag===13){var e=Xt();Er(t,67108864,e),Xh(t,67108864)}};k0=function(t){if(t.tag===13){var e=Xt(),n=Ir(t);Er(t,n,e),Xh(t,n)}};S0=function(t,e){return e()};wp=function(t,e,n){switch(e){case"input":if(dp(t,n),e=n.name,n.type==="radio"&&e!=null){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var r=n[e];if(r!==t&&r.form===t.form){var s=fc(r);if(!s)throw Error(X(90));r0(r),dp(r,s)}}}break;case"textarea":l0(t,n);break;case"select":e=n.value,e!=null&&js(t,!!n.multiple,e,!1)}};$p=Iy;x0=function(t,e,n,r,s){var o=ce;ce|=4;try{return ss(98,t.bind(null,e,n,r,s))}finally{ce=o,ce===0&&(mo(),Tn())}};bp=function(){(ce&49)==0&&(A2(),Tr())};y0=function(t,e){var n=ce;ce|=2;try{return t(e)}finally{ce=n,ce===0&&(mo(),Tn())}};function Oy(t,e){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!ja(e))throw Error(X(200));return H2(t,e,null,n)}var q2={Events:[Ia,so,fc,m0,g0,Tr,{current:!1}]},Ka={findFiberByHostInstance:ts,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"},X2={bundleType:Ka.bundleType,version:Ka.version,rendererPackageName:Ka.rendererPackageName,rendererConfig:Ka.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Qr.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return t=$0(t),t===null?null:t.stateNode},findFiberByHostInstance:Ka.findFiberByHostInstance||j2,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!="undefined"){var Gc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Gc.isDisabled&&Gc.supportsFiber)try{th=Gc.inject(X2),rs=Gc}catch{}}nn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=q2;nn.createPortal=Oy;nn.findDOMNode=function(t){if(t==null)return null;if(t.nodeType===1)return t;var e=t._reactInternals;if(e===void 0)throw typeof t.render=="function"?Error(X(188)):Error(X(268,Object.keys(t)));return t=$0(e),t=t===null?null:t.stateNode,t};nn.flushSync=function(t,e){var n=ce;if((n&48)!=0)return t(e);ce|=1;try{if(t)return ss(99,t.bind(null,e))}finally{ce=n,Tn()}};nn.hydrate=function(t,e,n){if(!ja(e))throw Error(X(200));return Uc(null,t,e,!0,n)};nn.render=function(t,e,n){if(!ja(e))throw Error(X(200));return Uc(null,t,e,!1,n)};nn.unmountComponentAtNode=function(t){if(!ja(t))throw Error(X(40));return t._reactRootContainer?(Ey(function(){Uc(null,null,t,!1,function(){t._reactRootContainer=null,t[ro]=null})}),!0):!1};nn.unstable_batchedUpdates=Iy;nn.unstable_createPortal=function(t,e){return Oy(t,e,2<arguments.length&&arguments[2]!==void 0?arguments[2]:null)};nn.unstable_renderSubtreeIntoContainer=function(t,e,n,r){if(!ja(n))throw Error(X(200));if(t==null||t._reactInternals===void 0)throw Error(X(38));return Uc(t,e,n,!1,r)};nn.version="17.0.2";function My(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__=="undefined"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(My)}catch(t){console.error(t)}}My(),Kx.exports=nn;var gX=Kx.exports;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y2=1e-7,Q2=1e-4;class Qh{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Hc{refCount(e){return cn("refCount")}incRef(e){return cn("incRef")}timerAvailable(){return!0}time(e){return cn("time")}read(e){return cn("read")}readSync(e){return cn("readSync")}numDataIds(){return cn("numDataIds")}disposeData(e,n){return cn("disposeData")}write(e,n,r){return cn("write")}move(e,n,r,s,o){return cn("move")}memory(){return cn("memory")}floatPrecision(){return cn("floatPrecision")}epsilon(){return this.floatPrecision()===32?Y2:Q2}dispose(){return cn("dispose")}}function cn(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ly(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Qn(t,e,n)}function Z2(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Qn(t,n,r),Qn(e,n,r)}function Dr(t,e,n){return Math.max(t,Math.min(e,n))}function Zh(t){return t%2==0?t:t+1}function Qn(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function By(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function J2(t,e){const n=Math.random();return e*n+(1-n)*t}function eS(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function S(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function ct(t,e,n=""){S(Ie(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function us(t){S(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Zn(t,e=[],n=!1){if(e==null&&(e=[]),Array.isArray(t)||yt(t)&&!n)for(let r=0;r<t.length;++r)Zn(t[r],e,n);else e.push(t);return e}function L(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function tS(t){return t.length===0}function Ie(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function kt(t){return t%1==0}function nS(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function jc(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function rS(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Ly(e),e}function ds(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function Jh(t,e=r=>0,n){return new Promise((r,s)=>{let o=0;const a=()=>{if(t()){r();return}o++;const i=e(o);if(n!=null&&o>=n){s();return}setTimeout(a,i)};a()})}function em(t,e){let n=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(t[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function ge(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),S(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),S(t.every(r=>kt(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function Jn(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:ge(e,t).sort();let a=0;for(let i=0;i<t.length;++i){if(o!=null){if(o[a]===i&&t[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`);(o[a]==null||o[a]>i)&&t[i]===1&&(n.push(t[i]),r.push(i)),o[a]<=i&&a++}t[i]!==1&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function Je(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else throw new Error(`Unknown data type ${t}`);return n}function St(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function Vy(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Wy(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function tm(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function yt(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function Kc(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function zy(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function An(t){return typeof t=="string"||t instanceof String}function Uy(t){return typeof t=="boolean"}function Gy(t){return typeof t=="number"}function vo(t){return Array.isArray(t)?vo(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":Gy(t)?"float32":An(t)?"string":Uy(t)?"bool":"float32"}function Fr(t){return!!(t&&t.constructor&&t.call&&t.apply)}function qc(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function ae(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Hy(t,e,n,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let a=0;a<o;a++)s[a]=n[t+a]}else{const o=e[0],a=e.slice(1),i=a.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<o;l++)s[l]=Hy(t+l*i,a,n,r)}return s}function un(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,o)=>s*o)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Hy(0,t,e,n)}function nm(t,e){const n=ut(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function ut(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function rm(t,e){const n=t.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return un(t,new Float32Array(n));if(e==="int32")return un(t,new Int32Array(n));if(e==="bool")return un(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function sm(t){t.forEach(e=>{S(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function wn(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function wo(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function om(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function At(...t){z().getBool("IS_TEST")||z().getBool("PROD")||console.warn(...t)}function sS(...t){z().getBool("IS_TEST")||z().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jy="tfjsflags";class Ky{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=oS,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&At(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];At(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(om(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);jy in e&&e[jy].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=iS(s,o)})}}function oS(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(aS(e,r[0],r[1]),r.join("="))),e}function aS(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function iS(t,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}function z(){return am}let am=null;function lS(t){am=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let im;function qy(){if(im==null){let t;if(typeof window!="undefined")t=window;else if(typeof global!="undefined")t=global;else if(typeof process!="undefined")t=process;else if(typeof self!="undefined")t=self;else throw new Error("Could not find a global object");im=t}return im}function cS(){const t=qy();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function lm(t,e){const n=cS();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Xc="Abs",qa="Acos",Xa="Acosh",$o="Add",Yc="AddN",Qc="All",Zc="Any",Jc="ArgMax",eu="ArgMin",Ya="Asin",Qa="Asinh",Za="Atan",Ja="Atanh",ei="Atan2",tu="AvgPool",cm="AvgPoolGrad",nu="AvgPool3D",um="AvgPool3DGrad",ru="BatchMatMul",su="BatchToSpaceND",ou="Bincount",uS="BroadcastTo",au="BroadcastArgs",ti="Cast",ni="Ceil",ri="ClipByValue",iu="Complex",lu="ComplexAbs",cu="Concat",uu="Conv2D",du="Conv2DBackpropFilter",fu="Conv2DBackpropInput",pu="Conv3D",dm="Conv3DBackpropFilterV2",hu="Conv3DBackpropInputV2",si="Cos",oi="Cosh",mu="Cumsum",gu="CropAndResize",xu="DenseBincount",yu="DepthToSpace",vu="DepthwiseConv2dNative",wu="DepthwiseConv2dNativeBackpropFilter",$u="DepthwiseConv2dNativeBackpropInput",bu="Diag",Cu="Dilation2D",fm="Dilation2DBackpropInput",pm="Dilation2DBackpropFilter",ai="RealDiv",ku="Einsum",ii="Elu",hm="EluGrad",li="Erf",ci="Equal",ui="Exp",Su="ExpandDims",di="Expm1",Iu="FFT",Eu="Fill",Tu="FlipLeftRight",fi="Floor",pi="FloorDiv",Nu="FusedBatchNorm",Ru="GatherV2",Du="GatherNd",hi="Greater",mi="GreaterEqual",gi="Identity",Fu="IFFT",Au="Imag",xi="IsFinite",yi="IsInf",vi="IsNan",_u="LeakyRelu",wi="Less",$i="LessEqual",Pu="LinSpace",bi="Log",Ci="Log1p",ki="LogicalAnd",Si="LogicalNot",Ii="LogicalOr",dS="LogSoftmax",Ou="LRN",mm="LRNGrad",Mu="Max",Ei="Maximum",Lu="MaxPool",gm="MaxPoolGrad",Bu="MaxPool3D",xm="MaxPool3DGrad",Vu="MaxPoolWithArgmax",Wu="Mean",zu="Min",Ti="Minimum",Uu="MirrorPad",Ni="Mod",Gu="Multinomial",Ri="Multiply",Hu="Neg",Di="NotEqual",ju="NonMaxSuppressionV3",Ku="NonMaxSuppressionV4",qu="NonMaxSuppressionV5",Xu="OnesLike",Yu="OneHot",Qu="Pack",Zu="PadV2",fS="Pool",Fi="Pow",Ju="Prelu",ed="Prod",td="Range",nd="Real",Ai="Reciprocal",_i="Relu",rd="Reshape",sd="ResizeNearestNeighbor",ym="ResizeNearestNeighborGrad",od="ResizeBilinear",vm="ResizeBilinearGrad",Pi="Relu6",ad="Reverse",Oi="Round",Mi="Rsqrt",id="ScatterNd",ld="Select",Li="Selu",cd="Slice",Bi="Sin",Vi="Sinh",Wi="Sign",zi="Sigmoid",Ui="Softplus",Gi="Sqrt",ud="Sum",dd="SpaceToBatchND",fd="SplitV",pd="Softmax",hd="SparseFillEmptyRows",md="SparseReshape",gd="SparseSegmentMean",xd="SparseSegmentSum",yd="SparseToDense",Hi="SquaredDifference",wm="Square",vd="StridedSlice",wd="StringNGrams",$d="StringSplit",bd="StringToHashBucketFast",ji="Sub",Ki="Tan",qi="Tanh",Xi="Tile",Cd="TopK",kd="Transform",Sd="Transpose",Id="Unique",Ed="Unpack",Td="UnsortedSegmentSum",Nd="ZerosLike",Yi="Step",Rd="FromPixels",Dd="RotateWithOffset",Qi="_FusedMatMul",Zi="FusedConv2D",Ji="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bo=lm("kernelRegistry",()=>new Map),el=lm("gradRegistry",()=>new Map);function Fd(t,e){const n=bm(t,e);return bo.get(n)}function $m(t){return el.get(t)}function Ad(t){const e=bo.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,a]=s,[i]=o.split("_");i===t&&n.push(a)}return n}function _d(t){const{kernelName:e,backendName:n}=t,r=bm(e,n);bo.has(r)&&At(`The kernel '${e}' for backend '${n}' is already registered`),bo.set(r,t)}function pS(t){const{kernelName:e}=t;el.has(e)&&z().getBool("DEBUG")&&At(`Overriding the gradient for '${e}'`),el.set(e,t)}function hS(t,e){const n=bm(t,e);if(!bo.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);bo.delete(n)}function mS(t){if(!el.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);el.delete(t)}function gS(t,e){Ad(t).forEach(r=>{const s=Object.assign({},r,{backendName:e});_d(s)})}function bm(t,e){return`${e}_${t}`}var Cm=De,dn=null;try{dn=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function De(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}De.prototype.__isLong__;Object.defineProperty(De.prototype,"__isLong__",{value:!0});function Bt(t){return(t&&t.__isLong__)===!0}De.isLong=Bt;var Xy={},Yy={};function fs(t,e){var n,r,s;return e?(t>>>=0,(s=0<=t&&t<256)&&(r=Yy[t],r)?r:(n=Fe(t,(t|0)<0?-1:0,!0),s&&(Yy[t]=n),n)):(t|=0,(s=-128<=t&&t<128)&&(r=Xy[t],r)?r:(n=Fe(t,t<0?-1:0,!1),s&&(Xy[t]=n),n))}De.fromInt=fs;function fn(t,e){if(isNaN(t))return e?ps:pn;if(e){if(t<0)return ps;if(t>=Zy)return rv}else{if(t<=-Jy)return Vt;if(t+1>=Jy)return nv}return t<0?fn(-t,e).neg():Fe(t%Co|0,t/Co|0,e)}De.fromNumber=fn;function Fe(t,e,n){return new De(t,e,n)}De.fromBits=Fe;var Pd=Math.pow;function km(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return pn;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return km(t.substring(1),e,n).neg();for(var s=fn(Pd(n,8)),o=pn,a=0;a<t.length;a+=8){var i=Math.min(8,t.length-a),l=parseInt(t.substring(a,a+i),n);if(i<8){var c=fn(Pd(n,i));o=o.mul(c).add(fn(l))}else o=o.mul(s),o=o.add(fn(l))}return o.unsigned=e,o}De.fromString=km;function $n(t,e){return typeof t=="number"?fn(t,e):typeof t=="string"?km(t,e):Fe(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}De.fromValue=$n;var Qy=1<<16,xS=1<<24,Co=Qy*Qy,Zy=Co*Co,Jy=Zy/2,ev=fs(xS),pn=fs(0);De.ZERO=pn;var ps=fs(0,!0);De.UZERO=ps;var ko=fs(1);De.ONE=ko;var tv=fs(1,!0);De.UONE=tv;var Sm=fs(-1);De.NEG_ONE=Sm;var nv=Fe(4294967295|0,2147483647|0,!1);De.MAX_VALUE=nv;var rv=Fe(4294967295|0,4294967295|0,!0);De.MAX_UNSIGNED_VALUE=rv;var Vt=Fe(0,2147483648|0,!1);De.MIN_VALUE=Vt;var Q=De.prototype;Q.toInt=function(){return this.unsigned?this.low>>>0:this.low};Q.toNumber=function(){return this.unsigned?(this.high>>>0)*Co+(this.low>>>0):this.high*Co+(this.low>>>0)};Q.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Vt)){var n=fn(e),r=this.div(n),s=r.mul(n).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=fn(Pd(e,6),this.unsigned),a=this,i="";;){var l=a.div(o),c=a.sub(l.mul(o)).toInt()>>>0,u=c.toString(e);if(a=l,a.isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}};Q.getHighBits=function(){return this.high};Q.getHighBitsUnsigned=function(){return this.high>>>0};Q.getLowBits=function(){return this.low};Q.getLowBitsUnsigned=function(){return this.low>>>0};Q.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Vt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&(e&1<<n)==0;n--);return this.high!=0?n+33:n+1};Q.isZero=function(){return this.high===0&&this.low===0};Q.eqz=Q.isZero;Q.isNegative=function(){return!this.unsigned&&this.high<0};Q.isPositive=function(){return this.unsigned||this.high>=0};Q.isOdd=function(){return(this.low&1)==1};Q.isEven=function(){return(this.low&1)==0};Q.equals=function(e){return Bt(e)||(e=$n(e)),this.unsigned!==e.unsigned&&this.high>>>31==1&&e.high>>>31==1?!1:this.high===e.high&&this.low===e.low};Q.eq=Q.equals;Q.notEquals=function(e){return!this.eq(e)};Q.neq=Q.notEquals;Q.ne=Q.notEquals;Q.lessThan=function(e){return this.comp(e)<0};Q.lt=Q.lessThan;Q.lessThanOrEqual=function(e){return this.comp(e)<=0};Q.lte=Q.lessThanOrEqual;Q.le=Q.lessThanOrEqual;Q.greaterThan=function(e){return this.comp(e)>0};Q.gt=Q.greaterThan;Q.greaterThanOrEqual=function(e){return this.comp(e)>=0};Q.gte=Q.greaterThanOrEqual;Q.ge=Q.greaterThanOrEqual;Q.compare=function(e){if(Bt(e)||(e=$n(e)),this.eq(e))return 0;var n=this.isNegative(),r=e.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Q.comp=Q.compare;Q.negate=function(){return!this.unsigned&&this.eq(Vt)?Vt:this.not().add(ko)};Q.neg=Q.negate;Q.add=function(e){Bt(e)||(e=$n(e));var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,o=this.low&65535,a=e.high>>>16,i=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,d=0,f=0,p=0;return p+=o+c,f+=p>>>16,p&=65535,f+=s+l,d+=f>>>16,f&=65535,d+=r+i,u+=d>>>16,d&=65535,u+=n+a,u&=65535,Fe(f<<16|p,u<<16|d,this.unsigned)};Q.subtract=function(e){return Bt(e)||(e=$n(e)),this.add(e.neg())};Q.sub=Q.subtract;Q.multiply=function(e){if(this.isZero())return pn;if(Bt(e)||(e=$n(e)),dn){var n=dn.mul(this.low,this.high,e.low,e.high);return Fe(n,dn.get_high(),this.unsigned)}if(e.isZero())return pn;if(this.eq(Vt))return e.isOdd()?Vt:pn;if(e.eq(Vt))return this.isOdd()?Vt:pn;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(ev)&&e.lt(ev))return fn(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,o=this.low>>>16,a=this.low&65535,i=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,d=0,f=0,p=0,h=0;return h+=a*u,p+=h>>>16,h&=65535,p+=o*u,f+=p>>>16,p&=65535,p+=a*c,f+=p>>>16,p&=65535,f+=s*u,d+=f>>>16,f&=65535,f+=o*c,d+=f>>>16,f&=65535,f+=a*l,d+=f>>>16,f&=65535,d+=r*u+s*c+o*l+a*i,d&=65535,Fe(p<<16|h,d<<16|f,this.unsigned)};Q.mul=Q.multiply;Q.divide=function(e){if(Bt(e)||(e=$n(e)),e.isZero())throw Error("division by zero");if(dn){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?dn.div_u:dn.div_s)(this.low,this.high,e.low,e.high);return Fe(n,dn.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ps:pn;var r,s,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return ps;if(e.gt(this.shru(1)))return tv;o=ps}else{if(this.eq(Vt)){if(e.eq(ko)||e.eq(Sm))return Vt;if(e.eq(Vt))return ko;var a=this.shr(1);return r=a.div(e).shl(1),r.eq(pn)?e.isNegative()?ko:Sm:(s=this.sub(e.mul(r)),o=r.add(s.div(e)),o)}else if(e.eq(Vt))return this.unsigned?ps:pn;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=pn}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(r)/Math.LN2),l=i<=48?1:Pd(2,i-48),c=fn(r),u=c.mul(e);u.isNegative()||u.gt(s);)r-=l,c=fn(r,this.unsigned),u=c.mul(e);c.isZero()&&(c=ko),o=o.add(c),s=s.sub(u)}return o};Q.div=Q.divide;Q.modulo=function(e){if(Bt(e)||(e=$n(e)),dn){var n=(this.unsigned?dn.rem_u:dn.rem_s)(this.low,this.high,e.low,e.high);return Fe(n,dn.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Q.mod=Q.modulo;Q.rem=Q.modulo;Q.not=function(){return Fe(~this.low,~this.high,this.unsigned)};Q.and=function(e){return Bt(e)||(e=$n(e)),Fe(this.low&e.low,this.high&e.high,this.unsigned)};Q.or=function(e){return Bt(e)||(e=$n(e)),Fe(this.low|e.low,this.high|e.high,this.unsigned)};Q.xor=function(e){return Bt(e)||(e=$n(e)),Fe(this.low^e.low,this.high^e.high,this.unsigned)};Q.shiftLeft=function(e){return Bt(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?Fe(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Fe(0,this.low<<e-32,this.unsigned)};Q.shl=Q.shiftLeft;Q.shiftRight=function(e){return Bt(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?Fe(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Fe(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Q.shr=Q.shiftRight;Q.shiftRightUnsigned=function(e){if(Bt(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var r=this.low;return Fe(r>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?Fe(n,0,this.unsigned):Fe(n>>>e-32,0,this.unsigned)};Q.shru=Q.shiftRightUnsigned;Q.shr_u=Q.shiftRightUnsigned;Q.toSigned=function(){return this.unsigned?Fe(this.low,this.high,!1):this};Q.toUnsigned=function(){return this.unsigned?this:Fe(this.low,this.high,!0)};Q.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Q.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Q.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};De.fromBytes=function(e,n,r){return r?De.fromBytesLE(e,n):De.fromBytesBE(e,n)};De.fromBytesLE=function(e,n){return new De(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};De.fromBytesBE=function(e,n){return new De(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};var yS=Object.freeze(jC({__proto__:null,[Symbol.toStringTag]:"Module",default:Cm},[Cm]));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hs=Cm||yS;function tl(t){return hs.fromString(t,!0,16)}const sv=tl("c3a5c85c97cb3127"),ms=tl("b492b66fbe98f273"),It=tl("9ae16a3b2f90404f");function Im(t){return t.xor(t.shru(47))}function ov(t,e,n){const r=t.slice(e,e+n);return hs.fromBytes(Array.from(r),!0,!0)}function Ee(t,e){return ov(t,e,8)}function av(t,e){return ov(t,e,4)}function rt(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function Ar(t,e,n=tl("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function vS(t,e,n,r,s,o){s=s.add(t),o=rt(o.add(s).add(r),21);const a=s;return s=s.add(e),s=s.add(n),o=o.add(rt(s,44)),[s.add(r),o.add(a)]}function Od(t,e,n,r){return vS(Ee(t,e),Ee(t,e+8),Ee(t,e+16),Ee(t,e+24),n,r)}function wS(t,e=t.length){if(e>=8){const n=It.add(e*2),r=Ee(t,0).add(It),s=Ee(t,e-8),o=rt(s,37).mul(n).add(r),a=rt(r,25).add(s).mul(n);return Ar(o,a,n)}if(e>=4){const n=It.add(e*2),r=av(t,0);return Ar(r.shl(3).add(e),av(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],o=n+(r<<8),a=e+(s<<2);return Im(It.mul(o).xor(sv.mul(a))).mul(It)}return It}function $S(t,e=t.length){const n=It.add(e*2),r=Ee(t,0).mul(ms),s=Ee(t,8),o=Ee(t,e-8).mul(n),a=Ee(t,e-16).mul(It);return Ar(rt(r.add(s),43).add(rt(o,30)).add(a),r.add(rt(s.add(It),18)).add(o),n)}function bS(t,e=t.length){const n=It.add(e*2),r=Ee(t,0).mul(It),s=Ee(t,8),o=Ee(t,e-8).mul(n),a=Ee(t,e-16).mul(It),i=rt(r.add(s),43).add(rt(o,30)).add(a),l=Ar(i,r.add(rt(s.add(It),18)).add(o),n),c=Ee(t,16).mul(n),u=Ee(t,24),d=i.add(Ee(t,e-32)).mul(n),f=l.add(Ee(t,e-24)).mul(n);return Ar(rt(c.add(u),43).add(rt(d,30)).add(f),c.add(rt(u.add(r),18)).add(d),n)}function iv(t,e=t.length){const n=hs.fromNumber(81,!0);if(e<=32)return e<=16?wS(t,e):$S(t,e);if(e<=64)return bS(t,e);let r=n,s=n.mul(ms).add(113),o=Im(s.mul(It).add(113)).mul(It),a=[hs.UZERO,hs.UZERO],i=[hs.UZERO,hs.UZERO];r=r.mul(It).add(Ee(t,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do r=rt(r.add(s).add(a[0]).add(Ee(t,l+8)),37).mul(ms),s=rt(s.add(a[1]).add(Ee(t,l+48)),42).mul(ms),r=r.xor(i[1]),s=s.add(a[0]).add(Ee(t,l+40)),o=rt(o.add(i[0]),33).mul(ms),a=Od(t,l,a[1].mul(ms),r.add(i[0])),i=Od(t,l+32,o.add(i[1]),s.add(Ee(t,l+16))),[o,r]=[r,o],l+=64;while(l!==c);const d=ms.add(o.and(255).shl(1));return l=u,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),r=rt(r.add(s).add(a[0]).add(Ee(t,l+8)),37).mul(d),s=rt(s.add(a[1]).add(Ee(t,l+48)),42).mul(d),r=r.xor(i[1].mul(9)),s=s.add(a[0].mul(9).add(Ee(t,l+40))),o=rt(o.add(i[0]),33).mul(d),a=Od(t,l,a[1].mul(d),r.add(i[0])),i=Od(t,l+32,o.add(i[1]),s.add(Ee(t,l+16))),[o,r]=[r,o],Ar(Ar(a[0],i[0],d).add(Im(s).mul(sv)).add(o),Ar(a[1],i[1],d).add(r),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function er(t,e){return e==="string"?_n(t):_r([t],e)}function CS(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function _r(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Zn(t)),z().getBool("DEBUG")&&Vy(t,e),CS(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Wt(){return z().platform.now()}function kS(t,e){return z().platform.fetch(t,e)}function _n(t,e="utf-8"){return e=e||"utf-8",z().platform.encode(t,e)}function gs(t,e="utf-8"){return e=e||"utf-8",z().platform.decode(t,e)}var SS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",createScalarValue:er,toTypedArray:_r,now:Wt,fetch:kS,encodeString:_n,decodeString:gs,shuffle:Ly,shuffleCombo:Z2,clamp:Dr,nearestLargerEven:Zh,swap:Qn,sum:By,randUniform:J2,distSquared:eS,assert:S,assertShapesMatch:ct,assertNonNull:us,flatten:Zn,sizeFromShape:L,isScalarShape:tS,arraysEqual:Ie,isInt:kt,tanh:nS,sizeToSquarishShape:jc,createShuffledIndices:rS,rightPad:ds,repeatedTry:Jh,inferFromImplicitShape:em,parseAxisParam:ge,squeezeShape:Jn,getTypedArrayFromDType:Je,getArrayFromDType:St,checkConversionForErrors:Vy,isValidDtype:Wy,hasEncodingLoss:tm,isTypedArray:yt,bytesPerElement:Kc,bytesFromStringArray:zy,isString:An,isBoolean:Uy,isNumber:Gy,inferDtype:vo,isFunction:Fr,nearestDivisor:qc,computeStrides:ae,toNestedArray:un,makeOnesTypedArray:nm,makeZerosTypedArray:ut,makeZerosNestedTypedArray:rm,assertNonNegativeIntegerDimensions:sm,locToIndex:wn,indexToLoc:wo,isPromise:om,hexToLong:tl,fingerPrint64:iv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IS{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new TS)}profileKernel(e,n,r){let s;const o=()=>{s=r()};let a;const i=Wt();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const c of s)c.dataSync();a=Promise.resolve({kernelMs:Wt()-i})}if(z().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(d=>{ES(d,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:a.then(c=>c.kernelMs),extraInfo:a.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:o,extraInfo:a}=e;r.forEach(i=>{Promise.all([i.data(),s,a]).then(l=>{this.logger.logKernelProfile(n,i,l[0],l[1],o,l[2])})})}}function ES(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class TS{logKernelProfile(e,n,r,s,o,a){const i=typeof s=="number"?ds(`${s}ms`,9):s.error,l=ds(e,25),c=n.rank,u=n.size,d=ds(n.shape.toString(),14);let f="";for(const p in o){const h=o[p];if(h!=null){const g=h.shape||n.shape,m=g.length;f+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${i}	%c${c}D ${d}	%c${u}	%c${f}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(t,e,n){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const c=t[l],u=c.inputs;for(const d in u){const f=u[d];let p=!1;for(let h=0;h<e.length;h++)if(r[f.id]){c.outputs.forEach(g=>r[g.id]=!0),p=!0,s[c.id]=!0;break}if(p)break}}const o={};o[n.id]=!0;const a={};for(let l=t.length-1;l>=0;l--){const c=t[l],u=c.inputs;for(let d=0;d<c.outputs.length;d++)if(o[c.outputs[d].id]){for(const f in u)o[u[f].id]=!0,a[c.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const c=t[l];if(s[c.id]&&a[c.id]){const u={};for(const f in c.inputs){const p=c.inputs[f];r[p.id]&&(u[f]=p)}const d=Object.assign({},c);d.inputs=u,d.outputs=c.outputs,i.push(d)}}return i}function RS(t,e,n,r){for(let s=e.length-1;s>=0;s--){const o=e[s],a=[];if(o.outputs.forEach(l=>{const c=t[l.id];c!=null?a.push(c):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const i=o.gradient(a);for(const l in o.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);const c=n(()=>i[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=o.inputs[l];if(!Ie(c.shape,u.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(t[u.id]==null)t[u.id]=c;else{const d=t[u.id];t[u.id]=r(d,c),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lv=20,nl=3,Em=7;function DS(t,e,n,r){const s=ae(e),o=FS(t,e,n,s),a=e.length,i=Md(t,e,n,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(i.map(c=>"    "+c).join(`
`)),l.join(`
`)}function FS(t,e,n,r){const s=L(e),o=r[r.length-1],a=new Array(o).fill(0),i=e.length,l=n==="complex64"?sl(t):t;if(i>1)for(let c=0;c<s/o;c++){const u=c*o;for(let d=0;d<o;d++)a[d]=Math.max(a[d],rl(l[u+d],0,n).length)}return a}function rl(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(Em))} + ${parseFloat(t[1].toFixed(Em))}j`:An(t)?r=`'${t}'`:n==="bool"?r=cv(t):r=parseFloat(t.toFixed(Em)).toString(),ds(r,e)}function cv(t){return t===0?"false":"true"}function Md(t,e,n,r,s,o=!0){const a=n==="complex64"?2:1,i=e[0],l=e.length;if(l===0){if(n==="complex64"){const g=sl(t);return[rl(g[0],0,n)]}return n==="bool"?[cv(t[0])]:[t[0].toString()]}if(l===1){if(i>lv){const m=nl*a;let x=Array.from(t.slice(0,m)),y=Array.from(t.slice((i-nl)*a,i*a));return n==="complex64"&&(x=sl(x),y=sl(y)),["["+x.map((w,v)=>rl(w,s[v],n)).join(", ")+", ..., "+y.map((w,v)=>rl(w,s[i-nl+v],n)).join(", ")+"]"]}const g=n==="complex64"?sl(t):Array.from(t);return["["+g.map((m,x)=>rl(m,s[x],n)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),d=r[0]*a,f=[];if(i>lv){for(let g=0;g<nl;g++){const m=g*d,x=m+d;f.push(...Md(t.slice(m,x),c,n,u,s,!1))}f.push("...");for(let g=i-nl;g<i;g++){const m=g*d,x=m+d;f.push(...Md(t.slice(m,x),c,n,u,s,g===i-1))}}else for(let g=0;g<i;g++){const m=g*d,x=m+d;f.push(...Md(t.slice(m,x),c,n,u,s,g===i-1))}const p=l===2?",":"";f[0]="["+f[0]+p;for(let g=1;g<f.length-1;g++)f[g]=" "+f[g]+p;let h=`,
`;for(let g=2;g<l;g++)h+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(o?"":h),f}function sl(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class et{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=L(e),r!=null){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||St(n,this.size),this.strides=ae(e)}set(e,...n){n.length===0&&(n=[0]),S(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Pn().makeTensor(this.values,this.shape,this.dtype)}}let Pn=null,So=null;function AS(t){Pn=t}function _S(t){So=t}class qe{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=L(e),this.strides=ae(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return So.buffer(this.shape,this.dtype,e)}bufferSync(){return So.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return un(this.shape,e,this.dtype==="complex64")}arraySync(){return un(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Pn().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>gs(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=Pn().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>gs(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Pn().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Pn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return So.print(this,e)}clone(){return this.throwIfDisposed(),So.clone(this)}toString(e=!1){const n=this.dataSync();return DS(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),So.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),Pn().makeVariable(this,e,n,r)}}Object.defineProperty(qe,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function PS(){return lm("Tensor",()=>qe)}PS();class ol extends qe{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s);this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ie(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Pn().disposeTensor(this),this.dataId=e.dataId,Pn().incRef(this,null)}dispose(){Pn().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(ol,Symbol.hasInstance,{value:t=>t instanceof qe&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Tm;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(Tm||(Tm={}));var Nm;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(Nm||(Nm={}));var Rm;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(Rm||(Rm={}));var Dm;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(Dm||(Dm={}));var Fm;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(Fm||(Fm={}));const OS={float32:Dm,int32:Nm,bool:Rm,complex64:Fm};function zt(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return OS[t][e]}function Ld(t){return zt(t,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(t,e){if(t.dtype===e.dtype)return[t,e];const n=zt(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function uv(t,e){S(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function MS(t,e){return e.some(n=>n.id===t.id)}function Am(t){const e=[],n=new Set;return dv(t,e,n),e}function dv(t,e,n){if(t==null)return;if(t instanceof qe){e.push(t);return}if(!LS(t))return;const r=t;for(const s in r){const o=r[s];n.has(o)||(n.add(o),dv(o,e,n))}}function LS(t){return Array.isArray(t)||typeof t=="object"}var BS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",makeTypesMatch:We,assertTypesMatch:uv,isTensorInList:MS,getTensorsInContainer:Am});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _m(t){return t.kernelName!=null}class fv{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Io{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new fv}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(At(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new IS(this.backendInstance),!0}setupRegisteredKernels(){Ad(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Ad(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Hc)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(a=>s<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,At(`Initialization of backend ${e} failed`),At(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return At(`Initialization of backend ${e} failed`),At(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,o=this.readSync(n),a=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,o,r.shape,r.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return Io.nextTensorId++}nextVariableId(){return Io.nextVariableId++}clone(e){const n=R.runKernel(gi,{x:e}),r={x:e},s=a=>({x:()=>{const i="float32",l={x:a},c={dtype:i};return R.runKernel(ti,l,c)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,o,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(Fd(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let o=0;r.forEach(l=>{o+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=s-n-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let l;const c=_m(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(_m(e)){const{kernelName:h,inputs:g,attrs:m}=e;this.backendName==null&&this.backend;const x=Fd(h,this.backendName);S(x!=null,()=>`Cannot find registered kernel '${h}' for backend '${this.backendName}'`),i=()=>{const y=this.backend.numDataIds();l=x.kernelFunc({inputs:g,attrs:m,backend:this.backend});const w=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,y,w);const v=w.map($=>{if($.rank!=null)return $;const{dataId:b,shape:C,dtype:I}=$;return this.makeTensorFromDataId(b,C,I)});if(s){const $=this.getTensorsForGradient(h,g,v);r=this.saveTensorsForBackwardMode($)}return v}}else{const{forwardFunc:h}=e,g=m=>{!s||(r=m.map(x=>this.keep(this.clone(x))))};i=()=>{const m=this.backend.numDataIds();l=this.tidy(()=>h(this.backend,g));const x=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,m,x),x}}const{inputs:u,attrs:d}=e,f=_m(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(p=this.profiler.profileKernel(c,u,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),s&&this.addTapeNode(c,u,n,f,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(h=>u[h]!=null?u[h].shape:null),outputShapes:n.map(h=>h.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=$m(e);if(s!=null){const o=s.inputsToSave||[],a=s.outputsToSave||[];let i;s.saveAllInputs?(S(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(c=>n[c])):i=o.map(c=>n[c]);const l=r.filter((c,u)=>a[u]);return i.concat(l)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&An(e[0])&&(o=e.map(l=>_n(l)));const a=s.write(o,n,r),i=new qe(n,r,a,this.nextTensorId());if(this.trackTensor(i,s),r==="string"){const l=this.state.tensorInfo.get(a),c=zy(o);this.state.numBytes+=c-l.bytes,l.bytes=c}return i}makeTensorFromDataId(e,n,r,s){r=r||"float32";const o=new qe(n,r,e,this.nextTensorId());return this.trackTensor(o,s),o}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new ol(e,n,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Kc(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof ol||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Kc(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,o,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:o},l=$m(e);l!=null&&(s=l.gradFunc),s!=null&&(i.gradient=c=>(c=c.map((u,d)=>{if(u==null){const f=r[d],p=ut(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return u}),s(c.length>1?c:c[0],o,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=Am(e),r=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!r.has(a.id)&&a.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,n,r,s=!1){if(S(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(o instanceof qe,()=>"The result y returned by f() must be a tensor.");const a=NS(this.state.activeTape,n,o);if(!s&&a.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[o.id]=r==null?VS(o.shape):r,RS(i,a,c=>this.tidy(c),WS);const l=n.map(c=>i[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return S(Fr(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{S(n.every(i=>i instanceof qe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((i,l)=>{s[l]=i});const o=(i,l)=>(r=e(...n,l),S(r.value instanceof qe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(Fr(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),a=(i,l)=>{const c=r.gradFunc(i,l),u=Array.isArray(c)?c:[c];S(u.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(u.every(f=>f instanceof qe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return u.forEach((f,p)=>{d[p]=()=>f}),d};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const n=Wt(),r=await this.backend.time(e);return r.wallMs=Wt()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new fv;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Io.nextTensorId=0;Io.nextVariableId=0;function VS(t){const e=nm(L(t),"float32");return R.makeTensor(e,t,"float32")}function pv(){const t=qy();if(t._tfengine==null){const e=new Ky(t);t._tfengine=new Io(e)}return lS(t._tfengine.ENV),AS(()=>t._tfengine),t._tfengine}const R=pv();function WS(t,e){const n={a:t,b:e};return R.runKernel($o,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(){return typeof navigator!="undefined"&&navigator!=null}let Pm;function US(t){Pm=t}function Om(t){if(Pm!==void 0)return Pm;if(t||zS()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window!="undefined"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Mm(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var GS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",mockIsMobile:US,isMobile:Om,isBrowser:Mm});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bn=z();bn.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});bn.registerFlag("IS_BROWSER",()=>Mm());bn.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");bn.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));bn.registerFlag("PROD",()=>!1);bn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>bn.getBool("DEBUG"));bn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);bn.registerFlag("IS_TEST",()=>!1);bn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);bn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function On(t,e){let n=t;if(yt(t))return e==="string"?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||yt(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&z().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&hv(t,r,[]),r}function hv(t,e,n){if(n=n||[],!Array.isArray(t)&&!yt(t)){S(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}S(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),S(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)hv(t[s],r,n.concat(s))}function mv(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function k(t,e,n,r="numeric"){if(t instanceof qe)return mv(r,t.dtype,e,n),t;let s=vo(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),mv(r,s,e,n),t==null||!yt(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const o=On(t,s);!yt(t)&&!Array.isArray(t)&&(t=[t]);const i=s!=="string"?_r(t,s):Zn(t,[],!0);return R.makeTensor(i,o,s)}function al(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,a)=>k(o,`${e}[${a}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gv="__op";function N(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+gv;const s=(...o)=>{R.startScope(n);try{const a=r(...o);return om(a)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(a),a}catch(a){throw R.endScope(null),a}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HS(t,e){const n=k(t,"real","complex"),r=k(e,"imag","complex");ct(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return R.runKernel(iu,s)}const xs=N({complex_:HS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pr(t,e,n,r){if(r==null&&(r=vo(t)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!yt(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){sm(e);const s=L(e),o=L(n);S(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let a=0;a<n.length;++a){const i=n[a],l=a===n.length-1?i!==L(e.slice(a)):!0;S(n[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!yt(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?_r(t,r):Zn(t,[],!0),R.makeTensor(t,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eo(t,e,n){const r=On(t,n);return Pr(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lm={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bd=4;async function jS(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(a=>a.name):Object.keys(t);for(let a=0;a<s.length;++a){const i=s[a],l=Array.isArray(t)?t[a].tensor:t[i];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);const c={name:i,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async d=>{const f=await l.bytes(),p=f.reduce((m,x)=>m+x.length,0)+Bd*f.length,h=new Uint8Array(p);let g=0;for(let m=0;m<f.length;m++){const x=f[m],y=new Uint8Array(new Uint32Array([x.length]).buffer);h.set(y,g),g+=Bd,h.set(x,g),g+=x.length}d(h)});r.push(u)}else r.push(l.data());e!=null&&(c.group=e),n.push(c)}const o=await Promise.all(r);return{data:KS(o),specs:n}}function xv(t,e){const n={};let r,s=0;for(const o of e){const a=o.name,i=o.dtype,l=o.shape,c=L(l);let u;if("quantization"in o){const d=o.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const f=Lm[d.dtype],p=t.slice(s,s+c*f),h=d.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(i==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){u=new Float32Array(h.length);for(let g=0;g<h.length;g++){const m=h[g];u[g]=m*d.scale+d.min}}else if(d.dtype==="float16")r===void 0&&(r=JS()),u=r(h);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(i==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let g=0;g<h.length;g++){const m=h[g];u[g]=Math.round(m*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);s+=c*f}else if(i==="string"){const d=L(o.shape);u=[];for(let f=0;f<d;f++){const p=new Uint32Array(t.slice(s,s+Bd))[0];s+=Bd;const h=new Uint8Array(t.slice(s,s+p));u.push(h),s+=p}}else{const d=Lm[i],f=t.slice(s,s+c*d);if(i==="float32")u=new Float32Array(f);else if(i==="int32")u=new Int32Array(f);else if(i==="bool")u=new Uint8Array(f);else if(i==="complex64"){u=new Float32Array(f);const p=new Float32Array(u.length/2),h=new Float32Array(u.length/2);for(let x=0;x<p.length;x++)p[x]=u[x*2],h[x]=u[x*2+1];const g=Eo(p,l,"float32"),m=Eo(h,l,"float32");n[a]=xs(g,m),g.dispose(),m.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);s+=c*d}i!=="complex64"&&(n[a]=Eo(u,l,i))}return n}function KS(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(o=>{if(e+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const Bm=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function yv(t){return Bm?Buffer.byteLength(t):new Blob([t]).size}function qS(t){if(Bm)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function XS(t){if(Bm){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function Vm(t){if(t.length===1)return t[0];let e=0;t.forEach(s=>{e+=s.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function vv(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function wv(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}async function Wm(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),t.weightsManifest!=null){const[r,s]=await e(t.weightsManifest);n.weightSpecs=r,n.weightData=s}return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),n}function il(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:yv(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:yv(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:t.weightData.byteLength}}function YS(){const t=n=>{let r=n<<13,s=0;for(;(r&8388608)==0;)s-=8388608,r<<=1;return r&=~8388608,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function QS(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function ZS(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function JS(){const t=YS(),e=QS(),n=ZS();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let a=0;a<r.length;a++){const i=r[a],l=t[n[i>>10]+(i&1023)]+e[i>>10];o[a]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ze{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ze.instance==null&&(ze.instance=new ze),ze.instance}static registerSaveRouter(e){ze.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ze.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ze.getHandlers(e,"save")}static getLoadHandlers(e,n){return ze.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?ze.getInstance().loadRouters:ze.getInstance().saveRouters).forEach(a=>{const i=a(e,r);i!==null&&s.push(i)}),s}}const eI=t=>ze.registerSaveRouter(t),tI=t=>ze.registerLoadRouter(t),nI=t=>ze.getSaveHandlers(t),rI=(t,e)=>ze.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zm="tensorflowjs",Um=1,ys="models_store",Or="model_info_store";function $v(){if(!z().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window=="undefined"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Gm(t){const e=t.result;e.createObjectStore(ys,{keyPath:"modelPath"}),e.createObjectStore(Or,{keyPath:"modelPath"})}class vs{constructor(e){if(this.indexedDB=$v(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const o=this.indexedDB.open(zm,Um);o.onupgradeneeded=()=>Gm(o),o.onsuccess=()=>{const a=o.result;if(n==null){const i=a.transaction(ys,"readonly"),c=i.objectStore(ys).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=u=>(a.close(),s(c.error)),i.oncomplete=()=>a.close()}else{const i=il(n),l=a.transaction(Or,"readwrite");let c=l.objectStore(Or);const u=c.put({modelPath:this.modelPath,modelArtifactsInfo:i});let d;u.onsuccess=()=>{d=a.transaction(ys,"readwrite");const p=d.objectStore(ys).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i});p.onsuccess=()=>r({modelArtifactsInfo:i}),p.onerror=h=>{c=l.objectStore(Or);const g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),s(p.error)),g.onerror=m=>(a.close(),s(p.error))}},u.onerror=f=>(a.close(),s(u.error)),l.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},o.onerror=a=>s(o.error)})}}vs.URL_SCHEME="indexeddb://";const bv=t=>z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(vs.URL_SCHEME)?sI(t.slice(vs.URL_SCHEME.length)):null;ze.registerSaveRouter(bv);ze.registerLoadRouter(bv);function sI(t){return new vs(t)}function oI(t){return t.startsWith(vs.URL_SCHEME)?t.slice(vs.URL_SCHEME.length):t}class aI{constructor(){this.indexedDB=$v()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(zm,Um);r.onupgradeneeded=()=>Gm(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(Or,"readonly"),i=o.objectStore(Or).getAll();i.onsuccess=()=>{const l={};for(const c of i.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},i.onerror=l=>(s.close(),n(i.error)),o.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=oI(e),new Promise((n,r)=>{const s=this.indexedDB.open(zm,Um);s.onupgradeneeded=()=>Gm(s),s.onsuccess=()=>{const o=s.result,a=o.transaction(Or,"readwrite"),i=a.objectStore(Or),l=i.get(e);let c;l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=i.delete(e),d=()=>{c=o.transaction(ys,"readwrite");const p=c.objectStore(ys).delete(e);p.onsuccess=()=>n(l.result.modelArtifactsInfo),p.onerror=h=>r(l.error)};u.onsuccess=d,u.onerror=f=>(d(),o.close(),r(l.error))}},l.onerror=u=>(o.close(),r(l.error)),a.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tr="/",To="tensorflowjs_models",Cv="info",iI="model_topology",lI="weight_specs",cI="weight_data",uI="model_metadata";function kv(t){return{info:[To,t,Cv].join(tr),topology:[To,t,iI].join(tr),weightSpecs:[To,t,lI].join(tr),weightData:[To,t,cI].join(tr),modelMetadata:[To,t,uI].join(tr)}}function Sv(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function dI(t){const e=t.split(tr);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(tr)}function fI(t){return t.startsWith(ws.URL_SCHEME)?t.slice(ws.URL_SCHEME.length):t}class ws{constructor(e){if(!z().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=kv(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=il(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,qS(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw Sv(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const i=JSON.parse(o);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=XS(a),n}}ws.URL_SCHEME="localstorage://";const Iv=t=>z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ws.URL_SCHEME)?pI(t.slice(ws.URL_SCHEME.length)):null;ze.registerSaveRouter(Iv);ze.registerLoadRouter(Iv);function pI(t){return new ws(t)}class hI{constructor(){S(z().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=To+tr,r=tr+Cv;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(n)&&o.endsWith(r)){const a=dI(o);e[a]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=fI(e);const n=kv(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Sv(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No="://";class Ut{constructor(){this.managers={}}static getInstance(){return Ut.instance==null&&(Ut.instance=new Ut),Ut.instance}static registerManager(e,n){S(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(No)&&(e=e.slice(0,e.indexOf(No))),S(e.length>0,()=>"scheme must not be an empty string.");const r=Ut.getInstance();S(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=this.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(this.getInstance().managers)}}function Vd(t){if(t.indexOf(No)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ut.getSchemes().join(",")}`);return{scheme:t.split(No)[0],path:t.split(No)[1]}}async function Ev(t,e,n=!1){S(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=ze.getLoadHandlers(t);S(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),S(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],o=ze.getSaveHandlers(e);S(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),S(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const a=o[0],i=Vd(t).scheme,l=Vd(t).path,c=i===Vd(t).scheme,u=await s.load();n&&c&&await Ut.getManager(i).removeModel(l);const d=await a.save(u);return n&&!c&&await Ut.getManager(i).removeModel(l),d.modelArtifactsInfo}async function mI(){const t=Ut.getSchemes(),e={};for(const n of t){const r=await Ut.getManager(n).listModels();for(const s in r){const o=n+No+s;e[o]=r[s]}}return e}async function gI(t){const e=Vd(t);return Ut.getManager(e.scheme).removeModel(e.path)}async function xI(t,e){return Ev(t,e,!1)}async function yI(t,e){return Ev(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vI{fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}}if(z().get("IS_BROWSER")){z().setPlatform("browser",new vI);try{Ut.registerManager(ws.URL_SCHEME,new hI)}catch{}try{Ut.registerManager(vs.URL_SCHEME,new aI)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wI={importFetch:()=>require("node-fetch")};let Hm;class $I{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return z().global.fetch!=null?z().global.fetch(e,n):(Hm==null&&(Hm=wI.importFetch()),Hm(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}}z().get("IS_NODE")&&z().setPlatform("node",new $I);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function de(t,e="float32",n){return e=e||"float32",sm(t),new et(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bI(t,e){const n=k(t,"x","cast");if(!Wy(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return R.runKernel(ti,r,s)}const Ue=N({cast_:bI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CI(t){const n={x:k(t,"x","clone","string_or_numeric")};return R.runKernel(gi,n)}const $s=N({clone_:CI});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tv(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */pv();const kI={buffer:de,cast:Ue,clone:$s,print:Tv};_S(kI);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SI="model",II=".json",EI=".weights.bin";function Nv(t){return new Promise(e=>setTimeout(e)).then(t)}class bs{constructor(e){if(!z().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(bs.URL_SCHEME)&&(e=e.slice(bs.URL_SCHEME.length)),(e==null||e.length===0)&&(e=SI),this.modelJsonFileName=e+II,this.weightDataFileName=e+EI}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=wv(e,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await Nv(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=n,await Nv(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:il(e)}}}}bs.URL_SCHEME="downloads://";class TI{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const o=JSON.parse(s.target.result),a=o.modelTopology;if(a==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const l=Wm(o,c=>this.loadWeights(c));e(l)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const a of e)n.push(...a.weights),r.push(...a.paths);const s=this.checkManifestAndWeightFiles(e),o=r.map(a=>this.loadWeightsFile(a,s[a]));return Promise.all(o).then(a=>[n,Vm(a)])}loadWeightsFile(e,n){return new Promise((r,s)=>{const o=new FileReader;o.onload=a=>{const i=a.target.result;r(i)},o.onerror=a=>s(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(o=>vv(o.name)),s={};for(const o of e)o.paths.forEach(a=>{const i=vv(a);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),r.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);s[a]=this.weightsFiles[r.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const NI=t=>z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(bs.URL_SCHEME)?RI(t.slice(bs.URL_SCHEME.length)):null;ze.registerSaveRouter(NI);function RI(t="model"){return new bs(t)}function DI(t){return new TI(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rv(t,e,n,r){a(t),n=n==null?0:n,r=r==null?1:r,i(n,r);let s=0;const o=l=>(l.then(c=>{const u=n+ ++s/t.length*(r-n);return e(u),c}),l);function a(l){S(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function i(l,c){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),S(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(t.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Dv(t,e){e==null&&(e={});const n=e.fetchFunc==null?z().platform.fetch:e.fetchFunc,r=t.map(d=>n(d,e.requestInit,{isBinary:!0})),s=0,o=.5,i=(e.onProgress==null?await Promise.all(r):await Rv(r,e.onProgress,s,o)).map(d=>d.arrayBuffer()),l=.5,c=1;return e.onProgress==null?await Promise.all(i):await Rv(i,e.onProgress,l,c)}async function FI(t,e="",n,r){return Fv(a=>Dv(a,{requestInit:r}))(t,e,n)}function Fv(t){return async(e,n="",r)=>{const s=e.map(()=>!1),o={},a=r!=null?r.map(()=>!1):[],i=[];if(e.forEach((p,h)=>{let g=0;p.weights.forEach(m=>{const x="quantization"in m?m.quantization.dtype:m.dtype,y=Lm[x]*L(m.shape),w=()=>{s[h]=!0,o[h]==null&&(o[h]=[]),o[h].push({manifestEntry:m,groupOffset:g,sizeBytes:y})};r!=null?r.forEach((v,$)=>{v===m.name&&(w(),a[$]=!0)}):w(),i.push(m.name),g+=y})}),!a.every(p=>p)){const p=r.filter((h,g)=>!a[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const l=s.reduce((p,h,g)=>(h&&p.push(g),p),[]),c=[];l.forEach(p=>{e[p].paths.forEach(h=>{const g=n+(n.endsWith("/")?"":"/")+h;c.push(g)})});const u=await t(c),d={};let f=0;return l.forEach(p=>{const h=e[p].paths.length;let g=0;for(let v=0;v<h;v++)g+=u[f+v].byteLength;const m=new ArrayBuffer(g),x=new Uint8Array(m);let y=0;for(let v=0;v<h;v++){const $=new Uint8Array(u[f+v]);x.set($,y),y+=$.byteLength}o[p].forEach(v=>{const $=m.slice(v.groupOffset,v.groupOffset+v.sizeBytes),b=xv($,[v.manifestEntry]);for(const C in b)d[C]=b[C]}),f+=h}),d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AI="application/octet-stream",_I="application/json";class jm{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(S(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=z().platform.fetch,S(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=wv(e,r);n.body.append("model.json",new Blob([JSON.stringify(s)],{type:_I}),"model.json"),e.weightData!=null&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:AI}),"model.weights.bin");const o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:il(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Wm(n,o=>this.loadWeights(o))}async loadWeights(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=PI(n),o=this.weightPathPrefix||r,a=[];for(const u of e)a.push(...u.weights);const i=[],l=[];for(const u of e)for(const d of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):i.push(o+d+s);this.weightUrlConverter&&i.push(...await Promise.all(l));const c=await Dv(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,Vm(c)]}}jm.URL_SCHEME_REGEX=/^https?:\/\//;function PI(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function Km(t){return t.match(jm.URL_SCHEME_REGEX)!=null}const Av=(t,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>Km(r)):n=Km(t),n)return qm(t,e)}return null};ze.registerSaveRouter(Av);ze.registerLoadRouter(Av);function qm(t,e){return new jm(t,e)}function OI(t,e){return qm(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xm{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}}class MI{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}}function LI(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new Xm(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Xm({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Xm({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function BI(t){return new MI(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var VI=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",browserFiles:DI,browserHTTPRequest:OI,concatenateArrayBuffers:Vm,decodeWeights:xv,encodeWeights:jS,fromMemory:LI,getLoadHandlers:rI,getModelArtifactsForJSON:Wm,getModelArtifactsInfoForJSON:il,getSaveHandlers:nI,http:qm,isHTTPScheme:Km,loadWeights:FI,registerLoadRouter:tI,registerSaveRouter:eI,weightsLoaderFactory:Fv,withSaveHandler:BI,copyModel:xI,listModels:mI,moveModel:yI,removeModel:gI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(t,e,n=!1,r=!1){let s=k(t,"a","matMul"),o=k(e,"b","matMul");[s,o]=We(s,o);const a={a:s,b:o},i={transposeA:n,transposeB:r};return R.runKernel(ru,a,i)}const $e=N({matMul_:WI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zI(t,e,n=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:k(t,"indices","oneHot","int32")},a={depth:e,onValue:n,offValue:r};return R.runKernel(Yu,o,a)}const Ym=N({oneHot_:zI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UI(t,e){const n=k(t,"x","transpose");if(e==null&&(e=n.shape.map((o,a)=>a).reverse()),S(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(o=>{S(o>=0&&o<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${e}`)}),n.rank<=1)return n.clone();const r={x:n},s={perm:e};return R.runKernel(Sd,r,s)}const Wd=N({transpose_:UI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GI(t,e,n){const r=k(t,"labels","confusionMatrix"),s=k(e,"predictions","confusionMatrix");S(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),S(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),S(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),S(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),S(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const o=Ym(Ue(r,"int32"),n),a=Ym(Ue(s,"int32"),n),i=Wd(o),l=$e(i,a);return Ue(l,"int32")}const HI=N({confusionMatrix_:GI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var jI=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",confusionMatrix:HI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _v(t,e,n){if(us(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=On(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Pr(t,e,r,n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Cs;function Pv(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,a=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData!="undefined"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement!="undefined"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&t instanceof HTMLImageElement)o=!0;else if(t.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&t instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(s){const h=2;if(s&&t.readyState<h)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(Fd(Rd,R.backendName)!=null){const h={pixels:t},g={numChannels:e};return R.runKernel(Rd,h,g)}const[c,u]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d;if(a)d=t.getContext("2d").getImageData(0,0,c,u).data;else if(r||n)d=t.data;else if(o||s||i){if(Cs==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Cs=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Cs=document.createElement("canvas").getContext("2d");Cs.canvas.width=c,Cs.canvas.height=u,Cs.drawImage(t,0,0,c,u),d=Cs.getImageData(0,0,c,u).data}let f;if(e===4)f=new Int32Array(d);else{const h=c*u;f=new Int32Array(h*e);for(let g=0;g<h;g++)for(let m=0;m<e;++m)f[g*e+m]=d[g*4+m]}return _v(f,[u,c,e],"int32")}function KI(t){return t!=null&&t.data instanceof Uint8Array}function qI(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function XI(t){return t!=null&&t.width!==0&&t.height!==0}function YI(t){return qI()&&!(t instanceof ImageBitmap)&&XI(t)&&!KI(t)}async function QI(t,e=3){let n=null;if(z().getBool("WRAP_TO_IMAGEBITMAP")&&YI(t)){let r;try{r=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===t.width&&r.height===t.height?n=r:n=t}else n=t;return Pv(n,e)}async function ZI(t,e){let n=k(t,"img","toPixels");if(!(t instanceof qe)){const c=n;n=Ue(c,"int32"),c.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,s]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const a=await n.data(),i=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const u=[0,0,0,255];for(let f=0;f<o;f++){const p=a[c*o+f];if(n.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(n.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);o===1?(u[0]=p*i,u[1]=p*i,u[2]=p*i):u[f]=p*i}const d=c*4;l[d+0]=Math.round(u[0]),l[d+1]=Math.round(u[1]),l[d+2]=Math.round(u[2]),l[d+3]=Math.round(u[3])}if(e!=null){e.width=s,e.height=r;const c=e.getContext("2d"),u=new ImageData(l,s,r);c.putImageData(u,0,0)}return n!==t&&n.dispose(),l}const JI=N({fromPixels_:Pv});var eE=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",fromPixelsAsync:QI,toPixels:ZI,fromPixels:JI});function zd(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(L(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,o=s[s.length-1];let a=1;for(let d=0;d<s.length-1;++d)a*=s[d];const i=t.shape,l=s.slice();l.pop();let c=1;for(let d=o;d<n;++d)c*=i[d],l.push(i[d]);const u=[...ae(t.shape).map(d=>d/c),1].slice(0,o);return[l,a,c,u]}var tE=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",prepareAndValidate:zd});function Qm(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(o+` update.rank != ${s+t.length-r}`);for(let a=0;a<s;++a)if(n.shape[a]!==e.shape[a])throw new Error(o+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<n.rank-s;++a)if(n.shape[a+s]!==t[a+r])throw new Error(o+` updates.shape[${a+s}] (${n.shape[a+s]}) != shape[${a+s}] (${t[a+s]})`)}function Zm(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Qm(n,e,t)}function Ro(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=n.length;let a=1;for(let d=s;d<o;++d)a*=n[d];const i=s<1?1:s,l=L(e.shape)/i,c=[...ae(n.slice(0,s)),1],u=L(n);return{sliceRank:s,numUpdates:l,sliceSize:a,strides:c,outputSize:u}}var nE=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",validateUpdateShape:Qm,validateInput:Zm,calculateShapes:Ro});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jm=-2,rE=-1;function eg(t,e,n){const r=t.shape.length;S(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),S(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function sE(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function tg(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function Ov(t,e,n,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function Mv(t,e,n){return n<=t?n:n-(e-1)}function Lv(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function oE(t,e,n,r,s,o,a,i,l){const c=t.length;let u=new Array(c),d=new Array(c),f=new Array(c);if(e.length&&n>0){const p=e[0],h=n+1;u=Bv(a,p,h,r,t),d=Vv(i,p,h,s,t),f=Ov(o,p,h,t)}else for(let p=0;p<c;p++)u[p]=zv(a,r,o,t,p,l),d[p]=Uv(i,s,o,t,p,l),f[p]=Wv(o,p,l);return{begin:u,end:d,strides:f}}function Bv(t,e,n,r,s){const o=[...s],a=Lv(n,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{const l=Mv(e,n,i);let c=r[l];t&1<<l&&(c=0),o[i]=c}return o}function Vv(t,e,n,r,s){const o=[...s],a=Lv(n,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const l=Mv(e,n,i);let c=r[l];t&1<<l&&(c=Number.MAX_SAFE_INTEGER),o[i]=c}for(let i=0;i<o.length;i++){const l=s[i];o[i]<0&&(o[i]+=l),o[i]=Dr(0,o[i],s[i])}return o}function Wv(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function zv(t,e,n,r,s,o){let a=e[s];const i=n[s]||1;(t&1<<s||o&1<<s||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=r[s];return a<0&&(a+=l),a=Dr(0,a,l-1),a}function Uv(t,e,n,r,s,o){let a=e[s];const i=n[s]||1;(t&1<<s||o&1<<s||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=r[s];return a<0&&(a+=l),i>0?a=Dr(0,a,l):a=Dr(-1,a,l-1),a}function ng(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function rg(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function sg(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(a=>{S(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(s).fill(-1):typeof n=="number"?o=[n,...new Array(s-1).fill(-1)]:n.length<s?o=n.concat(new Array(s-n.length).fill(-1)):o=n,o=o.map((a,i)=>a>=0?a:(S(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),t.shape[i]-r[i])),[r,o]}function og(t,e,n,r,s,o,a,i,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,a!=null&&(a&a-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:s,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};for(let w=0;w<d.dims;w++)u&&(1<<w&i)!=0&&d.numAddAxisAfterEllipsis++,1<<w&a&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};aE(d,f);let p=!0,h=!0,g=!0;const m=[],x=[];for(let w=0;w<t.length;++w){if(f.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);const v=!!(f.shrinkAxisMask&1<<w),$=t[w];if($===-1){m.push(v?1:-1);continue}const b=[f.beginMask&1<<w,f.endMask&1<<w],C=[f.strides[w]>0?0:-1,f.strides[w]>0?$:$-1];if(v&&f.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&f.strides[w]===1;const I=!!(f.beginMask&1<<w&&f.endMask&1<<w);if(f.beginValid&&f.endValid){if(v){const F=f.begin[w]<0?$+f.begin[w]:f.begin[w];if(f.begin[w]=F,f.end[w]=f.begin[w]+1,F<0||F>=$)throw Error(`slice index ${f.begin[w]} of dimension ${w} out of bounds.`)}else f.begin[w]=Gv(f.begin[w],0,f.strides[w],$,b,C),f.end[w]=Gv(f.end[w],1,f.strides[w],$,b,C);const D=f.strides[w]===1&&f.begin[w]===0&&f.end[w]===$;p=p&&D,h=h&&(w===0&&f.strides[w]===1||D)}else p=p&&f.strides[w]===1&&I,h=h&&(w===0&&f.strides[w]===1||I);let E,T=!1;if(f.beginValid&&f.endValid?(E=f.end[w]-f.begin[w],T=!0):v?(E=1,T=!0):I&&$>=0&&(f.strides[w]<0?E=-$:E=$,T=!0),T){let D;E===0||E<0!=f.strides[w]<0?D=0:D=Math.trunc(E/f.strides[w])+(E%f.strides[w]!=0?1:0),m.push(D)}else m.push(-1)}for(let w=0;w<f.finalShapeGatherIndices.length;++w){const v=f.finalShapeGatherIndices[w];v>=0?x.push(m[v]):v===Jm&&x.push(1)}return{finalShapeSparse:x.filter((w,v)=>f.finalShapeGatherIndices[v]!==Jm),finalShape:x,isIdentity:p,sliceDim0:h,isSimpleSlice:g,begin:f.begin,end:f.end,strides:f.strides}}function aE(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(Jm),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(rE),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function Gv(t,e,n,r,s,o){if(s[e])return n>0?o[e]:o[e+1&1];{const a=t<0?r+t:t;return a<o[0]?o[0]:a>o[1]?o[1]:a}}var Hv=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",assertParamsValid:eg,maskToAxes:sE,computeOutShape:tg,stridesWithElidedDims:Ov,getNormalizedAxes:oE,startIndicesWithElidedDims:Bv,stopIndicesWithElidedDims:Vv,stridesForAxis:Wv,startForAxis:zv,stopForAxis:Uv,isSliceContinous:ng,computeFlatOffset:rg,parseSliceParams:sg,sliceInfo:og});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jv{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class Mr{constructor(){this.classNameMap={}}static getMap(){return Mr.instance==null&&(Mr.instance=new Mr),Mr.instance}static register(e){Mr.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Lr(t){S(t.className!=null,()=>"Class being registered does not have the static className property defined."),S(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),S(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Mr.register(t)}var iE=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",Serializable:jv,SerializationMap:Mr,registerClass:Lr});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lE=.001,Kv=.1;function cE(t,e,n){return n==null&&(n=ag()),ig(t,e,(r,s)=>lg(r,s,n))}function ag(){return R.backend.floatPrecision()===32?lE:Kv}function ig(t,e,n){let r=!0;if((yt(t)||yt(e))&&(r=!1),yt(t)&&yt(e)&&(r=!0),r){const a=t.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(t)&&Array.isArray(e)){const a=On(t),i=On(e);if(!Ie(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}const s=yt(t)?t:Zn(t),o=yt(e)?e:Zn(e);if(s.length!==o.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${o.length}.
Actual:   ${s}.
Expected: ${o}.`);for(let a=0;a<o.length;++a){const i=s[a],l=o[a];if(!n(i,l))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${l}.
Actual:   ${s}.
Expected: ${o}.`)}}function uE(t,e){t().then(()=>e.fail(),()=>e())}function dE(t,e){const n=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return An(t)||An(t[0])||An(e)||An(e[0])?ig(t,n,(r,s)=>r==s):ig(t,e,(r,s)=>lg(r,s,0))}function fE(t,e,n){if(n==null&&(n=ag()),!lg(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`)}function lg(t,e,n){return!isFinite(t)&&!isFinite(e)?!0:!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function pE(t,e,n){for(let r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error(`Value out of range:${t[r]} low: ${e}, high: ${n}`)}function hE(t,e){expect(new Float32Array(t)).toEqual(new Float32Array(e))}function qv(t){for(let e=0;e<t.length;e++){const n=t[e];Array.isArray(n)?qv(n):t[e]=_n(n)}return t}var mE=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",TEST_EPSILON_FLOAT16:Kv,expectArraysClose:cE,testEpsilon:ag,expectPromiseToFail:uE,expectArraysEqual:dE,expectNumbersClose:fE,expectValuesInRange:pE,expectArrayBuffersEqual:hE,encodeStrings:qv});/** @license See the LICENSE file. */const gE="3.11.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xE(){z().set("PROD",!0)}function yE(){z().set("DEBUG",!0)}function vE(){z().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function wE(t){z().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function $E(){R.disposeVariables()}function Br(){return R}function bE(){return R.memory()}function CE(t){return R.profile(t)}function Xe(t,e){return R.tidy(t,e)}function _t(t){Am(t).forEach(n=>n.dispose())}function Xv(t){return R.keep(t)}function kE(t){return R.time(t)}function SE(t){return R.setBackend(t)}function IE(){return R.ready()}function EE(){return R.backendName}function TE(t){R.removeBackend(t)}function NE(t){return R.findBackend(t)}function RE(t){return R.findBackendFactory(t)}function cg(t,e,n=1){return R.registerBackend(t,e,n)}function DE(){return R.backend}function FE(t,e){z().setPlatform(t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(t,e){let n=k(t,"a","add"),r=k(e,"b","add");[n,r]=We(n,r);const s={a:n,b:r};return R.runKernel($o,s)}const le=N({add_:AE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _E(t,e){let n=k(t,"a","floorDiv"),r=k(e,"b","floorDiv");[n,r]=We(n,r);const s={a:n,b:r};return R.runKernel(pi,s)}const Yv=N({floorDiv_:_E});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PE(t,e){let n=k(t,"a","div"),r=k(e,"b","div");if([n,r]=We(n,r),n.dtype==="int32"&&r.dtype==="int32")return Yv(n,r);const s={a:n,b:r},o={};return R.runKernel(ai,s,o)}const Ae=N({div_:PE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OE(t,e){let n=k(t,"a","mul"),r=k(e,"b","mul");[n,r]=We(n,r);const s={a:n,b:r};return R.runKernel(Ri,s)}const Z=N({mul_:OE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ME(t){const e=k(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return R.runKernel(lu,n)}else{const n={x:e};return R.runKernel(Xc,n)}}const Yt=N({abs_:ME});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LE(t){const n={x:k(t,"x","acos")};return R.runKernel(qa,n)}const BE=N({acos_:LE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VE(t){const n={x:k(t,"x","acosh")};return R.runKernel(Xa,n)}const WE=N({acosh_:VE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zE(t){S(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),S(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,o)=>k(s,`tensors${o}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Ie(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return R.runKernel(Yc,r)}const UE=N({addN_:zE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GE(t,e=null,n=!1){const s={x:k(t,"x","all","bool")},o={axis:e,keepDims:n};return R.runKernel(Qc,s,o)}const HE=N({all_:GE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jE(t,e=null,n=!1){const s={x:k(t,"x","any","bool")},o={axis:e,keepDims:n};return R.runKernel(Zc,s,o)}const KE=N({any_:jE});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qE(t,e=0){const r={x:k(t,"x","argMax")},s={axis:e};return R.runKernel(Jc,r,s)}const XE=N({argMax_:qE});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YE(t,e=0){const r={x:k(t,"x","argMin")},s={axis:e};return R.runKernel(eu,r,s)}const QE=N({argMin_:YE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZE(t){const n={x:k(t,"x","asin")};return R.runKernel(Ya,n)}const JE=N({asin_:ZE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eT(t){const n={x:k(t,"x","asinh")};return R.runKernel(Qa,n)}const tT=N({asinh_:eT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nT(t){const n={x:k(t,"x","atan")};return R.runKernel(Za,n)}const rT=N({atan_:nT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sT(t,e){let n=k(t,"a","atan2"),r=k(e,"b","atan2");[n,r]=We(n,r);const s={a:n,b:r};return R.runKernel(ei,s)}const oT=N({atan2_:sT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(t){const n={x:k(t,"x","atanh")};return R.runKernel(Ja,n)}const iT=N({atanh_:aT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ll(t,e,n,r,s="NHWC",o){const a=t[3],i=[...e,a],l=rr(s);return st(t,i,n,o,r,null,null,l)}function hn(t,e,n,r,s,o,a="channelsLast"){const[i,l]=Ud(e);let c;if(a==="channelsLast")c=[i,l,t[3],t[3]];else if(a==="channelsFirst")c=[i,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return st(t,c,n,r,s,o,!1,a)}function nr(t,e,n,r,s,o,a="NDHWC"){const[i,l,c]=dg(e);let u,d;if(a==="NDHWC")d="channelsLast",u=[i,l,c,t[4],t[4]];else if(a==="NCDHW")d="channelsFirst",u=[i,l,c,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return Vr(t,u,n,r,s,!1,d,o)}function st(t,e,n,r,s,o,a=!1,i="channelsLast"){let[l,c,u,d]=[-1,-1,-1,-1];if(i==="channelsLast")[l,c,u,d]=t;else if(i==="channelsFirst")[l,d,c,u]=t;else throw new Error(`Unknown dataFormat ${i}`);const[f,p,,h]=e,[g,m]=Ud(n),[x,y]=Ud(r),w=Do(f,x),v=Do(p,y),{padInfo:$,outHeight:b,outWidth:C}=uT(s,c,u,g,m,w,v,o,i),I=a?h*d:h;let E;return i==="channelsFirst"?E=[l,I,b,C]:i==="channelsLast"&&(E=[l,b,C,I]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:d,outHeight:b,outWidth:C,outChannels:I,padInfo:$,strideHeight:g,strideWidth:m,filterHeight:f,filterWidth:p,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:x,dilationWidth:y,inShape:t,outShape:E,filterShape:e}}function Vr(t,e,n,r,s,o=!1,a="channelsLast",i){let[l,c,u,d,f]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,d,f]=t;else if(a==="channelsFirst")[l,f,c,u,d]=t;else throw new Error(`Unknown dataFormat ${a}`);const[p,h,g,,m]=e,[x,y,w]=dg(n),[v,$,b]=dg(r),C=Do(p,v),I=Do(h,$),E=Do(g,b),{padInfo:T,outDepth:D,outHeight:F,outWidth:A}=dT(s,c,u,d,x,y,w,C,I,E,i),P=o?m*f:m;let M;return a==="channelsFirst"?M=[l,P,D,F,A]:a==="channelsLast"&&(M=[l,D,F,A,P]),{batchSize:l,dataFormat:a,inDepth:c,inHeight:u,inWidth:d,inChannels:f,outDepth:D,outHeight:F,outWidth:A,outChannels:P,padInfo:T,strideDepth:x,strideHeight:y,strideWidth:w,filterDepth:p,filterHeight:h,filterWidth:g,effectiveFilterDepth:C,effectiveFilterHeight:I,effectiveFilterWidth:E,dilationDepth:v,dilationHeight:$,dilationWidth:b,inShape:t,outShape:M,filterShape:e}}function lT(t,e,n,r,s){r==null&&(r=ug(t,e,n));const o=t[0],a=t[1],i=ks((o-e+2*r)/n+1,s),l=ks((a-e+2*r)/n+1,s);return[i,l]}function cT(t,e,n,r,s,o){s==null&&(s=ug(t,e,r));const a=t[0],i=t[1],l=t[2],c=ks((a-e+2*s)/r+1,o),u=ks((i-e+2*s)/r+1,o),d=ks((l-e+2*s)/r+1,o);return[c,u,d,n]}function ug(t,e,n,r=1){const s=Do(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function Ud(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function dg(t){return typeof t=="number"?[t,t,t]:t}function Do(t,e){return e<=1?t:t+(t-1)*(e-1)}function uT(t,e,n,r,s,o,a,i,l){let c,u,d;if(typeof t=="number"){c={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const p=lT([e,n],o,r,t,i);u=p[0],d=p[1]}else if(t==="same"){u=Math.ceil(e/r),d=Math.ceil(n/s);const f=Math.max(0,(u-1)*r+o-e),p=Math.max(0,(d-1)*s+a-n),h=Math.floor(f/2),g=f-h,m=Math.floor(p/2),x=p-m;c={top:h,bottom:g,left:m,right:x,type:"SAME"}}else if(t==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-o+1)/r),d=Math.ceil((n-a+1)/s);else if(typeof t=="object"){const f=l==="channelsLast"?t[1][0]:t[2][0],p=l==="channelsLast"?t[1][1]:t[2][1],h=l==="channelsLast"?t[2][0]:t[3][0],g=l==="channelsLast"?t[2][1]:t[3][1];c={top:f,bottom:p,left:h,right:g,type:f===0&&p===0&&h===0&&g===0?"VALID":"EXPLICIT"},u=ks((e-o+f+p)/r+1,i),d=ks((n-a+h+g)/s+1,i)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outHeight:u,outWidth:d}}function dT(t,e,n,r,s,o,a,i,l,c,u){let d,f,p,h;if(typeof t=="number"){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const m=cT([e,n,r,1],i,1,s,t,u);f=m[0],p=m[1],h=m[2]}else if(t==="same"){f=Math.ceil(e/s),p=Math.ceil(n/o),h=Math.ceil(r/a);const g=(f-1)*s+i-e,m=(p-1)*o+l-n,x=(h-1)*a+c-r,y=Math.floor(g/2),w=g-y,v=Math.floor(m/2),$=m-v,b=Math.floor(x/2),C=x-b;d={top:v,bottom:$,left:b,right:C,front:y,back:w,type:"SAME"}}else if(t==="valid")d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((e-i+1)/s),p=Math.ceil((n-l+1)/o),h=Math.ceil((r-c+1)/a);else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:d,outDepth:f,outHeight:p,outWidth:h}}function ks(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function cl(t){const[e,n,r]=Ud(t);return e===1&&n===1&&r===1}function vt(t,e){return cl(t)||cl(e)}function rr(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fT(t,e){const r={x:k(t,"x","reshape","string_or_numeric")},s={shape:e};return R.runKernel(rd,r,s)}const H=N({reshape_:fT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pT(t,e,n,r,s){const o=k(t,"x","avgPool","float32"),a=1;S(vt(n,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let i=o,l=!1;o.rank===3&&(l=!0,i=H(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),s!=null&&S(kt(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let d=R.runKernel(tu,c,u);return d=Ue(d,o.dtype),l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Qv=N({avgPool_:pT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hT(t,e,n,r,s,o="NDHWC"){const a=k(t,"x","avgPool3d","float32");let i=a,l=!1;a.rank===4&&(l=!0,i=H(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),S(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&S(kt(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o};let d=R.runKernel(nu,c,u);return d=Ue(d,i.dtype),l?H(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const mT=N({avgPool3d_:hT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT(t,e=0){S(t.length>=1,()=>"Pass at least one tensor to concat");const n=al(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return $s(n[0]);const r=n,s={axis:e};return R.runKernel(cu,r,s)}const Gt=N({concat_:gT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xT(t){const n={x:k(t,"x","sigmoid","float32")};return R.runKernel(zi,n)}const Fo=N({sigmoid_:xT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yT(t,e,n){const r=k(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:n};return R.runKernel(cd,s,o)}const Me=N({slice_:yT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vT(t){const n={x:k(t,"x","tanh","float32")};return R.runKernel(qi,n)}const fg=N({tanh_:vT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wT(t,e,n,r,s,o){const a=k(t,"forgetBias","basicLSTMCell"),i=k(e,"lstmKernel","basicLSTMCell"),l=k(n,"lstmBias","basicLSTMCell"),c=k(r,"data","basicLSTMCell"),u=k(s,"c","basicLSTMCell"),d=k(o,"h","basicLSTMCell"),f=Gt([c,d],1),p=$e(f,i),h=le(p,l),g=h.shape[0],m=h.shape[1]/4,x=[g,m],y=Me(h,[0,0],x),w=Me(h,[0,m],x),v=Me(h,[0,m*2],x),$=Me(h,[0,m*3],x),b=le(Z(Fo(y),fg(w)),Z(u,Fo(le(a,v)))),C=Z(fg(b),Fo($));return[b,C]}const $T=N({basicLSTMCell_:wT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bT(t,e,n){const r=k(t,"x","batchToSpaceND"),s=e.reduce((i,l)=>i*l);S(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),S(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),S(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},a={blockShape:e,crops:n};return R.runKernel(su,o,a)}const Zv=N({batchToSpaceND_:bT});function CT(t){let e;return t.rank===0||t.rank===1?e=H(t,[1,1,1,t.size]):t.rank===2?e=H(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=H(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kT(t,e,n,r,s,o){o==null&&(o=.001);const a=k(t,"x","batchNorm"),i=k(e,"mean","batchNorm"),l=k(n,"variance","batchNorm");let c;s!=null&&(c=k(s,"scale","batchNorm"));let u;r!=null&&(u=k(r,"offset","batchNorm")),S(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:CT(a),scale:c,offset:u,mean:i,variance:l},p={varianceEpsilon:o},h=R.runKernel(Nu,f,p);return H(h,a.shape)}const Gd=N({batchNorm_:kT});function ST(t,e,n,r,s,o){const a=k(t,"x","batchNorm"),i=k(e,"mean","batchNorm"),l=k(n,"variance","batchNorm");let c;s!=null&&(c=k(s,"scale","batchNorm"));let u;return r!=null&&(u=k(r,"offset","batchNorm")),S(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),S(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),S(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&S(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),Gd(a,i,l,u,c,o)}const IT=N({batchNorm2d_:ST});function ET(t,e,n,r,s,o){const a=k(t,"x","batchNorm"),i=k(e,"mean","batchNorm"),l=k(n,"variance","batchNorm");let c;s!=null&&(c=k(s,"scale","batchNorm"));let u;return r!=null&&(u=k(r,"offset","batchNorm")),S(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),S(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),S(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&S(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),Gd(a,i,l,u,c,o)}const TT=N({batchNorm3d_:ET});function NT(t,e,n,r,s,o){const a=k(t,"x","batchNorm"),i=k(e,"mean","batchNorm"),l=k(n,"variance","batchNorm");let c;s!=null&&(c=k(s,"scale","batchNorm"));let u;return r!=null&&(u=k(r,"offset","batchNorm")),S(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),S(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),S(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&S(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),Gd(a,i,l,u,c,o)}const RT=N({batchNorm4d_:NT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DT(t,e,n){const r=k(t,"x","bincount"),s=k(e,"weights","bincount");S(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(n>=0,()=>`size must be non-negative, but got ${n}.`),S(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},a={size:n};return R.runKernel(ou,o,a)}const Jv=N({bincount_:DT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(t,e){const n=k(t,"s0","broadcastArgs","int32"),r=k(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return R.runKernel(au,s)}const AT=N({broadcastArgs_:FT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _T(t,e){let n=k(t,"broadcastTo","x");const r=n.shape;if(e.some(c=>!(c>0)||c%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const c=n.shape.slice();for(;c.length<e.length;)c.unshift(1);n=H(n,c)}const s=n.shape,o=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])o[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return $s(n);const i={x:n},l={reps:o};return R.runKernel(Xi,i,l)}const Hd=N({broadcastTo_:_T});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PT(t){const n={x:k(t,"x","ceil","float32")};return R.runKernel(ni,n)}const OT=N({ceil_:PT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MT(t,e,n){const r=k(t,"x","clipByValue");S(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`);const s={x:r},o={clipValueMin:e,clipValueMax:n};return R.runKernel(ri,s,o)}const LT=N({clipByValue_:MT});function BT(t){return Gt(t,0)}const VT=N({concat1d_:BT});function WT(t,e){return Gt(t,e)}const zT=N({concat2d_:WT});function UT(t,e){return Gt(t,e)}const GT=N({concat3d_:UT});function HT(t,e){return Gt(t,e)}const jT=N({concat4d_:HT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KT(t,e,n,r,s="NHWC",o=[1,1],a){const i=k(t,"x","conv2d","float32"),l=k(e,"filter","conv2d","float32");let c=i,u=!1;i.rank===3&&(u=!0,c=H(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),S(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),a!=null&&S(kt(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const d=s==="NHWC"?c.shape[3]:c.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(vt(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const f={x:c,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a},h=R.runKernel(uu,f,p);return u?H(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const jd=N({conv2d_:KT});function qT(t,e,n,r,s="NWC",o=1,a){const i=k(t,"x","conv1d"),l=k(e,"filter","conv1d");let c=i,u=!1;i.rank===2&&(u=!0,c=H(i,[1,i.shape[0],i.shape[1]])),S(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),S(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),a!=null&&S(kt(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),S(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(vt(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),S(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=H(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=H(c,[c.shape[0],1,c.shape[1],c.shape[2]]),m=jd(f,d,[1,n],r,"NHWC",[1,o],a);return u?H(m,[m.shape[2],m.shape[3]]):H(m,[m.shape[0],m.shape[2],m.shape[3]])}const XT=N({conv1d_:qT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YT(t,e,n,r,s,o="NHWC",a){S(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,l=e,c=!1;e.rank===3&&(c=!0,l=H(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),S(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),S(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const u=o==="NHWC"?i[3]:i[1],d=o==="NHWC"?l.shape[3]:l.shape[1];S(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),S(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),a!=null&&S(kt(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const f={dy:l,filter:n},p={strides:r,pad:s,dataFormat:o,dimRoundingMode:a,inputShape:i},h=R.runKernel(fu,f,p);return c?H(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ew=N({conv2DBackpropInput_:YT});function QT(t,e,n,r,s,o){const a=k(t,"x","conv2dTranspose"),i=k(e,"filter","conv2dTranspose");return ew(n,a,i,r,s,"NHWC",o)}const ZT=N({conv2dTranspose_:QT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JT(t,e,n,r,s="NDHWC",o=[1,1,1]){const a=k(t,"x","conv3d"),i=k(e,"filter","conv3d");let l=a,c=!1;a.rank===4&&(c=!0,l=H(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),S(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),S(vt(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),S(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const u={x:l,filter:i},d={strides:n,pad:r,dataFormat:s,dilations:o},f=R.runKernel(pu,u,d);return c?H(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const eN=N({conv3d_:JT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tN(t,e,n,r,s){S(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,a=e,i=!1;e.rank===4&&(i=!0,a=H(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],c=a.shape[4];S(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),S(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),S(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),S(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),S(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const u={dy:a,filter:n},d={pad:s,strides:r,inputShape:o},f=R.runKernel(hu,u,d);return i?H(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const nN=N({conv3DBackpropInput_:tN});function rN(t,e,n,r,s){const o=k(t,"x","conv3dTranspose"),a=k(e,"filter","conv3dTranspose");return nN(n,o,a,r,s)}const sN=N({conv3dTranspose_:rN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oN(t){const n={x:k(t,"x","cos","float32")};return R.runKernel(si,n)}const aN=N({cos_:oN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(t){const n={x:k(t,"x","cosh","float32")};return R.runKernel(oi,n)}const lN=N({cosh_:iN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cN(t,e=0,n=!1,r=!1){const o={x:k(t,"x","cumsum")},a={axis:e,exclusive:n,reverse:r};return R.runKernel(mu,o,a)}const uN=N({cumsum_:cN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dN(t,e,n,r=!1){const s=k(t,"x","denseBincount"),o=k(e,"weights","denseBincount");S(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(n>=0,()=>`size must be non-negative, but got ${n}.`),S(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const a={x:s,weights:o},i={size:n,binaryOutput:r};return R.runKernel(xu,a,i)}const fN=N({denseBincount_:dN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pN(t,e,n="NHWC"){const r=k(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],o=n==="NHWC"?r.shape[2]:r.shape[3],a=n==="NHWC"?r.shape[3]:r.shape[1];S(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),S(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),S(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),S(a%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${r.shape}`);const i={x:r},l={blockSize:e,dataFormat:n};return R.runKernel(yu,i,l)}const hN=N({depthToSpace_:pN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mN(t,e,n,r,s="NHWC",o=[1,1],a){const i=k(t,"x","depthwiseConv2d","float32"),l=k(e,"filter","depthwiseConv2d","float32");let c=i,u=!1;i.rank===3&&(u=!0,c=H(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),S(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),S(c.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),a!=null&&S(kt(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const d={x:c,filter:l},f={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a},p=R.runKernel(vu,d,f);return u?H(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const pg=N({depthwiseConv2d_:mN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gN(t){const n={x:k(t,"x","diag")};return R.runKernel(bu,n)}const xN=N({diag_:gN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yN(t,e,n,r,s=[1,1],o="NHWC"){const a=k(t,"x","dilation2d"),i=k(e,"filter","dilation2d");S(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),S(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),S(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=a,c=!1;a.rank===3&&(l=H(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0);const u={x:l,filter:i},d={strides:n,pad:r,dilations:s},f=R.runKernel(Cu,u,d);return c?H(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const vN=N({dilation2d_:yN});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ao(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,a=t[o]||1;(e[e.length-1-s]||1)>1&&a===1&&r.unshift(o)}return r}function tw(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],o=e.length-r-1,a=e[o];(s==null||s===1&&a>1)&&n.unshift(o)}return n}function ye(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let o=t[t.length-s-1];o==null&&(o=1);let a=e[e.length-s-1];if(a==null&&(a=1),o===1)n.unshift(a);else if(a===1)n.unshift(o);else if(o!==a){const i=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(i)}else n.unshift(o)}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wN(t,e){let n=k(t,"a","equal","string_or_numeric"),r=k(e,"b","equal","string_or_numeric");[n,r]=We(n,r),ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(ci,s)}const nw=N({equal_:wN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(t,e,n){const r=k(e,"a","where"),s=k(n,"b","where"),o=k(t,"condition","where","bool"),a=ye(ye(o.shape,r.shape),s.shape),i=Hd(o,a),l=Hd(r,a),c=Hd(s,a),u={condition:i,t:l,e:c};return R.runKernel(ld,u)}const _o=N({where_:$N});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bN(t){const n={x:k(t,"x","zerosLike")};return R.runKernel(Nd,n)}const Qt=N({zerosLike_:bN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(t,e){let n=k(t,"a","div"),r=k(e,"b","div");[n,r]=We(n,r);const s=Ae(n,r),o=Qt(s),a=nw(r,o);return _o(a,o,s)}const kN=N({divNoNan_:CN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SN(t,e){const n=k(t,"t1","dot"),r=k(e,"t2","dot");S((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],o=r.rank===1?r.size:r.shape[0];if(S(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),n.rank===1&&r.rank===1){const a=H(n,[1,-1]),i=H(r,[-1,1]),l=$e(a,i);return H(l,[])}else if(n.rank===1&&r.rank===2){const a=H(n,[1,-1]),i=H(r,[r.shape[0],r.shape[1]]),l=$e(a,i);return H(l,[l.size])}else if(n.rank===2&&r.rank===1){const a=H(r,[-1,1]),i=$e(n,a);return H(i,[i.size])}else{const a=H(r,[r.shape[0],r.shape[1]]);return $e(n,a)}}const IN=N({dot_:SN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EN(t,...e){const n=e.map((s,o)=>k(s,`tensors${o}`,"einsum")),r={equation:t};return R.runKernel(ku,n,r)}const TN=N({einsum_:EN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(t){const n={x:k(t,"x","elu","float32")};return R.runKernel(ii,n)}const rw=N({elu_:NN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(t){let e=k(t,"x","erf");S(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ue(e,"float32"));const n={x:e};return R.runKernel(li,n)}const DN=N({erf_:RN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(t){const n={x:k(t,"x","exp")};return R.runKernel(ui,n)}const Ss=N({exp_:FN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(t,e=0){const n=k(t,"x","expandDims","string_or_numeric");S(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return R.runKernel(Su,r,s)}const Is=N({expandDims_:AN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(t){const n={x:k(t,"x","expm1")};return R.runKernel(di,n)}const PN=N({expm1_:_N});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ON(t,e){const n=k(t,"x","tile","string_or_numeric");S(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return R.runKernel(Xi,r,s)}const ul=N({tile_:ON});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MN(t,e,n,r="float32"){e==null&&(e=t);const s=de([t,e],r),o=t<=e?t:e;for(let i=0;i<o;++i)s.set(1,i,i);const a=H(s.toTensor(),[t,e]);if(n==null)return a;if(n.length===1)return ul(Is(a,0),[n[0],1,1]);if(n.length===2)return ul(Is(Is(a,0),0),[n[0],n[1],1,1]);if(n.length===3)return ul(Is(Is(Is(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const sw=N({eye_:MN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kd(t,e,n){const r={shape:t,value:e,dtype:n};return R.runKernel(Eu,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LN(t){const n={x:k(t,"x","floor","float32")};return R.runKernel(fi,n)}const ow=N({floor_:LN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN(t,e,n=0,r=0){const s=k(t,"x","gather"),o=k(e,"indices","gather","int32"),a={x:s,indices:o},i={axis:n,batchDims:r};return R.runKernel(Ru,a,i)}const aw=N({gather_:BN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VN(t,e){let n=k(t,"a","greater","string_or_numeric"),r=k(e,"b","greater","string_or_numeric");[n,r]=We(n,r),ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(hi,s)}const qd=N({greater_:VN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WN(t,e){let n=k(t,"a","greaterEqual","string_or_numeric"),r=k(e,"b","greaterEqual","string_or_numeric");[n,r]=We(n,r),ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(mi,s)}const iw=N({greaterEqual_:WN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zN(t){const n={input:k(t,"input","imag")};return R.runKernel(Au,n)}const hg=N({imag_:zN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UN(t){const n={x:k(t,"x","isFinite")};return R.runKernel(xi,n)}const GN=N({isFinite_:UN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HN(t){const n={x:k(t,"x","isInf")};return R.runKernel(yi,n)}const jN=N({isInf_:HN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KN(t){const n={x:k(t,"x","isNaN")};return R.runKernel(vi,n)}const qN=N({isNaN_:KN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XN(t,e=.2){const r={x:k(t,"x","leakyRelu")},s={alpha:e};return R.runKernel(_u,r,s)}const lw=N({leakyRelu_:XN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YN(t,e){let n=k(t,"a","less","string_or_numeric"),r=k(e,"b","less","string_or_numeric");[n,r]=We(n,r),ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(wi,s)}const QN=N({less_:YN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZN(t,e){let n=k(t,"a","lessEqual","string_or_numeric"),r=k(e,"b","lessEqual","string_or_numeric");[n,r]=We(n,r),ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel($i,s)}const mg=N({lessEqual_:ZN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JN(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return R.runKernel(Pu,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eR(t,e=5,n=1,r=1,s=.5){const o=k(t,"x","localResponseNormalization");S(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),S(kt(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=H(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:a},c={depthRadius:e,bias:n,alpha:r,beta:s},u=R.runKernel(Ou,l,c);return i?H(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const tR=N({localResponseNormalization_:eR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nR(t){const n={x:k(t,"x","log","float32")};return R.runKernel(bi,n)}const dl=N({log_:nR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rR(t){const n={x:k(t,"x","log1p")};return R.runKernel(Ci,n)}const cw=N({log1p_:rR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sR(t){return S(Fr(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const r=k(e,"x","tf.grad","string_or_numeric"),s=n!=null?k(n,"dy","tf.grad"):null;return R.tidy(()=>{const{value:o,grads:a}=R.gradients(()=>t(r),[r],s);return s!=null&&ct(o.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Xd(a),a[0]})}}function oR(t){return S(Fr(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{S(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=al(e,"args","tf.grads","string_or_numeric"),s=n!=null?k(n,"dy","tf.grads"):null;return R.tidy(()=>{const{value:o,grads:a}=R.gradients(()=>t(...r),r,s);return s!=null&&ct(o.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Xd(a),a})}}function aR(t){return S(Fr(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{S(e instanceof qe,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),S(n==null||n instanceof qe,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=R.gradients(()=>t(e),[e],n);return Xd(r),{grad:r[0],value:s}}}function iR(t){return S(Fr(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{S(Array.isArray(e)&&e.every(s=>s instanceof qe),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),S(n==null||n instanceof qe,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=R.gradients(()=>t(...e),e,n);return n!=null&&ct(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Xd(r.grads),r}}function uw(t,e){S(Fr(t),()=>"The f passed in variableGrads(f) must be a function"),S(e==null||Array.isArray(e)&&e.every(c=>c instanceof ol),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const c in R.registeredVariables)e.push(R.registeredVariables[c])}const r=n?e.filter(c=>!c.trainable):null,s=e.length;e=e.filter(c=>c.trainable),S(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const o=!0,{value:a,grads:i}=R.gradients(t,e,null,o);S(i.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((c,u)=>{i[u]!=null&&(l[c.name]=i[u])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:a,grads:l}}function Mn(t){return R.customGrad(t)}function Xd(t){if(t.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lR(t){const n={x:k(t,"x","neg")};return R.runKernel(Hu,n)}const Wr=N({neg_:lR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(t){const n={x:k(t,"x","softplus")};return R.runKernel(Ui,n)}const dw=N({softplus_:cR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(t){const e=k(t,"x","logSigmoid");return Mn(r=>({value:Wr(dw(Wr(r))),gradFunc:a=>Z(a,Fo(Wr(r)))}))(e)}const dR=N({logSigmoid_:uR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fR(t,e=null,n=!1){const s={x:k(t,"x","max")},o={reductionIndices:e,keepDims:n};return R.runKernel(Mu,s,o)}const Po=N({max_:fR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pR(t,e){let n=k(t,"a","sub"),r=k(e,"b","sub");[n,r]=We(n,r);const s={a:n,b:r};return R.runKernel(ji,s)}const fe=N({sub_:pR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hR(t,e=null,n=!1){let r=k(t,"x","sum");r.dtype==="bool"&&(r=Ue(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return R.runKernel(ud,s,o)}const _e=N({sum_:hR});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mR(t,e=-1){const n=k(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Mn((s,o)=>{const a=!0,i=Po(s,e,!0),l=fe(s,i),c=fe(Ue(l,"float32"),dl(_e(Ss(l),e,a)));return o([c]),{value:c,gradFunc:(d,f)=>{const[p]=f,h=!0,g=Ss(p);return fe(d,Z(_e(d,e,h),g))}}})(n)}const gR=N({logSoftmax_:mR});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gg(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function fw(t,e,n){const r=t.length+e.length,s=[];let o=0,a=0;for(let i=0;i<r;i++)n.indexOf(i)===-1?s.push(t[o++]):s.push(e[a++]);return s}function dt(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&n.push(t[o]);const s=e.map(o=>t[o]);return[n,s]}function tt(t,e){const n=e.map(r=>1);return fw(t,n,e)}function ft(t,e,n){S(gg(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function Ye(t,e){if(gg(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function Yd(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function Qe(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xR(t,e=null,n=!1){const r=k(t,"x","logSumExp"),s=ge(e,r.shape),o=Po(r,s,!0),a=fe(r,o),i=Ss(a),l=_e(i,s),c=dl(l),u=le(H(o,c.shape),c);if(n){const d=tt(u.shape,s);return H(u,d)}return u}const pw=N({logSumExp_:xR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yR(t,e){const n=k(t,"a","logicalAnd","bool"),r=k(e,"b","logicalAnd","bool");ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(ki,s)}const Qd=N({logicalAnd_:yR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vR(t){const n={x:k(t,"x","logicalNot","bool")};return R.runKernel(Si,n)}const hw=N({logicalNot_:vR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wR(t,e){const n=k(t,"a","logicalOr","bool"),r=k(e,"b","logicalOr","bool");ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(Ii,s)}const mw=N({logicalOr_:wR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $R(t,e){const n=k(t,"a","logicalXor","bool"),r=k(e,"b","logicalXor","bool");return ye(n.shape,r.shape),Qd(mw(t,e),hw(Qd(t,e)))}const bR=N({logicalXor_:$R});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CR(t,e,n,r,s){const o=k(t,"x","maxPool"),a=1;let i=o,l=!1;o.rank===3&&(l=!0,i=H(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),S(vt(n,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),s!=null&&S(kt(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:s},d=R.runKernel(Lu,c,u);return l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const gw=N({maxPool_:CR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kR(t,e=[1,1,1],n,r,s,o="NDHWC"){const a=k(t,"x","maxPool3d");let i=a,l=!1;a.rank===4&&(l=!0,i=H(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),S(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&S(kt(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},d=R.runKernel(Bu,c,u);return l?H(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const SR=N({maxPool3d_:kR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IR(t,e,n,r,s=!1){const a={x:k(t,"x","maxPoolWithArgmax")},i={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},l=R.runKernel(Vu,a,i);return{result:l[0],indexes:l[1]}}const ER=N({maxPoolWithArgmax_:IR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TR(t,e){let n=k(t,"a","maximum"),r=k(e,"b","maximum");[n,r]=We(n,r),n.dtype==="bool"&&(n=Ue(n,"int32"),r=Ue(r,"int32")),ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(Ei,s)}const xw=N({maximum_:TR});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NR(t,e=null,n=!1){const s={x:k(t,"x","mean")},o={axis:e,keepDims:n};return R.runKernel(Wu,s,o)}const Zd=N({mean_:NR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Es(t,e="float32"){if(e==="complex64"){const r=Es(t,"float32"),s=Es(t,"float32");return xs(r,s)}const n=ut(L(t),e);return R.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ts(t,e="float32"){if(e==="complex64"){const r=Ts(t,"float32"),s=Es(t,"float32");return xs(r,s)}const n=nm(L(t),e);return R.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=k(t,"x","meshgrid",t instanceof qe?t.dtype:"float32");if(e===void 0)return[r];let s=k(e,"y","meshgrid",e instanceof qe?e.dtype:"float32");const o=L(r.shape),a=L(s.shape);return n==="xy"?(r=H(r,[1,-1]),s=H(s,[-1,1]),[$e(Ts([a,1],r.dtype),r),$e(s,Ts([1,o],s.dtype))]):(r=H(r,[-1,1]),s=H(s,[1,-1]),[$e(r,Ts([1,a],r.dtype)),$e(Ts([o,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DR(t,e=null,n=!1){const s={x:k(t,"x","min")},o={axis:e,keepDims:n};return R.runKernel(zu,s,o)}const xg=N({min_:DR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FR(t,e){let n=k(t,"a","minimum"),r=k(e,"b","minimum");[n,r]=We(n,r),n.dtype==="bool"&&(n=Ue(n,"int32"),r=Ue(r,"int32")),ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(Ti,s)}const yw=N({minimum_:FR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AR(t,e,n){S(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=k(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let i=0;i<r.rank;i++)S(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),S(e[i][0]>=0&&e[i][0]<=r.shape[i]-s&&e[i][1]>=0&&e[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:n},a={x:r};return R.runKernel(Uu,a,o)}const _R=N({mirrorPad_:AR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PR(t,e){let n=k(t,"a","mod"),r=k(e,"b","mod");[n,r]=We(n,r);const s={a:n,b:r};return R.runKernel(Ni,s)}const OR=N({mod_:PR});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(t){const e=k(t,"x","square"),n={};return R.runKernel("Square",{x:e},n)}const Cn=N({square_:MR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LR(t,e=null,n=!1){t=k(t,"x","moments");const r=ge(e,t.shape),s=Zd(t,r,n);let o=s.shape;n||(o=tt(s.shape,r));const a=Cn(fe(Ue(t,"float32"),H(s,o))),i=Zd(a,r,n);return{mean:s,variance:i}}const BR=N({moments_:LR});function VR(t,e,n,r){const s=k(e,"data","multiRNNCell"),o=al(n,"c","multiRNNCell"),a=al(r,"h","multiRNNCell");let i=s;const l=[];for(let d=0;d<t.length;d++){const f=t[d](i,o[d],a[d]);l.push(f[0]),l.push(f[1]),i=f[1]}const c=[],u=[];for(let d=0;d<l.length;d+=2)c.push(l[d]),u.push(l[d+1]);return[c,u]}const WR=N({multiRNNCell_:VR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zR(t,e,n,r=!1){const s=k(t,"logits","multinomial"),o=s.size,a=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();const l={logits:a===1?H(s,[1,-1]):s},c={numSamples:e,seed:n,normalized:r},u=R.runKernel(Gu,l,c);return a===1?H(u,[u.size]):u}const UR=N({multinomial_:zR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GR(t,e){let n=k(t,"a","notEqual","string_or_numeric"),r=k(e,"b","notEqual","string_or_numeric");[n,r]=We(n,r),ye(n.shape,r.shape);const s={a:n,b:r};return R.runKernel(Di,s)}const vw=N({notEqual_:GR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HR(t){const n={x:k(t,"x","onesLike")};return R.runKernel(Xu,n)}const jR=N({onesLike_:HR});function KR(t,e){const n=k(t,"v1","outerProduct"),r=k(e,"v2","outerProduct");S(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=H(n,[-1,1]),o=H(r,[1,-1]);return $e(s,o)}const qR=N({outerProduct_:KR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XR(t,e,n=0){const r=k(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},o={x:r};return R.runKernel(Zu,o,s)}const fl=N({pad_:XR});function YR(t,e,n=0){return S(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),fl(t,[e],n)}const QR=N({pad1d_:YR});function ZR(t,e,n=0){return S(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),fl(t,e,n)}const JR=N({pad2d_:ZR});function eD(t,e,n=0){return S(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),fl(t,e,n)}const tD=N({pad3d_:eD});function nD(t,e,n=0){return S(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),fl(t,e,n)}const rD=N({pad4d_:nD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sD(t,e,n){const r=k(t,"x","spaceToBatchND");S(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),S(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),S(r.shape.reduce((a,i,l)=>l>0&&l<=e.length?a&&(i+n[l-1][0]+n[l-1][1])%e[l-1]==0:a,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:n};return R.runKernel(dd,s,o)}const ww=N({spaceToBatchND_:sD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(t,e,n,r,s,o){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");const a=k(t,"x","maxPool");let i=a,l=!1;a.rank===3&&(l=!0,i=H(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(vt(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const c=hn(i.shape,e,o,s,r),u=[c.dilationHeight,c.dilationWidth];let d;r==="same"?d=iD([c.filterHeight,c.filterWidth],u):d=[[0,0],[0,0]];const f=u[0]===1&&u[1]===1,[p,h]=aD([c.inHeight,c.inWidth],u,d),g=f?r:"valid",m=f?i:ww(i,u,p),y=(n==="avg"?()=>Qv(m,e,o,g):()=>gw(m,e,o,g))(),w=f?y:Zv(y,u,h);return l?H(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function aD(t,e,n){const r=n.map(u=>u[0]),s=n.map(u=>u[1]),o=t.concat(r,s),a=e.map((u,d)=>(u-o[d]%u)%u),i=s.map((u,d)=>u+a[d]),l=e.map((u,d)=>[r[d],i[d]]),c=e.map((u,d)=>[0,a[d]]);return[l,c]}function iD(t,e){const r=t.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),s=r.map(a=>Math.floor(a/2)),o=r.map((a,i)=>a-s[i]);return r.map((a,i)=>[s[i],o[i]])}const lD=N({pool_:oD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cD(t,e){let n=k(t,"base","pow"),r=k(e,"exp","pow");[n,r]=We(n,r);const s={a:n,b:r};return R.runKernel(Fi,s)}const pl=N({pow_:cD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(t,e){const n=k(t,"x","prelu"),r=k(e,"alpha","prelu"),s={x:n,alpha:r};return R.runKernel(Ju,s)}const $w=N({prelu_:uD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(t,e=null,n=!1){let r=k(t,"x","prod");r.dtype==="bool"&&(r=Ue(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return R.runKernel(ed,s,o)}const fD=N({prod_:dD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pD(t,e,n){const r=L(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<r;o++)s[o]=e();return R.makeTensor(s,t,n)}const hD=N({rand_:pD});var bw={exports:{}};(function(t){(function(e,n,r){function s(l){var c=this,u=i();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function o(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function a(l,c){var u=new s(l),d=c&&c.state,f=u.next;return f.int32=function(){return u.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,d&&(typeof d=="object"&&o(d,u),f.state=function(){return o(u,{})}),f}function i(){var l=4022871197,c=function(u){u=u.toString();for(var d=0;d<u.length;d++){l+=u.charCodeAt(d);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.alea=a})(tn,t,!1)})(bw);var Cw={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},i===(i|0)?l.x=i:c+=i;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l}function a(i,l){var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.xor128=a})(tn,t,!1)})(Cw);var kw={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,i===(i|0)?l.x=i:c+=i;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l.v=i.v,l.d=i.d,l}function a(i,l){var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.xorwow=a})(tn,t,!1)})(kw);var Sw={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this;l.next=function(){var u=l.x,d=l.i,f,p;return f=u[d],f^=f>>>7,p=f^f<<24,f=u[d+1&7],p^=f^f>>>10,f=u[d+3&7],p^=f^f>>>3,f=u[d+4&7],p^=f^f<<7,f=u[d+7&7],f=f^f<<13,p^=f^f<<9,u[d]=p,l.i=d+1&7,p};function c(u,d){var f,p=[];if(d===(d|0))p[0]=d;else for(d=""+d,f=0;f<d.length;++f)p[f&7]=p[f&7]<<15^d.charCodeAt(f)+p[f+1&7]<<13;for(;p.length<8;)p.push(0);for(f=0;f<8&&p[f]===0;++f);for(f==8&&(p[7]=-1),u.x=p,u.i=0,f=256;f>0;--f)u.next()}c(l,i)}function o(i,l){return l.x=i.x.slice(),l.i=i.i,l}function a(i,l){i==null&&(i=+new Date);var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(u.x&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.xorshift7=a})(tn,t,!1)})(Sw);var Iw={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this;l.next=function(){var u=l.w,d=l.X,f=l.i,p,h;return l.w=u=u+1640531527|0,h=d[f+34&127],p=d[f=f+1&127],h^=h<<13,p^=p<<17,h^=h>>>15,p^=p>>>12,h=d[f]=h^p,l.i=f,h+(u^u>>>16)|0};function c(u,d){var f,p,h,g,m,x=[],y=128;for(d===(d|0)?(p=d,d=null):(d=d+"\0",p=0,y=Math.max(y,d.length)),h=0,g=-32;g<y;++g)d&&(p^=d.charCodeAt((g+32)%d.length)),g===0&&(m=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,g>=0&&(m=m+1640531527|0,f=x[g&127]^=p+m,h=f==0?h+1:0);for(h>=128&&(x[(d&&d.length||0)&127]=-1),h=127,g=4*128;g>0;--g)p=x[h+34&127],f=x[h=h+1&127],p^=p<<13,f^=f<<17,p^=p>>>15,f^=f>>>12,x[h]=p^f;u.w=m,u.X=x,u.i=h}c(l,i)}function o(i,l){return l.i=i.i,l.w=i.w,l.X=i.X.slice(),l}function a(i,l){i==null&&(i=+new Date);var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(u.X&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.xor4096=a})(tn,t,!1)})(Iw);var Ew={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this,c="";l.next=function(){var d=l.b,f=l.c,p=l.d,h=l.a;return d=d<<25^d>>>7^f,f=f-p|0,p=p<<24^p>>>8^h,h=h-d|0,l.b=d=d<<20^d>>>12^f,l.c=f=f-p|0,l.d=p<<16^f>>>16^h,l.a=h-d|0},l.a=0,l.b=0,l.c=2654435769|0,l.d=1367130551,i===Math.floor(i)?(l.a=i/4294967296|0,l.b=i|0):c+=i;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function o(i,l){return l.a=i.a,l.b=i.b,l.c=i.c,l.d=i.d,l}function a(i,l){var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.tychei=a})(tn,t,!1)})(Ew);var Tw={exports:{}};(function(t){(function(e,n){var r=this,s=256,o=6,a=52,i="random",l=n.pow(s,o),c=n.pow(2,a),u=c*2,d=s-1,f;function p(v,$,b){var C=[];$=$==!0?{entropy:!0}:$||{};var I=x(m($.entropy?[v,w(e)]:v==null?y():v,3),C),E=new h(C),T=function(){for(var D=E.g(o),F=l,A=0;D<c;)D=(D+A)*s,F*=s,A=E.g(1);for(;D>=u;)D/=2,F/=2,A>>>=1;return(D+A)/F};return T.int32=function(){return E.g(4)|0},T.quick=function(){return E.g(4)/4294967296},T.double=T,x(w(E.S),e),($.pass||b||function(D,F,A,P){return P&&(P.S&&g(P,E),D.state=function(){return g(E,{})}),A?(n[i]=D,F):D})(T,I,"global"in $?$.global:this==n,$.state)}n["seed"+i]=p;function h(v){var $,b=v.length,C=this,I=0,E=C.i=C.j=0,T=C.S=[];for(b||(v=[b++]);I<s;)T[I]=I++;for(I=0;I<s;I++)T[I]=T[E=d&E+v[I%b]+($=T[I])],T[E]=$;(C.g=function(D){for(var F,A=0,P=C.i,M=C.j,O=C.S;D--;)F=O[P=d&P+1],A=A*s+O[d&(O[P]=O[M=d&M+F])+(O[M]=F)];return C.i=P,C.j=M,A})(s)}function g(v,$){return $.i=v.i,$.j=v.j,$.S=v.S.slice(),$}function m(v,$){var b=[],C=typeof v,I;if($&&C=="object")for(I in v)try{b.push(m(v[I],$-1))}catch{}return b.length?b:C=="string"?v:v+"\0"}function x(v,$){for(var b=v+"",C,I=0;I<b.length;)$[d&I]=d&(C^=$[d&I]*19)+b.charCodeAt(I++);return w($)}function y(){try{var v;return f&&(v=f.randomBytes)?v=v(s):(v=new Uint8Array(s),(r.crypto||r.msCrypto).getRandomValues(v)),w(v)}catch{var $=r.navigator,b=$&&$.plugins;return[+new Date,r,b,r.screen,w(e)]}}function w(v){return String.fromCharCode.apply(0,v)}if(x(n.random(),e),t.exports){t.exports=p;try{f=require("crypto")}catch{}}})([],Math)})(Tw);var mD=bw.exports,gD=Cw.exports,xD=kw.exports,yD=Sw.exports,vD=Iw.exports,wD=Ew.exports,Ns=Tw.exports;Ns.alea=mD;Ns.xor128=gD;Ns.xorwow=xD;Ns.xorshift7=yD;Ns.xor4096=vD;Ns.tychei=wD;var yg=Ns;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vg{constructor(e,n,r,s,o){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=o||Math.random();this.random=yg.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,o,a;do s=2*this.random()-1,o=2*this.random()-1,a=s*s+o*o;while(a>=1||a===0);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*s*i,n=this.mean+this.stdDev*o*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class $D{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const o=s||Math.random();this.randu=yg.alea(o.toString()),this.randn=new vg(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,o,a;for(;;){do s=this.randn.nextValue(),a=1+this.c*s;while(a<=0);if(a*=a*a,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-a+Math.log(a)),o=this.randu(),o<n||Math.log(o)<r)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class bD{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=yg.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CD(t,e,n=1,r="float32",s){if(n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const o=new $D(e,n,r,s),a=de(t,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const kD=N({randomGamma_:CD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SD(t,e=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const o=new vg(e,n,r,!1,s),a=de(t,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const ID=N({randomNormal_:SD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ED(t,e=0,n=1,r="float32",s){const o=de(t,r),a=new bD(e,n,null,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Nw=N({randomUniform_:ED});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hl(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return R.runKernel(td,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TD(t){const n={input:k(t,"input","real")};return R.runKernel(nd,n)}const Jd=N({real_:TD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(t){const n={x:k(t,"x","reciprocal")};return R.runKernel(Ai,n)}const RD=N({reciprocal_:ND});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DD(t){const n={x:k(t,"x","relu")};return R.runKernel(_i,n)}const ef=N({relu_:DD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FD(t){const n={x:k(t,"x","relu6")};return R.runKernel(Pi,n)}const Rw=N({relu6_:FD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(t,e){const r={x:k(t,"x","reverse")},s={dims:e};return R.runKernel(ad,r,s)}const Rs=N({reverse_:AD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(t){const e=k(t,"x","reverse");return S(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Rs(e,0)}const PD=N({reverse1d_:_D});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(t,e){const n=k(t,"x","reverse");return S(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Rs(n,e)}const MD=N({reverse2d_:OD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LD(t,e){const n=k(t,"x","reverse");return S(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Rs(n,e)}const BD=N({reverse3d_:LD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VD(t,e){const n=k(t,"x","reverse");return S(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Rs(n,e)}const WD=N({reverse4d_:VD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zD(t){const n={x:k(t,"x","round")};return R.runKernel(Oi,n)}const Dw=N({round_:zD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UD(t){const n={x:k(t,"x","rsqrt","float32")};return R.runKernel(Mi,n)}const GD=N({rsqrt_:UD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ve(t,e){if((yt(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&yt(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Pr(t,[],[],e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HD(t){const n={x:k(t,"x","selu")};return R.runKernel(Li,n)}const jD=N({selu_:HD});function KD(t,e,n,r,s,o=[1,1],a="NHWC"){const i=k(t,"x","separableConv2d"),l=k(e,"depthwiseFilter","separableConv2d"),c=k(n,"pointwiseFilter","separableConv2d");let u=i,d=!1;if(i.rank===3&&(d=!0,u=H(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),S(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),S(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=l.shape[2],p=l.shape[3];S(c.shape[2]===f*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*p}, but got ${c.shape[2]}.`);const h=pg(u,l,r,s,a,o),m=jd(h,c,1,"valid",a);return d?H(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const qD=N({separableConv2d_:KD});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function XD(t,e){const n=k(t,"x","setdiff1d"),r=k(e,"y","setdiff1d");S(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),S(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),S(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),o=await r.data(),a=new Set(o);let i=0;for(let u=0;u<s.length;u++)a.has(s[u])||i++;const l=new et([i],n.dtype),c=new et([i],"int32");for(let u=0,d=0;u<s.length;u++)a.has(s[u])||(l.values[d]=s[u],c.values[d]=u,d++);return[l.toTensor(),c.toTensor()]}const YD=XD;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QD(t){const n={x:k(t,"x","sign")};return R.runKernel(Wi,n)}const ZD=N({sign_:QD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JD(t){const n={x:k(t,"x","sin","float32")};return R.runKernel(Bi,n)}const eF=N({sin_:JD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tF(t){const n={x:k(t,"x","sinh")};return R.runKernel(Vi,n)}const nF=N({sinh_:tF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(t,e,n){const r=k(t,"x","slice1d");return S(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Me(r,[e],[n])}const sF=N({slice1d_:rF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oF(t,e,n){const r=k(t,"x","slice2d");return S(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Me(r,e,n)}const aF=N({slice2d_:oF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iF(t,e,n){const r=k(t,"x","slice3d");return S(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Me(r,e,n)}const lF=N({slice3d_:iF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cF(t,e,n){const r=k(t,"x","slice4d");return S(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Me(r,e,n)}const uF=N({slice4d_:cF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dF(t,e=-1){const n=k(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return R.runKernel(pd,r,s)}const fF=N({softmax_:dF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(t){S(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return R.runKernel(Iu,e)}const wg=N({fft_:pF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(t){S(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return R.runKernel(Fu,e)}const tf=N({ifft_:hF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=H(t,[n,e]);r=tf(s)}else{const s=[n,2*(e-1)],o=H(Jd(t),[n,e]),a=H(hg(t),[n,e]),i=Rs(Me(o,[0,1],[n,e-2]),1),l=Z(Rs(Me(a,[0,1],[n,e-2]),1),ve(-1)),c=Gt([o,i],1),u=Gt([a,l],1),d=H(xs(c,u),[s[0],s[1]]);r=tf(d)}if(r=Jd(r),t.rank===3&&t.shape[0]!==0){const s=r,o=t.shape[0];r=H(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const Fw=N({irfft_:mF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(t,e,n=0){const s={x:k(t,"x","split")},o={numOrSizeSplits:e,axis:n};return R.runKernel(fd,s,o)}const ml=N({split_:gF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(t,e){S(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const h=t.shape.map(m=>0),g=t.shape.map(m=>m);g[t.shape.length-1]=e,s=Me(t,h,g),n=e}else if(e!=null&&e>n){const h=t.shape.map(g=>g);h[t.shape.length-1]=e-n,s=Gt([t,Es(h)],t.shape.length-1),n=e}else s=t;const o=Qt(s),a=H(xs(s,o),[r,n]),i=wg(a),l=Math.floor(n/2)+1,c=Jd(i),u=hg(i),d=ml(c,[l,n-l],c.shape.length-1),f=ml(u,[l,n-l],u.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,H(xs(d[0],f[0]),p)}const $g=N({rfft_:xF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(t){const n={x:k(t,"x","sqrt","float32")};return R.runKernel(Gi,n)}const sr=N({sqrt_:yF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vF(t,e){let n=k(t,"a","squaredDifference"),r=k(e,"b","squaredDifference");[n,r]=We(n,r),ye(n.shape,r.shape);const s={a:n,b:r},o={};return R.runKernel(Hi,s,o)}const Aw=N({squaredDifference_:vF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wF(t,e){const n=k(t,"x","squeeze");return H(n,Jn(n.shape,e).newShape)}const bg=N({squeeze_:wF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $F(t,e=0){const n=al(t,"tensors","stack","string_or_numeric");S(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&S(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return R.runKernel(Qu,r,s)}const gl=N({stack_:$F});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(t,e=0){const r={x:k(t,"x","step")},s={alpha:e};return R.runKernel(Yi,r,s)}const _w=N({step_:bF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CF(t,e,n,r,s=0,o=0,a=0,i=0,l=0){const u={x:k(t,"x","stridedSlice","string_or_numeric")},d={begin:e,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};return R.runKernel(vd,u,d)}const kF=N({stridedSlice_:CF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(t){const n={x:k(t,"x","tan","float32")};return R.runKernel(Ki,n)}const IF=N({tan_:SF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kn(t,e){us(t);const n=On(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Pr(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xl(t,e,n){if(us(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=On(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Pr(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EF(t,e,n){if(us(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=On(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Pr(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TF(t,e,n){if(us(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=On(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Pr(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NF(t,e,n){if(us(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=On(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Pr(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(t,e=1,n=!0){const r=k(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},a={k:e,sorted:n},[i,l]=R.runKernel(Cd,o,a);return{values:i,indices:l}}const DF=N({topk_:RF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(t,e=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new vg(e,n,r,!0,s),a=de(t,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const AF=N({truncatedNormal_:FF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _F(t,e=0){const n=k(t,"x","unique","string_or_numeric");S(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[o,a]=R.runKernel(Id,r,s);return{values:o,indices:a}}const PF=N({unique_:_F});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(t,e,n){const r=k(t,"x","unsortedSegmentSum"),s=k(e,"segmentIds","unsortedSegmentSum","int32");S(kt(n),()=>"numSegments must be of dtype int");const o={x:r,segmentIds:s},a={numSegments:n};return R.runKernel(Td,o,a)}const MF=N({unsortedSegmentSum_:OF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LF(t,e=0){const n=k(t,"x","unstack","string_or_numeric");S(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return R.runKernel(Ed,r,s)}const Cg=N({unstack_:LF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BF(t,e=!0,n,r){return R.makeVariable(t,e,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nf(t,e){const n=[];for(let o=0;o<e.length;o++)e[o]&&n.push(o);const r=de(t,"int32"),s=de([n.length,t.length],"int32");for(let o=0;o<n.length;o++){const a=r.indexToLoc(n[o]),i=o*t.length;s.values.set(a,i)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function VF(t){const e=k(t,"condition","whereAsync","bool"),n=await e.data(),r=nf(e.shape,n);return t!==e&&e.dispose(),r}const Pw=VF;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function WF(t,e,n){const r=k(t,"tensor","boolMask"),s=k(e,"mask","boolMask","bool"),o=n==null?0:n,a=s.rank,i=r.shape;S(a>0,()=>"mask cannot be scalar"),ct(i.slice(o,o+a),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=o;g<o+a;g++)l*=i[g];const c=i.slice(0,o).concat([l],i.slice(o+a)),u=H(r,c),d=H(s,[-1]),f=await Pw(d),p=bg(f,[1]),h=aw(u,p,o);return t!==r&&r.dispose(),e!==s&&s.dispose(),p.dispose(),u.dispose(),d.dispose(),f.dispose(),h}const zF=WF;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(t,e="euclidean",n=null,r=!1){t=k(t,"x","norm");const s=Ow(t,e,n);let o=s.shape;if(r){const a=ge(n,t.shape);o=tt(s.shape,a)}return H(s,o)}function Ow(t,e,n=null){if(t.rank===0)return Yt(t);if(t.rank!==1&&n===null)return Ow(H(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return _e(Yt(t),n);if(e===1/0)return Po(Yt(t),n);if(e===-1/0)return xg(Yt(t),n);if(e==="euclidean"||e===2)return sr(_e(pl(Yt(t),ve(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return Po(_e(Yt(t),n[0]),n[1]-1);if(e===1/0)return Po(_e(Yt(t),n[1]),n[0]);if(e===-1/0)return xg(_e(Yt(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return sr(_e(Cn(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const kg=N({norm_:UF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(t,e,n,r,s=!0){const o=k(t,"v","movingAverage"),a=k(e,"x","movingAverage"),i=k(n,"decay","movingAverage");uv(o,a),S(Ie(o.shape,a.shape),()=>"Shape mismatch in v and x");const l=ve(1),c=fe(l,i);let u=Z(fe(a,o),c);if(s){S(r!=null,()=>"When using zeroDebias: true, step is required.");const d=k(r,"step","movingAverage");u=Ae(u,fe(l,pl(i,d)))}return le(o,u)}const HF=N({movingAverage_:GF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jF(t,e,n){const r=k(t,"indices","scatterND","int32"),s=k(e,"updates","scatterND");Zm(s,r,n);const o={indices:r,updates:s},a={shape:n};return R.runKernel(id,o,a)}const KF=N({scatterND_:jF});function qF(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(t,e,n,r=0){const s=k(t,"sparseIndices","sparseToDense","int32"),o=k(e,"sparseValues","sparseToDense"),a=k(r,"defaultValue","sparseToDense",o.dtype);qF(s,o,n,a);const i={sparseIndices:s,sparseValues:o,defaultValue:a},l={outputShape:n};return R.runKernel(yd,i,l)}const YF=N({sparseToDense_:XF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QF(t,e){const n=k(e,"indices","gatherND","int32"),s={params:k(t,"x","gatherND","string_or_numeric"),indices:n};return R.runKernel(Du,s)}const ZF=N({gatherND_:QF});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(t,e){if(e==null)return t.shape.slice();if(Ie(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eA(t,e,n,r){const s=k(t,"x","dropout");if(S(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof qe?s.clone():s;const o=JF(s,n),a=1-e,i=Ae(ow(le(Nw(o,0,1,"float32",r),a)),a);return Z(s,i)}const tA=N({dropout_:eA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mw(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Sg(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const a=2*Math.PI*o/(t+r-1);s[o]=e-n*Math.cos(a)}return kn(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nA(t,e,n=1){const r=k(t,"predictions","inTopK"),s=k(e,"targets","inTopK");S(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),S(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),ct(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];S(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const a=await r.data(),i=await s.data(),[l,c]=[a.length/o,o],u=Je("bool",l);for(let d=0;d<l;d++){const f=d*c,p=a.subarray(f,f+c),h=[];for(let g=0;g<p.length;g++)h.push({value:p[g],index:g});h.sort((g,m)=>m.value-g.value),u[d]=0;for(let g=0;g<n;g++)if(h[g].index===i[d]){u[d]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),Eo(u,s.shape,"bool")}const rA=nA;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sA(t,e,n,r,s,o="NHWC",a){let i=t;t.rank===3&&(i=H(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=H(e,[1,e.shape[0],e.shape[1],e.shape[2]])),S(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),S(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=o==="NHWC"?i.shape[3]:i.shape[1],u=o==="NHWC"?l.shape[3]:l.shape[1];S(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),S(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),a!=null&&S(kt(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const d={x:i,dy:l},f={strides:r,pad:s,dataFormat:o,dimRoundingMode:a,filterShape:n};return R.runKernel(du,d,f)}const oA=N({conv2DBackpropFilter_:sA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rf(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return Z(t,_w(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function sf(t,e){let n=e;const r=tw(t.shape,e.shape);return r.length>0&&(n=_e(n,r)),H(n,t.shape)}function of(t,e,n,r){if(e==="linear")return t;if(e==="relu")return ef(t);if(e==="elu")return rw(t);if(e==="relu6")return Rw(t);if(e==="prelu")return $w(t,n);if(e==="leakyrelu")return lw(t,r);if(e==="sigmoid")return Fo(t);throw new Error(`Unknown fused activation ${e}.`)}const af=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aA({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",af(R.state.gradientDepth,l)===!1){let $=jd(t,e,n,r,s,o,a);return i!=null&&($=le($,i)),of($,l,c,u)}const d=k(t,"x","conv2d","float32"),f=k(e,"filter","conv2d","float32");let p=d,h=!1;d.rank===3&&(h=!0,p=H(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),S(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),a!=null&&S(kt(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),S(p.shape[3]===f.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${f.shape[2]}.`),S(vt(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),S(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const g=st(p.shape,f.shape,n,o,r,a);let m;i!=null&&(m=k(i,"bias","fused conv2d"),[m]=We(m,d),ye(g.outShape,m.shape));let x;c!=null&&(x=k(c,"prelu weights","fused conv2d"));const y=($,b)=>{const[C,I,E,T]=b,D=rf($,E,l);S(cl(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const F=ew(I.shape,D,C,n,r),A=oA(I,D,C.shape,n,r),P=[F,A];if(T!=null){const M=sf(T,D);P.push(M)}return P},w={x:p,filter:f,bias:m,preluActivationWeights:x},v={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:u};return i==null?Mn((b,C,I)=>{let E=R.runKernel(Zi,w,v);return I([C,b,E]),h&&(E=H(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:y}})(p,f):Mn((b,C,I,E)=>{let T=R.runKernel(Zi,w,v);return E([C,b,T,I]),h&&(T=H(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:y}})(p,f,m)}const iA=N({fusedConv2d_:aA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lA(t,e,n,r,s,o=[1,1],a){let i=t;t.rank===3&&(i=H(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=H(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:l},u={strides:r,pad:s,dimRoundingMode:a,dilations:o,filterShape:n};return R.runKernel(wu,c,u)}const cA=N({depthwiseConv2dNativeBackpropFilter_:lA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uA(t,e,n,r,s,o=[1,1],a){let i=e,l=!1;e.rank===3&&(l=!0,i=H(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:n},u={strides:r,pad:s,dimRoundingMode:a,dilations:o,inputShape:t},d=R.runKernel($u,c,u);return l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const dA=N({depthwiseConv2dNativeBackpropInput_:uA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fA({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(af(R.state.gradientDepth,l)===!1){let $=pg(t,e,n,r,s,o,a);return i!=null&&($=le($,i)),of($,l,c,u)}const d=k(t,"x","depthwiseConv2d","float32"),f=k(e,"filter","depthwiseConv2d","float32");let p=d,h=!1;d.rank===3&&(h=!0,p=H(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),S(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),S(p.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),o==null&&(o=[1,1]),S(vt(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),a!=null&&S(kt(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`);const g=st(p.shape,f.shape,n,o,r,a,!0);let m;i!=null&&(m=k(i,"bias","fused conv2d"),[m]=We(m,d),ye(g.outShape,m.shape));let x;c!=null&&(x=k(c,"prelu weights","fused depthwiseConv2d"));const y=($,b)=>{S(cl(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[C,I,E,T]=b,D=rf($,E,l),F=dA(I.shape,D,C,n,r,o,a),A=cA(I,D,C.shape,n,r,o,a);if(T!=null){const P=sf(m,D);return[F,A,P]}return[F,A]},w={x:p,filter:f,bias:m,preluActivationWeights:x},v={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:u};return i==null?Mn((b,C,I)=>{let E=R.runKernel(Ji,w,v);return I([C,b,E]),h&&(E=H(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:y}})(p,f):Mn((b,C,I,E)=>{let T=R.runKernel(Ji,w,v);return E([C,b,T,I]),h&&(T=H(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:y}})(p,f,m)}const pA=N({fusedDepthwiseConv2d_:fA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i}){if(af(R.state.gradientDepth,o)===!1){let T=$e(t,e,n,r);return s!=null&&(T=le(T,s)),of(T,o,a,i)}let l=k(t,"a","fused matMul"),c=k(e,"b","fused matMul");[l,c]=We(l,c);const u=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?c.shape[c.rank-2]:c.shape[c.rank-1],h=l.shape.slice(0,-2),g=c.shape.slice(0,-2),m=L(h),x=L(g);S(l.rank>=2&&c.rank>=2&&l.rank===c.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${c.rank}.`),S(Ie(h,g),()=>`Error in fused matMul: outer dimensions (${h}) and (${g}) of Tensors with shapes ${l.shape} and ${c.shape} must match.`),S(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);const y=l.shape.slice(0,-2).concat([f,p]),w=n?H(l,[m,u,f]):H(l,[m,f,u]),v=r?H(c,[x,p,d]):H(c,[x,d,p]);let $;s!=null&&($=k(s,"bias","fused matMul"),[$]=We($,l),ye(y,$.shape));let b;a!=null&&(b=k(a,"prelu weights","fused matMul"));const C=(T,D)=>{const[F,A,P,M]=D,O=rf(H(T,P.shape),P,o);let U,B;if(!n&&!r?(U=$e(O,A,!1,!0),B=$e(F,O,!0,!1)):!n&&r?(U=$e(O,A,!1,!1),B=$e(O,F,!0,!1)):n&&!r?(U=$e(A,O,!1,!0),B=$e(F,O,!1,!1)):(U=$e(A,O,!0,!0),B=$e(O,F,!0,!0)),s!=null){const G=sf(M,O);return[U,B,G]}else return[U,B]},I={a:w,b:v,bias:$,preluActivationWeights:b},E={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:i};return s==null?Mn((D,F,A)=>{const P=R.runKernel(Qi,I,E);return A([D,F,P]),{value:H(P,y),gradFunc:C}})(w,v):Mn((D,F,A,P)=>{const M=R.runKernel(Qi,I,E);return P([D,F,M,A]),{value:H(M,y),gradFunc:C}})(w,v,$)}const mA=N({fusedMatMul_:hA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var gA=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",conv2d:iA,depthwiseConv2d:pA,matMul:mA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(t){return Sg(t,.54,.46)}const yA=N({hammingWindow_:xA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(t){return Sg(t,.5,.5)}const Lw=N({hannWindow_:vA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(t,e,n,r=!1,s=0){let o=0;const a=[];for(;o+e<=t.size;)a.push(Me(t,o,e)),o+=n;if(r)for(;o<t.size;){const i=o+e-t.size,l=Gt([Me(t,o,e-i),Kd([i],s)]);a.push(l),o+=n}return a.length===0?xl([],[0,e]):H(Gt(a),[a.length,e])}const Bw=N({frame_:wA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $A(t,e,n,r,s=Lw){r==null&&(r=Mw(e));const o=Bw(t,e,n),a=Z(o,s(e));return $g(a,r)}const bA=N({stft_:$A});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CA(t,e,n,r,s="bilinear",o=0){const a=k(t,"image","cropAndResize"),i=k(e,"boxes","cropAndResize","float32"),l=k(n,"boxInd","cropAndResize","int32"),c=i.shape[0];S(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),S(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`),S(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`),S(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const u={image:a,boxes:i,boxInd:l},d={method:s,extrapolationValue:o,cropSize:r};return R.runKernel(gu,u,d)}const kA=N({cropAndResize_:CA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SA(t){const e=k(t,"image","flipLeftRight","float32");S(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return R.runKernel(Tu,n,{})}const IA=N({flipLeftRight_:SA});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EA(t){const e=k(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];S(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),S(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,ul(e,s)}const TA=N({grayscaleToRGB_:EA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NA(t,e,n=0,r=.5){const s=k(t,"image","rotateWithOffset","float32");S(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},a={radians:e,fillValue:n,center:r};return R.runKernel(Dd,o,a)}const RA=N({rotateWithOffset_:NA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oo(t,e,n,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const a=t.shape[0];return n=Math.min(n,a),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),S(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),S(e.rank===1,()=>"scores must be a 1D tensor"),S(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),S(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=k(t,"boxes","nonMaxSuppression","float32"),a=k(e,"scores","nonMaxSuppression","float32"),i=Oo(o,a,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return R.runKernel(ju,{boxes:o,scores:a},l)}const FA=N({nonMaxSuppression_:DA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA(t,e,n){const r=_A(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function _A(t,e,n){return OA(t,e,n||PA)}function PA(t,e){return t>e?1:t<e?-1:0}function OA(t,e,n){let r=0,s=t.length,o=0,a=!1;for(;r<s;){o=r+(s-r>>>1);const i=n(e,t[o]);i>0?r=o+1:(s=o,a=!i)}return a?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lf(t,e,n,r,s){return Ig(t,e,n,r,s,0)}function cf(t,e,n,r,s,o){return Ig(t,e,n,r,s,0,!1,o,!0)}function uf(t,e,n,r,s,o){return Ig(t,e,n,r,s,o,!0)}function Ig(t,e,n,r,s,o,a=!1,i=!1,l=!1){const c=[];for(let m=0;m<e.length;m++)e[m]>s&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(Vw);const u=o>0?-.5/o:0,d=[],f=[];for(;d.length<n&&c.length>0;){const m=c.pop(),{score:x,boxIndex:y,suppressBeginIndex:w}=m;if(x<s)break;let v=!1;for(let $=d.length-1;$>=w;--$){const b=MA(t,y,d[$]);if(b>=r){v=!0;break}if(m.score=m.score*LA(r,u,b),m.score<=s)break}m.suppressBeginIndex=d.length,v||(m.score===x?(d.push(y),f.push(m.score)):m.score>s&&AA(c,m,Vw))}const p=d.length,h=n-p;i&&h>0&&(d.push(...new Array(h).fill(0)),f.push(...new Array(h).fill(0)));const g={selectedIndices:d};return a&&(g.selectedScores=f),l&&(g.validOutputs=p),g}function MA(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),o=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),f=Math.max(s[1],s[3]),p=(i-o)*(l-a),h=(d-c)*(f-u);if(p<=0||h<=0)return 0;const g=Math.max(o,c),m=Math.max(a,u),x=Math.min(i,d),y=Math.min(l,f),w=Math.max(x-g,0)*Math.max(y-m,0);return w/(p+h-w)}function LA(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function Vw(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function BA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=k(t,"boxes","nonMaxSuppressionAsync"),a=k(e,"scores","nonMaxSuppressionAsync"),i=Oo(o,a,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const l=await Promise.all([o.data(),a.data()]),c=l[0],u=l[1],{selectedIndices:d}=lf(c,u,n,r,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),kn(d,"int32")}const VA=BA;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const a=k(t,"boxes","nonMaxSuppression"),i=k(e,"scores","nonMaxSuppression"),l=Oo(a,i,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const c={boxes:a,scores:i},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},d=R.runKernel(qu,c,u);return{selectedIndices:d[0],selectedScores:d[1]}}const zA=N({nonMaxSuppressionWithScore_:WA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function UA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const a=k(t,"boxes","nonMaxSuppressionAsync"),i=k(e,"scores","nonMaxSuppressionAsync"),l=Oo(a,i,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const c=await Promise.all([a.data(),i.data()]),u=c[0],d=c[1],{selectedIndices:f,selectedScores:p}=uf(u,d,n,r,s,o);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:kn(f,"int32"),selectedScores:kn(p)}}const GA=UA;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const a=k(t,"boxes","nonMaxSuppression"),i=k(e,"scores","nonMaxSuppression"),l=Oo(a,i,n,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,f={boxes:a,scores:i},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:o},h=R.runKernel(Ku,f,p);return{selectedIndices:h[0],validOutputs:h[1]}}const jA=N({nonMaxSuppressionPadded_:HA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function KA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const a=k(t,"boxes","nonMaxSuppressionAsync"),i=k(e,"scores","nonMaxSuppressionAsync"),l=Oo(a,i,n,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,[f,p]=await Promise.all([a.data(),i.data()]),{selectedIndices:h,validOutputs:g}=cf(f,p,c,u,d,o);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:kn(h,"int32"),validOutputs:ve(g,"int32")}}const qA=KA;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XA(t,e,n=!1,r=!1){const s=k(t,"images","resizeBilinear");S(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),S(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=H(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:o},l={alignCorners:n,halfPixelCenters:r,size:e},c=R.runKernel(od,i,l);return a?H(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const YA=N({resizeBilinear_:XA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QA(t,e,n=!1,r=!1){const s=k(t,"images","resizeNearestNeighbor");S(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),S(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),S(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=H(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:o},l={alignCorners:n,halfPixelCenters:r,size:e},c=R.runKernel(sd,i,l);return a?H(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const ZA=N({resizeNearestNeighbor_:QA});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JA(t,e="binary",n=!1,r=.5){const s=k(t,"image","threshold"),o=.2989,a=.587,i=.114,l=s.shape[0]*s.shape[1];let c=Z(kn([r]),255),u,d,f,p;if(S(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),S(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),S(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),S(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[u,d,f]=ml(s,[1,1,1],-1);const m=Z(u,o),x=Z(d,a),y=Z(f,i);p=le(le(m,x),y)}else p=t;if(e==="otsu"){const m=Jv(Ue(Dw(p),"int32"),Eo([]),256);c=e_(m,l)}const h=n?mg(p,c):qd(p,c);return Ue(Z(h,255),"int32")}function e_(t,e){let n=kn([-1]),r=kn([0]),s=kn([0]),o,a,i,l,c,u;for(let d=0;d<t.size-1;d++){o=Me(t,0,d+1),a=Me(t,d+1),c=Ae(_e(o),e),u=Ae(_e(a),e);const f=_e(Z(o,hl(0,o.size)));i=Ae(f,_e(o));const p=Kd(a.shape,o.size),h=le(hl(0,a.size),p),g=Z(a,h);l=Ae(_e(g),_e(a));const m=fe(i,l),x=fe(i,l),y=Z(c,u);s=Z(Z(y,m),x);const w=qd(s,r);r=_o(w,s,r),n=_o(w,kn([d]),n)}return n}const t_=N({threshold_:JA});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n_(t,e,n="nearest",r="constant",s=0,o){const a=k(t,"image","transform","float32"),i=k(e,"transforms","transform","float32");S(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),S(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:a,transforms:i},c={interpolation:n,fillMode:r,fillValue:s,outputShape:o};return R.runKernel(kd,l,c)}const r_=N({transform_:n_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_(t,e,n){S(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),S(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=k(t,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,a]=r.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=o),n<0&&(n=a);const i=H(hl(0,o,1,"int32"),[-1,1]),l=hl(0,a,1,"int32"),c=fe(i,l),u=Qd(mg(c,ve(+e,"int32")),iw(c,ve(-n,"int32"))),d=Es([o,a],r.dtype);return H(gl(Cg(H(r,[-1,o,a])).map(f=>_o(u,f,d))),s)}const o_=N({bandPart_:s_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_(t){let e;if(Array.isArray(t)){e=!1,S(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)S(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else e=!0,t=ml(t,t.shape[0],0).map(s=>bg(s,[0]));S(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(R.tidy(()=>{let o=r[s];if(s>0)for(let a=0;a<s;++a){const i=Z(_e(Z(n[a],o)),n[a]);o=fe(o,i)}return Ae(o,kg(o,"euclidean"))}));return e?gl(n,0):n}const i_=N({gramSchmidt_:a_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_(t,e=!1){if(S(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return Ww(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,c)=>l*c),r=Cg(H(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];r.forEach(l=>{const[c,u]=Ww(l,e);s.push(c),o.push(u)});const a=H(gl(s,0),t.shape),i=H(gl(o,0),t.shape);return[a,i]}}function Ww(t,e=!1){return R.tidy(()=>{S(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=sw(n),o=$s(t);const a=xl([[1]],[1,1]);let i=$s(a);const l=n>=r?r:n;for(let c=0;c<l;++c){const u=o,d=i,f=s;[i,o,s]=R.tidy(()=>{const p=Me(o,[c,c],[n-c,1]),h=kg(p),g=Me(o,[c,c],[1,1]),m=_o(qd(g,0),xl([[-1]]),xl([[1]])),x=fe(g,Z(m,h)),y=Ae(p,x);y.shape[0]===1?i=$s(a):i=Gt([a,Me(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);const w=Wr(Ae($e(m,x),h)),v=Me(o,[c,0],[n-c,r]),$=Z(w,i),b=Wd(i);if(c===0)o=fe(v,$e($,$e(b,v)));else{const E=fe(v,$e($,$e(b,v)));o=Gt([Me(o,[0,0],[c,r]),E],0)}const C=Wd($),I=Me(s,[0,c],[n,s.shape[1]-c]);if(c===0)s=fe(I,$e($e(I,i),C));else{const E=fe(I,$e($e(I,i),C));s=Gt([Me(s,[0,0],[n,c]),E],1)}return[i,o,s]}),_t([u,d,f])}return!e&&n>r&&(s=Me(s,[0,0],[n,r]),o=Me(o,[0,0],[r,r])),[s,o]})}const c_=N({qr_:l_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Et;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Et||(Et={}));function u_(t,e,n=Et.SUM_BY_NONZERO_WEIGHTS){const r=k(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=k(e,"weights","computeWeightedLoss"));const o=s==null?r:Z(r,s);if(n===Et.NONE)return o;if(n===Et.SUM)return _e(o);if(n===Et.MEAN){if(s==null)return Zd(o);{const a=r.size/s.size,i=Ae(_e(o),_e(s));return a>1?Ae(i,ve(a)):i}}if(n===Et.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Ae(_e(o),ve(r.size));{const a=Z(s,Ts(r.shape)),i=Ue(_e(vw(a,ve(0))),"float32");return Ae(_e(o),i)}}throw Error(`Unknown reduction: ${n}`)}const or=N({computeWeightedLoss_:u_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d_(t,e,n,r=Et.SUM_BY_NONZERO_WEIGHTS){const s=k(t,"labels","absoluteDifference"),o=k(e,"predictions","absoluteDifference");let a=null;n!=null&&(a=k(n,"weights","absoluteDifference")),ct(s.shape,o.shape,"Error in absoluteDifference: ");const i=Yt(fe(s,o));return or(i,a,r)}const f_=N({absoluteDifference_:d_});function p_(t,e,n,r,s=Et.SUM_BY_NONZERO_WEIGHTS){const o=k(t,"labels","cosineDistance"),a=k(e,"predictions","cosineDistance");let i=null;r!=null&&(i=k(r,"weights","cosineDistance")),ct(o.shape,a.shape,"Error in cosineDistance: ");const l=ve(1),c=fe(l,_e(Z(o,a),n,!0));return or(c,i,s)}const h_=N({cosineDistance_:p_});function m_(t,e,n,r=Et.SUM_BY_NONZERO_WEIGHTS){let s=k(t,"labels","hingeLoss");const o=k(e,"predictions","hingeLoss");let a=null;n!=null&&(a=k(n,"weights","hingeLoss")),ct(s.shape,o.shape,"Error in hingeLoss: ");const i=ve(1);s=fe(Z(ve(2),s),i);const l=ef(fe(i,Z(s,o)));return or(l,a,r)}const g_=N({hingeLoss_:m_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x_(t,e,n,r=1,s=Et.SUM_BY_NONZERO_WEIGHTS){const o=k(t,"labels","huberLoss"),a=k(e,"predictions","huberLoss");let i=null;n!=null&&(i=k(n,"weights","huberLoss")),ct(o.shape,a.shape,"Error in huberLoss: ");const l=ve(r),c=Yt(fe(a,o)),u=yw(c,l),d=fe(c,u),f=le(Z(ve(.5),Cn(u)),Z(l,d));return or(f,i,s)}const y_=N({huberLoss_:x_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_(t,e,n,r=1e-7,s=Et.SUM_BY_NONZERO_WEIGHTS){const o=k(t,"labels","logLoss"),a=k(e,"predictions","logLoss");let i=null;n!=null&&(i=k(n,"weights","logLoss")),ct(o.shape,a.shape,"Error in logLoss: ");const l=ve(1),c=ve(r),u=Wr(Z(o,dl(le(a,c)))),d=Z(fe(l,o),dl(le(fe(l,a),c))),f=fe(u,d);return or(f,i,s)}const w_=N({logLoss_:v_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(t,e,n,r=Et.SUM_BY_NONZERO_WEIGHTS){const s=k(t,"labels","meanSquaredError"),o=k(e,"predictions","meanSquaredError");let a=null;n!=null&&(a=k(n,"weights","meanSquaredError")),ct(s.shape,o.shape,"Error in meanSquaredError: ");const i=Aw(s,o);return or(i,a,r)}const b_=N({meanSquaredError_:$_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_(t,e){const n=k(t,"labels","sigmoidCrossEntropyWithLogits"),r=k(e,"logits","sigmoidCrossEntropyWithLogits");ct(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=ef(r),o=Z(r,n),a=cw(Ss(Wr(Yt(r))));return le(fe(s,o),a)}function k_(t,e,n,r=0,s=Et.SUM_BY_NONZERO_WEIGHTS){let o=k(t,"multiClassLabels","sigmoidCrossEntropy");const a=k(e,"logits","sigmoidCrossEntropy");let i=null;if(n!=null&&(i=k(n,"weights","sigmoidCrossEntropy")),ct(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=ve(r),u=ve(1),d=ve(.5);o=le(Z(o,fe(u,c)),Z(d,c))}const l=C_(o,a);return or(l,i,s)}const S_=N({sigmoidCrossEntropy_:k_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Mn((s,o,a)=>{const l=pw(o,[n],!0),c=fe(Ue(o,"float32"),l);a([s,c]);const u=Wr(Z(c,s));return{value:_e(u,[n]),gradFunc:(p,h)=>{const[g,m]=h,x=tt(p.shape,[n]);return[Z(H(p,x),fe(Ue(g,"float32"),Ss(m))),Z(H(p,x),fe(Ss(m),Ue(g,"float32")))]}}})(t,e)}function E_(t,e,n,r=0,s=Et.SUM_BY_NONZERO_WEIGHTS){let o=k(t,"onehotLabels","softmaxCrossEntropy");const a=k(e,"logits","softmaxCrossEntropy");let i=null;if(n!=null&&(i=k(n,"weights","softmaxCrossEntropy")),ct(o.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){const c=ve(r),u=ve(1),d=ve(o.shape[1]);o=le(Z(o,fe(u,c)),Ae(c,d))}const l=I_(o,a);return or(l,i,s)}const T_=N({softmaxCrossEntropy_:E_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_(t,e,n,r){const s=k(t,"indices","sparseFillEmptyRows"),o=k(e,"values","sparseFillEmptyRows"),a=k(n,"denseShape","sparseFillEmptyRows"),i=k(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const l={indices:s,values:o,denseShape:a,defaultValue:i},c=R.runKernel(hd,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const R_=N({sparseFillEmptyRows_:N_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_(t,e,n){const r=k(t,"inputIndices","sparseReshape"),s=k(e,"inputShape","sparseReshape"),o=k(n,"newShape","sparseReshape");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a={inputIndices:r,inputShape:s,newShape:o},i=R.runKernel(md,a);return{outputIndices:i[0],outputShape:i[1]}}const F_=N({sparseReshape_:D_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(t,e,n){const r=k(t,"data","sparseSegmentMean"),s=k(e,"indices","sparseSegmentMean"),o=k(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const a={data:r,indices:s,segmentIds:o};return R.runKernel(gd,a)}const __=N({sparseSegmentMean_:A_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(t,e,n){const r=k(t,"data","sparseSegmentSum"),s=k(e,"indices","sparseSegmentSum"),o=k(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const a={data:r,indices:s,segmentIds:o};return R.runKernel(xd,a)}const O_=N({sparseSegmentSum_:P_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_(t,e,n,r,s,o,a,i){const l=k(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=k(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:a,preserveShortSequences:i},d={data:l,dataSplits:c},f=R.runKernel(wd,d,u);return{nGrams:f[0],nGramsSplits:f[1]}}const L_=N({stringNGrams_:M_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_(t,e,n=!0){const r=k(t,"input","stringSplit","string"),s=k(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:n},a={input:r,delimiter:s},i=R.runKernel($d,a,o);return{indices:i[0],values:i[1],shape:i[2]}}const V_=N({stringSplit_:B_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W_(t,e){const n=k(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return R.runKernel(bd,s,r)}const z_=N({stringToHashBucketFast_:W_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U_={fft:wg,ifft:tf,rfft:$g,irfft:Fw},G_={hammingWindow:yA,hannWindow:Lw,frame:Bw,stft:bA},H_={flipLeftRight:IA,grayscaleToRGB:TA,resizeNearestNeighbor:ZA,resizeBilinear:YA,rotateWithOffset:RA,cropAndResize:kA,nonMaxSuppression:FA,nonMaxSuppressionAsync:VA,nonMaxSuppressionWithScore:zA,nonMaxSuppressionWithScoreAsync:GA,nonMaxSuppressionPadded:jA,nonMaxSuppressionPaddedAsync:qA,threshold:t_,transform:r_},j_={bandPart:o_,gramSchmidt:i_,qr:c_},K_={absoluteDifference:f_,computeWeightedLoss:or,cosineDistance:h_,hingeLoss:g_,huberLoss:y_,logLoss:w_,meanSquaredError:b_,sigmoidCrossEntropy:S_,softmaxCrossEntropy:T_},q_={sparseFillEmptyRows:R_,sparseReshape:F_,sparseSegmentMean:__,sparseSegmentSum:O_},X_={stringNGrams:L_,stringSplit:V_,stringToHashBucketFast:z_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zr extends jv{minimize(e,n=!1,r){const{value:s,grads:o}=this.computeGradients(e,r);if(r!=null){const a=r.map(i=>({name:i.name,tensor:o[i.name]}));this.applyGradients(a)}else this.applyGradients(o);return _t(o),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return uw(e,n)}dispose(){this.iterations_!=null&&_t(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ve(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(zr,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class df extends zr{constructor(e,n,r=null){super();this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=R.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=R.registeredVariables[r],a=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Xe(()=>Qt(o).variable(a))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Xe(()=>Qt(o).variable(a))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const l=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;Xe(()=>{const u=le(Z(l,this.rho),Z(Cn(i),1-this.rho)),d=Z(Ae(sr(le(c,this.epsilon)),sr(le(l,this.epsilon))),i),f=le(Z(c,this.rho),Z(Cn(d),1-this.rho));l.assign(u),c.assign(f);const p=le(Z(d,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_t(this.accumulatedGrads.map(e=>e.variable)),_t(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}df.className="Adadelta";Lr(df);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ff extends zr{constructor(e,n=.1){super();this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=R.registeredVariables[r];if(this.accumulatedGrads[s]==null){const l=!1;this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Xe(()=>Kd(o.shape,this.initialAccumulatorValue).variable(l))}}const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const i=this.accumulatedGrads[s].variable;Xe(()=>{const l=le(i,Cn(a));i.assign(l);const c=le(Z(Ae(a,sr(le(l,R.backend.epsilon()))),-this.learningRate),o);o.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_t(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}ff.className="Adagrad";Lr(ff);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pf extends zr{constructor(e,n,r,s=null){super();this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Xe(()=>{this.accBeta1=ve(n).variable(),this.accBeta2=ve(r).variable()}),s==null&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Xe(()=>{const r=fe(1,this.accBeta1),s=fe(1,this.accBeta2);n.forEach((o,a)=>{const i=R.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Xe(()=>Qt(i).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:Xe(()=>Qt(i).variable(l))});const c=Array.isArray(e)?e[a].tensor:e[o];if(c==null)return;const u=this.accumulatedFirstMoment[a].variable,d=this.accumulatedSecondMoment[a].variable,f=le(Z(u,this.beta1),Z(c,1-this.beta1)),p=le(Z(d,this.beta2),Z(Cn(c),1-this.beta2)),h=Ae(f,r),g=Ae(p,s);u.assign(f),d.assign(p);const m=le(Z(Ae(h,le(sr(g),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(Z(this.accBeta1,this.beta1)),this.accBeta2.assign(Z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&_t(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),Xe(()=>{this.accBeta1.assign(pl(this.beta1,this.iterations_+1)),this.accBeta2.assign(pl(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}pf.className="Adam";Lr(pf);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class hf extends zr{constructor(e,n,r,s=null,o=0){super();this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Xe(()=>{this.iteration=ve(0).variable(),this.accBeta1=ve(n).variable()}),s==null&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Xe(()=>{const r=fe(1,this.accBeta1),s=Ae(-this.learningRate,le(Z(this.iteration,this.decay),1));n.forEach((o,a)=>{const i=R.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Qt(i).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:Qt(i).variable(l)});const c=Array.isArray(e)?e[a].tensor:e[o];if(c==null)return;const u=this.accumulatedFirstMoment[a].variable,d=this.accumulatedWeightedInfNorm[a].variable,f=le(Z(u,this.beta1),Z(c,1-this.beta1)),p=Z(d,this.beta2),h=Yt(c),g=xw(p,h);u.assign(f),d.assign(g);const m=le(Z(Ae(s,r),Ae(f,le(g,this.epsilon))),i);i.assign(m)}),this.iteration.assign(le(this.iteration,1)),this.accBeta1.assign(Z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&_t(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}hf.className="Adamax";Lr(hf);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yl extends zr{constructor(e){super();this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const a=R.registeredVariables[r];Xe(()=>{const i=le(Z(this.c,o),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Xv(ve(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}yl.className="SGD";Lr(yl);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mf extends yl{constructor(e,n,r=!1){super(e);this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=ve(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=R.registeredVariables[r];if(this.accumulations[s]==null){const l=!1;this.accumulations[s]={originalName:`${r}/momentum`,variable:Xe(()=>Qt(o).variable(l))}}const a=this.accumulations[s].variable,i=Array.isArray(e)?e[s].tensor:e[r];i!=null&&Xe(()=>{let l;const c=le(Z(this.m,a),i);this.useNesterov?l=le(Z(this.c,le(i,Z(c,this.m))),o):l=le(Z(this.c,c),o),a.assign(c),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_t(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}mf.className="Momentum";Lr(mf);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gf extends zr{constructor(e,n=.9,r=0,s=null,o=!1){super();if(this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=R.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=R.registeredVariables[r],a=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Xe(()=>Qt(o).variable(a))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Xe(()=>Qt(o).variable(a))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Xe(()=>Qt(o).variable(a))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const l=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;Xe(()=>{const u=le(Z(l,this.decay),Z(Cn(i),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,f=le(Z(d,this.decay),Z(i,1-this.decay)),p=Ae(Z(i,this.learningRate),sr(fe(u,le(Cn(f),this.epsilon)))),h=le(Z(c,this.momentum),p);l.assign(u),d.assign(f),c.assign(h);const g=fe(o,h);o.assign(g)}else{const d=le(Z(l,this.decay),Z(Cn(i),1-this.decay)),f=le(Z(c,this.momentum),Ae(Z(i,this.learningRate),sr(le(d,this.epsilon))));l.assign(d),c.assign(f);const p=fe(o,f);o.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_t(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_t(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&_t(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}gf.className="RMSProp";Lr(gf);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ur{static sgd(e){return new yl(e)}static momentum(e,n,r=!1){return new mf(e,n,r)}static rmsprop(e,n=.9,r=0,s=null,o=!1){return new gf(e,n,r,s,o)}static adam(e=.001,n=.9,r=.999,s=null){return new pf(e,n,r,s)}static adadelta(e=.001,n=.95,r=null){return new df(e,n,r)}static adamax(e=.002,n=.9,r=.999,s=null,o=0){return new hf(e,n,r,s,o)}static adagrad(e,n=.1){return new ff(e,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y_={sgd:Ur.sgd,momentum:Ur.momentum,adadelta:Ur.adadelta,adagrad:Ur.adagrad,rmsprop:Ur.rmsprop,adamax:Ur.adamax,adam:Ur.adam};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q_=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:t=>t())();function Z_(){return new Promise(t=>Q_(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eg(t,e){const n=t[0].length;t.forEach((s,o)=>{S(s.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),S(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,o)=>{for(let a=0;a<n;a++)S(a===e||s[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function Ln(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tg=30;function xf(t){return t<=Tg?t:qc(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ng(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vl(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=e.length;for(let a=0;a<o;++a)s=s.concat([t[a+1]/e[a],e[a]]);s=s.concat(t.slice(o+1))}return s}function wl(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let a=1;a<t;++a)a>=e*2+1||a%2==1?o.push(a):s.push(a);r.push(...s),r.push(0),r.push(...o)}return r}function $l(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let o=1;o<t.length;++o)o<=e.length?r?s.push(e[o-1]*t[o]):s.push(t[o]/e[o-1]):s.push(t[o]);return s}function Rg(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function Dg(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fg=1.7580993408473768,Ag=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _g=.3275911,Pg=.254829592,Og=-.284496736,Mg=1.421413741,Lg=-1.453152027,Bg=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function zw(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function Uw(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function Gw(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function Vg(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function Hw(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function jw(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function Kw(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wg="->",J_=/->/g,qw=",",Xw="...";function zg(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(J_,"").length)/Wg.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Wg}").`);const[r,s]=t.split(Wg);S(r.indexOf(Xw)===-1,()=>`The ellipsis notation ("${Xw}") is not supported yet.`);const o=r.split(qw),a=o.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let f=0;f<s.length;++f){const p=s[f];if(!o.some(h=>h.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);i.indexOf(p)===-1&&i.push(p)}for(let f=0;f<r.length;++f){const p=r[f];i.indexOf(p)===-1&&p!==qw&&i.push(p)}const l=new Array(o.length);for(let f=0;f<a;++f){if(new Set(o[f].split("")).size!==o[f].length)throw new Error(`Found duplicate axes in input component ${o[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let p=0;p<o[f].length;++p)l[f].push(i.indexOf(o[f][p]))}const c=i.length,u=s.length,d=[];for(let f=u;f<c;++f)d.push(f);return{allDims:i,summedDims:d,idDims:l}}function Ug(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function Gg(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const o=n[s].shape;for(let a=0;a<e[s].length;++a)r[e[s][a]]===void 0?r[e[s][a]]=o[a]:S(r[e[s][a]]===o[a],()=>`Expected dimension ${r[e[s][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function Hg(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let a=0;a<s;++a)r.push([]);const o=[];for(let a=0;a<n.length;++a){const i=n[a],l=eP(e,i);for(const c of l)o.indexOf(c)===-1&&(r[a].push(c),o.push(c))}return{path:n,steps:r}}function jg(t){return t.every((e,n)=>e===n)}function eP(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function Kg(t,e,n=0){let r=[];if(typeof e=="number")S(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);S(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const a=e.reduce((i,l)=>l>0?i+l:i);e[o]=t.shape[n]-a}S(t.shape[n]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yw(t,e){let n=!1,r;for(t<=Tg?(r=t,n=!0):r=qc(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=qc(t,r+1);return r}function Qw(t,e,n){const r=[],s=t.length;for(let o=0;o<s;o++)o!==e?r.push(t[o]):r.push(n);return r}function qg(t,e,n,r){const s=e.shape.length,o=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(t.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const a=t.shape[n],i=[];let l=1,c=1,u=1;for(let d=0;d<r;++d)i.push(t.shape[d]),l*=t.shape[d];for(let d=r;d<n;d++)i.push(t.shape[d]),c*=t.shape[d];for(let d=r;d<s;d++)i.push(e.shape[d]);for(let d=n+1;d<o;d++)i.push(t.shape[d]),u*=t.shape[d];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:a,outputShape:i}}var tP=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",segOpComputeOptimalWindowSize:Yw,computeOutShape:Qw,collectGatherOpShapeInfo:qg});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(t){try{return t.map(e=>gs(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Zw(t){return t.map(e=>_n(e))}var Jw=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",slice_util:Hv,segment_util:tP,fromUint8ToStringArray:Ds,fromStringArrayToUint8:Zw,upcastType:zt,axesAreInnerMostDims:gg,combineLocations:fw,computeOutAndReduceShapes:dt,expandShapeToKeepDim:tt,assertAxesAreInnerMostDims:ft,getAxesPermutation:Ye,getUndoAxesPermutation:Yd,getInnerMostAxes:Qe,getBroadcastDims:Ao,getReductionAxes:tw,assertAndGetBroadcastShape:ye,assertParamsConsistent:Eg,computeOutShape:Ln,computeDilation2DInfo:ll,computePool2DInfo:hn,computePool3DInfo:nr,computeConv2DInfo:st,computeConv3DInfo:Vr,computeDefaultPad:ug,tupleValuesAreOne:cl,eitherStridesOrDilationsAreOne:vt,convertConv2DDataFormat:rr,getFusedDyActivation:rf,getFusedBiasGradient:sf,applyActivation:of,shouldFuse:af,PARALLELIZE_THRESHOLD:Tg,computeOptimalWindowSize:xf,getImageCenter:Ng,getReshaped:vl,getPermuted:wl,getReshapedPermuted:$l,getSliceBeginCoords:Rg,getSliceSize:Dg,prepareAndValidate:zd,validateUpdateShape:Qm,validateInput:Zm,calculateShapes:Ro,SELU_SCALEALPHA:Fg,SELU_SCALE:Ag,ERF_P:_g,ERF_A1:Pg,ERF_A2:Og,ERF_A3:Mg,ERF_A4:Lg,ERF_A5:Bg,warn:At,log:sS,mergeRealAndImagArrays:ar,splitRealAndImagArrays:zw,complexWithEvenIndex:Uw,complexWithOddIndex:Gw,getComplexWithIndex:Vg,assignToTypedArray:Hw,exponents:jw,exponent:Kw,decodeEinsumEquation:zg,getEinsumPermutation:Ug,checkEinsumDimSizes:Gg,getEinsumComputePath:Hg,isIdentityPermutation:jg,prepareSplitSize:Kg});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var nP=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",nonMaxSuppressionV3Impl:lf,nonMaxSuppressionV4Impl:cf,nonMaxSuppressionV5Impl:uf,whereImpl:nf});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var xX=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",OptimizerConstructors:Ur,AdadeltaOptimizer:df,AdagradOptimizer:ff,AdamOptimizer:pf,AdamaxOptimizer:hf,MomentumOptimizer:mf,Optimizer:zr,RMSPropOptimizer:gf,SGDOptimizer:yl,Tensor:qe,TensorBuffer:et,Variable:ol,get Rank(){return Tm},sumOutType:Ld,upcastType:zt,get Reduction(){return Et},customGrad:Mn,grad:sR,grads:oR,valueAndGrad:aR,valueAndGrads:iR,variableGrads:uw,Environment:Ky,env:z,get ENV(){return am},nextFrame:Z_,KernelBackend:Hc,DataStorage:Qh,abs:Yt,acos:BE,acosh:WE,add:le,addN:UE,all:HE,any:KE,argMax:XE,argMin:QE,asin:JE,asinh:tT,atan:rT,atan2:oT,atanh:iT,avgPool:Qv,avgPool3d:mT,basicLSTMCell:$T,batchToSpaceND:Zv,batchNorm:Gd,batchNorm2d:IT,batchNorm3d:TT,batchNorm4d:RT,bincount:Jv,broadcastArgs:AT,broadcastTo:Hd,buffer:de,cast:Ue,ceil:OT,clipByValue:LT,clone:$s,complex:xs,concat:Gt,concat1d:VT,concat2d:zT,concat3d:GT,concat4d:jT,conv1d:XT,conv2d:jd,conv2dTranspose:ZT,conv3d:eN,conv3dTranspose:sN,cos:aN,cosh:lN,cumsum:uN,denseBincount:fN,depthToSpace:hN,depthwiseConv2d:pg,diag:xN,dilation2d:vN,div:Ae,divNoNan:kN,dot:IN,einsum:TN,elu:rw,equal:nw,erf:DN,exp:Ss,expandDims:Is,expm1:PN,eye:sw,fill:Kd,floor:ow,floorDiv:Yv,gather:aw,greater:qd,greaterEqual:iw,imag:hg,isFinite:GN,isInf:jN,isNaN:qN,leakyRelu:lw,less:QN,lessEqual:mg,linspace:JN,localResponseNormalization:tR,log:dl,log1p:cw,logSigmoid:dR,logSoftmax:gR,logSumExp:pw,logicalAnd:Qd,logicalNot:hw,logicalOr:mw,logicalXor:bR,matMul:$e,max:Po,maxPool:gw,maxPool3d:SR,maxPoolWithArgmax:ER,maximum:xw,mean:Zd,meshgrid:RR,min:xg,minimum:yw,mirrorPad:_R,mod:OR,moments:BR,mul:Z,multiRNNCell:WR,multinomial:UR,neg:Wr,notEqual:vw,oneHot:Ym,ones:Ts,onesLike:jR,outerProduct:qR,pad:fl,pad1d:QR,pad2d:JR,pad3d:tD,pad4d:rD,pool:lD,pow:pl,prelu:$w,print:Tv,prod:fD,rand:hD,randomGamma:kD,randomNormal:ID,randomUniform:Nw,range:hl,real:Jd,reciprocal:RD,relu:ef,relu6:Rw,reshape:H,reverse:Rs,reverse1d:PD,reverse2d:MD,reverse3d:BD,reverse4d:WD,round:Dw,rsqrt:GD,scalar:ve,selu:jD,separableConv2d:qD,setdiff1dAsync:YD,sigmoid:Fo,sign:ZD,sin:eF,sinh:nF,slice:Me,slice1d:sF,slice2d:aF,slice3d:lF,slice4d:uF,softmax:fF,softplus:dw,spaceToBatchND:ww,fft:wg,ifft:tf,irfft:Fw,rfft:$g,split:ml,sqrt:sr,square:Cn,squaredDifference:Aw,squeeze:bg,stack:gl,step:_w,stridedSlice:kF,sub:fe,sum:_e,tan:IF,tanh:fg,tensor:Eo,tensor1d:kn,tensor2d:xl,tensor3d:_v,tensor4d:EF,tensor5d:TF,tensor6d:NF,tile:ul,topk:DF,truncatedNormal:AF,unique:PF,unsortedSegmentSum:MF,unstack:Cg,variable:BF,where:_o,whereAsync:Pw,zeros:Es,zerosLike:Qt,op:N,OP_SCOPE_SUFFIX:gv,booleanMaskAsync:zF,transpose:Wd,norm:kg,movingAverage:HF,scatterND:KF,sparseToDense:YF,gatherND:ZF,dropout:tA,enclosingPowerOfTwo:Mw,cosineWindow:Sg,inTopKAsync:rA,image:H_,linalg:j_,losses:K_,spectral:U_,fused:gA,signal:G_,sparse:q_,string:X_,train:Y_,enableProdMode:xE,enableDebugMode:yE,disableDeprecationWarnings:vE,deprecationWarn:wE,disposeVariables:$E,engine:Br,memory:bE,profile:CE,tidy:Xe,dispose:_t,keep:Xv,time:kE,setBackend:SE,ready:IE,getBackend:EE,removeBackend:TE,findBackend:NE,findBackendFactory:RE,registerBackend:cg,backend:DE,setPlatform:FE,getKernel:Fd,getGradient:$m,getKernelsForBackend:Ad,registerKernel:_d,registerGradient:pS,unregisterKernel:hS,unregisterGradient:mS,copyRegisteredKernels:gS,Abs:Xc,Acos:qa,Acosh:Xa,Add:$o,AddN:Yc,All:Qc,Any:Zc,ArgMax:Jc,ArgMin:eu,Asin:Ya,Asinh:Qa,Atan:Za,Atanh:Ja,Atan2:ei,AvgPool:tu,AvgPoolGrad:cm,AvgPool3D:nu,AvgPool3DGrad:um,BatchMatMul:ru,BatchToSpaceND:su,Bincount:ou,BroadcastTo:uS,BroadcastArgs:au,Cast:ti,Ceil:ni,ClipByValue:ri,Complex:iu,ComplexAbs:lu,Concat:cu,Conv2D:uu,Conv2DBackpropFilter:du,Conv2DBackpropInput:fu,Conv3D:pu,Conv3DBackpropFilterV2:dm,Conv3DBackpropInputV2:hu,Cos:si,Cosh:oi,Cumsum:mu,CropAndResize:gu,DenseBincount:xu,DepthToSpace:yu,DepthwiseConv2dNative:vu,DepthwiseConv2dNativeBackpropFilter:wu,DepthwiseConv2dNativeBackpropInput:$u,Diag:bu,Dilation2D:Cu,Dilation2DBackpropInput:fm,Dilation2DBackpropFilter:pm,RealDiv:ai,Einsum:ku,Elu:ii,EluGrad:hm,Erf:li,Equal:ci,Exp:ui,ExpandDims:Su,Expm1:di,FFT:Iu,Fill:Eu,FlipLeftRight:Tu,Floor:fi,FloorDiv:pi,FusedBatchNorm:Nu,GatherV2:Ru,GatherNd:Du,Greater:hi,GreaterEqual:mi,Identity:gi,IFFT:Fu,Imag:Au,IsFinite:xi,IsInf:yi,IsNan:vi,LeakyRelu:_u,Less:wi,LessEqual:$i,LinSpace:Pu,Log:bi,Log1p:Ci,LogicalAnd:ki,LogicalNot:Si,LogicalOr:Ii,LogSoftmax:dS,LRN:Ou,LRNGrad:mm,Max:Mu,Maximum:Ei,MaxPool:Lu,MaxPoolGrad:gm,MaxPool3D:Bu,MaxPool3DGrad:xm,MaxPoolWithArgmax:Vu,Mean:Wu,Min:zu,Minimum:Ti,MirrorPad:Uu,Mod:Ni,Multinomial:Gu,Multiply:Ri,Neg:Hu,NotEqual:Di,NonMaxSuppressionV3:ju,NonMaxSuppressionV4:Ku,NonMaxSuppressionV5:qu,OnesLike:Xu,OneHot:Yu,Pack:Qu,PadV2:Zu,Pool:fS,Pow:Fi,Prelu:Ju,Prod:ed,Range:td,Real:nd,Reciprocal:Ai,Relu:_i,Reshape:rd,ResizeNearestNeighbor:sd,ResizeNearestNeighborGrad:ym,ResizeBilinear:od,ResizeBilinearGrad:vm,Relu6:Pi,Reverse:ad,Round:Oi,Rsqrt:Mi,ScatterNd:id,Select:ld,Selu:Li,Slice:cd,Sin:Bi,Sinh:Vi,Sign:Wi,Sigmoid:zi,Softplus:Ui,Sqrt:Gi,Sum:ud,SpaceToBatchND:dd,SplitV:fd,Softmax:pd,SparseFillEmptyRows:hd,SparseReshape:md,SparseSegmentMean:gd,SparseSegmentSum:xd,SparseToDense:yd,SquaredDifference:Hi,Square:wm,StridedSlice:vd,StringNGrams:wd,StringSplit:$d,StringToHashBucketFast:bd,Sub:ji,Tan:Ki,Tanh:qi,Tile:Xi,TopK:Cd,Transform:kd,Transpose:Sd,Unique:Id,Unpack:Ed,UnsortedSegmentSum:Td,ZerosLike:Nd,Step:Yi,FromPixels:Rd,RotateWithOffset:Dd,_FusedMatMul:Qi,FusedConv2D:Zi,FusedDepthwiseConv2D:Ji,version_core:gE,browser:eE,io:VI,math:jI,serialization:iE,test_util:mE,util:SS,backend_util:Jw,tensor_util:BS,slice_util:Hv,gather_util:tE,scatter_util:nE,device_util:GS,kernel_impls:nP});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ne(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&S(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rP=nf;class yf extends Hc{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new Qh(this,Br())}nextDataId(){return yf.nextDataId++}write(e,n,r){this.firstUse&&(this.firstUse=!1,z().get("IS_NODE")&&At(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&An(r[0])){const o=r.map(a=>_n(a));s=this.write(o,e,n)}else s=this.write(r,e,n);return{dataId:s,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){const n=this.data.get(e);n.refCount--}}move(e,n,r,s,o){this.data.set(e,{values:n,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:n,complexTensorInfos:r}=this.data.get(e);if(n==="complex64"){const s=this.readSync(r.real.dataId),o=this.readSync(r.imag.dataId);return ar(s,o)}return this.data.get(e).values}bufferSync(e){const n=this.readSync(e.dataId);let r=n;if(e.dtype==="string")try{r=n.map(s=>gs(s))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return de(e.shape,e.dtype,r)}makeOutput(e,n,r){const s=this.write(e,n,r);return Br().makeTensorFromDataId(s,n,r,this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const n=Wt();return e(),{kernelMs:Wt()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ne([e],"where");const n=this.readSync(e.dataId);return rP(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}yf.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const sP=t=>{const{x:e}=t.inputs,n=t.backend;ne(e,"abs");let r=new Float32Array(L(e.shape));const s=n.data.get(e.dataId).values;return r=e$(s),n.makeOutput(r,e.shape,e.dtype)},oP={kernelName:Xc,backendName:"cpu",kernelFunc:sP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(t){return(e,n,r,s,o)=>{const a=ye(e,n),i=a.length,l=ae(a),c=L(a),u=Je(o,c),d=e.length,f=n.length,p=ae(e),h=ae(n),g=Ao(e,a),m=Ao(n,a);if(g.length+m.length===0)for(let x=0;x<u.length;++x)u[x]=t(r[x%r.length],s[x%s.length]);else for(let x=0;x<u.length;++x){const y=wo(x,i,l),w=y.slice(-d);g.forEach(C=>w[C]=0);const v=wn(w,d,p),$=y.slice(-f);m.forEach(C=>$[C]=0);const b=wn($,f,h);u[x]=t(r[v],s[b])}return[u,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,i=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(i.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",o),imag:n.makeTensorInfo(s.shape,"float32",a)},i}const aP={kernelName:iu,backendName:"cpu",kernelFunc:Ht};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vf(t,e,n="float32"){if(n==="complex64"){const s=vf(t,e,"float32"),o=vf(t,e,"float32");return Ht({inputs:{real:s,imag:o},backend:t})}const r=ut(L(e),n);return t.makeTensorInfo(e,n,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bn(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const iP={kernelName:gi,backendName:"cpu",kernelFunc:Bn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fs(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.data.get(r.dataId).complexTensorInfos.real,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}const lP={kernelName:nd,backendName:"cpu",kernelFunc:Fs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gr(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return Bn({inputs:{x:s},backend:n});const a=vf(n,s.shape,s.dtype),i=Gr({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Ht({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}if(s.dtype==="complex64"){const a=Fs({inputs:{input:s},backend:n}),i=Gr({inputs:{x:a},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(a),i}if(!tm(s.dtype,o)){const a=Bn({inputs:{x:s},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32"){const a=n.data.get(s.dataId).values,i=Int32Array.from(a);return n.makeTensorInfo(s.shape,"int32",i)}if(o==="bool"){const a=n.data.get(s.dataId).values,i=_r([0],s.dtype),[l,c]=Ze((u,d)=>u!==d?1:0)(s.shape,[],a,i,"bool");return n.makeTensorInfo(c,"bool",l)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const cP={kernelName:ti,backendName:"cpu",kernelFunc:Gr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ot(t,e,n,r){return n==null?({inputs:s,backend:o})=>{const{a,b:i}=s,l=o;ne([a,i],t);const c=l.data.get(a.dataId).values,u=l.data.get(i.dataId).values,d=a.dtype==="string"?Ds(c):c,f=a.dtype==="string"?Ds(u):u,p=r||a.dtype,[h,g]=e(a.shape,i.shape,d,f,p);return l.makeTensorInfo(g,p,h)}:({inputs:s,backend:o})=>{const{a,b:i}=s,l=o;if(a.dtype==="complex64"||i.dtype==="complex64"){const c=Gr({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),d=u.complexTensorInfos.real,f=u.complexTensorInfos.imag,p=l.data.get(d.dataId).values,h=l.data.get(f.dataId).values,g=Gr({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),x=m.complexTensorInfos.real,y=m.complexTensorInfos.imag,w=l.data.get(x.dataId).values,v=l.data.get(y.dataId).values,[$,b,C]=n(a.shape,i.shape,p,h,w,v),I=l.makeTensorInfo(C,"float32",$),E=l.makeTensorInfo(C,"float32",b),T=Ht({inputs:{real:I,imag:E},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(E),T}else{const c=l.data.get(a.dataId).values,u=l.data.get(i.dataId).values,d=r||a.dtype,[f,p]=e(a.shape,i.shape,c,u,d);return l.makeTensorInfo(p,d,f)}}}function Xg(t){return(e,n,r,s,o,a)=>{const i=ye(e,n),l=L(i),c=i.length,u=ae(i),d=Je("float32",l),f=Je("float32",l),p=Ao(e,i),h=Ao(n,i),g=ar(r,s),m=ar(o,a),x=e.length,y=ae(e),w=n.length,v=ae(n);if(p.length+h.length===0)for(let $=0;$<d.length;$++){const b=$%g.length,C=$%m.length,I=t(g[b*2],g[b*2+1],m[C*2],m[C*2+1]);d[$]=I.real,f[$]=I.imag}else for(let $=0;$<d.length;$++){const b=wo($,c,u),C=b.slice(-x);p.forEach(F=>C[F]=0);const I=wn(C,x,y),E=b.slice(-w);h.forEach(F=>E[F]=0);const T=wn(E,w,v),D=t(g[I*2],g[I*2+1],m[T*2],m[T*2+1]);d[$]=D.real,f[$]=D.imag}return[d,f,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t$=Ze((t,e)=>t+e),uP=Xg((t,e,n,r)=>({real:t+n,imag:e+r})),bl=ot($o,t$,uP),dP={kernelName:$o,backendName:"cpu",kernelFunc:bl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yg(t,e,n,r,s){const o=L(r),a=ut(s,n);for(let i=0;i<t.length;i++){const l=t[i];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o>0?a[l]+=e[i]:a[l]+=1)}return a}function n$(t,e,n,r=!1){const s=t.shape[0],o=t.shape[1],a=de([s,n],e.dtype);for(let i=0;i<s;i++)for(let l=0;l<o;l++){const c=t.get(i,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?a.set(1,i,c):e.size>0?a.set(a.get(i,c)+e.get(i,l),i,c):a.set(a.get(i,c)+1,i,c))}return a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hr(t){return(e,n,r)=>{const s=Je(n,e.length);for(let o=0;o<e.length;++o)s[o]=t(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function be(t,e,n){return({inputs:r,attrs:s,backend:o})=>{const{x:a}=r;if(ne(a,t),a.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");const i=o,l=i.data.get(a.dataId).values,c=L(a.shape),u=n||a.dtype,d=St(u,c);for(let f=0;f<c;++f)d[f]=e(l[f],s);return i.makeTensorInfo(a.shape,u,d)}}function Mo(t,e,n){return({inputs:r,attrs:s,backend:o})=>{const{x:a}=r;if(ne(a,t),a.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");const i=o,l=i.data.get(a.dataId).values,c=n||a.dtype,u=e(l,c,s);return i.makeTensorInfo(a.shape,c,u)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r$=Hr(t=>Math.ceil(t)),fP=Mo(ni,r$),pP={kernelName:ni,backendName:"cpu",kernelFunc:fP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(t,e,n,r){const s=St(n,L(e));if(r&&n!=="string"){let o=0;t.forEach(a=>{const i=L(a.shape);s.set(a.vals,o),o+=i})}else{let o=0;t.forEach(a=>{const i=n==="string"?Ds(a.vals):a.vals;let l=0;for(let c=0;c<a.shape[0];++c){const u=c*e[1]+o;for(let d=0;d<a.shape[1];++d)s[u+d]=i[l++]}o+=a.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o$=Ze((t,e)=>t===e?1:0),a$=ot(ci,o$,null,"bool"),hP={kernelName:ci,backendName:"cpu",kernelFunc:a$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i$=Hr(t=>Math.exp(t)),l$=Mo(ui,i$,"float32"),mP={kernelName:ui,backendName:"cpu",kernelFunc:l$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$=Hr(t=>Math.expm1(t)),gP=Mo(di,c$),xP={kernelName:di,backendName:"cpu",kernelFunc:gP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u$=Hr(t=>Math.floor(t)),yP=Mo(fi,u$),vP={kernelName:fi,backendName:"cpu",kernelFunc:yP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(t,e,n,r,s,o,a,i,l){const c=de([r,o],n);for(let u=0;u<r;u++){const d=[];let f=0;for(let p=0;p<s;p++){const h=t[u*s+p];f+=h*a[p],d.push(h)}if(f<0||f>=l/o)throw new Error(`Invalid indices: ${d} does not index into ${i}`);for(let p=0;p<o;p++)c.values[u*o+p]=e.get(...e.indexToLoc(f*o+p))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(t,e,n){const r=de(n,t.dtype);for(let s=0;s<r.size;++s){const a=r.indexToLoc(s).slice(),i=a[0],l=a[2],c=e.locToIndex([i,l]);a[2]=e.values[c];const u=t.locToIndex(a);r.values[s]=t.values[u]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p$=Ze((t,e)=>t>e?1:0),wP=ot(hi,p$,null,"bool"),$P={kernelName:hi,backendName:"cpu",kernelFunc:wP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$=Ze((t,e)=>t>=e?1:0),bP=ot(mi,h$,null,"bool"),CP={kernelName:mi,backendName:"cpu",kernelFunc:bP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m$=Ze((t,e)=>t<e?1:0),kP=ot(wi,m$,null,"bool"),SP={kernelName:wi,backendName:"cpu",kernelFunc:kP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g$=Ze((t,e)=>t<=e?1:0),IP=ot($i,g$,null,"bool"),EP={kernelName:$i,backendName:"cpu",kernelFunc:IP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$(t,e,n){const r=(e-t)/(n-1),s=ut(n,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y$=Hr(t=>Math.log(t)),TP=Mo(bi,y$),NP={kernelName:bi,backendName:"cpu",kernelFunc:TP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v$(t,e,n,r){const s=Je(r,L(n));for(let o=0;o<s.length;++o){const a=o*e;let i=t[a];for(let l=0;l<e;++l){const c=t[a+l];(Number.isNaN(c)||c>i)&&(i=c)}s[o]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w$=Ze((t,e)=>Math.max(t,e)),RP=ot(Ei,w$),DP={kernelName:Ei,backendName:"cpu",kernelFunc:RP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $$=Ze((t,e)=>Math.min(t,e)),FP=ot(Ti,$$),AP={kernelName:Ti,backendName:"cpu",kernelFunc:FP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qg=Ze((t,e)=>t*e),_P=Xg((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n})),wf=ot(Ri,Qg,_P),PP={kernelName:Ri,backendName:"cpu",kernelFunc:wf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(t,e,n){const r=er(-1,n);return Qg([],e,r,t,n)}function OP(t){const{inputs:e,backend:n}=t,{x:r}=e;ne(r,"neg");const s=n.data.get(r.dataId).values,[o,a]=b$(s,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,o)}const MP={kernelName:Hu,backendName:"cpu",kernelFunc:OP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C$=Ze((t,e)=>t!==e?1:0),LP=ot(Di,C$,null,"bool"),BP={kernelName:Di,backendName:"cpu",kernelFunc:LP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zg(t,e,n,r,s){const o=e.length,a=L(e),i=ae(e),l=ae(s),c=Je(n,L(s));for(let u=0;u<a;++u){const d=wo(u,o,i),f=new Array(d.length);for(let h=0;h<f.length;h++)f[h]=d[r[h]];const p=wn(f,o,l);c[p]=t[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(t){const{inputs:e,attrs:n,backend:r}=t,{x:s}=e,{perm:o}=n;ne(s,"transpose");const a=s.shape.length,i=new Array(a);for(let d=0;d<i.length;d++)i[d]=s.shape[o[d]];const l=r.data.get(s.dataId).values,c=Zg(l,s.shape,s.dtype,o,i);return{dataId:r.write(c,i,s.dtype),shape:i,dtype:s.dtype}}const VP={kernelName:Sd,backendName:"cpu",kernelFunc:Zt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k$(t,e,n,r){const[s,o]=dt(t,r),a=zt(e,"int32"),i=ut(L(s),a),l=L(o);for(let c=0;c<i.length;++c){const u=c*l;let d=1;for(let f=0;f<l;++f)d*=n[u+f];i[c]=d}return{outVals:i,outShape:s,outDtype:a}}function WP(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;ne(s,"prod");const i=s.shape.length,l=ge(o,s.shape),c=Ye(l,i);let u=l,d=s;const f=[];c!=null&&(d=Zt({inputs:{x:s},backend:n,attrs:{perm:c}}),f.push(d),u=Qe(u.length,i));const p=n.data.get(d.dataId).values,{outVals:h,outShape:g,outDtype:m}=k$(d.shape,d.dtype,p,u);let x=g;return a&&(x=tt(g,l)),f.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(x,m,h)}const zP={kernelName:ed,backendName:"cpu",kernelFunc:WP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$(t,e,n,r){const s=t===e,o=t<e&&n<0,a=e<t&&n>1;if(s||o||a)return ut(0,r);const i=Math.abs(Math.ceil((e-t)/n)),l=ut(i,r);e<t&&n===1&&(n=-1),l[0]=t;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I$=Hr(t=>1/Math.sqrt(t)),UP=Mo(Mi,I$),GP={kernelName:Mi,backendName:"cpu",kernelFunc:UP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HP=Hr(t=>1/(1+Math.exp(-t))),E$=be(zi,t=>1/(1+Math.exp(-t))),jP={kernelName:zi,backendName:"cpu",kernelFunc:E$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$(t,e,n,r,s){const o=ng(r,e,n),a=L(n),i=ae(r);if(o){const d=rg(e,i);return s==="string"?t.slice(d,d+a):t.subarray(d,d+a)}const l=s==="string"?Ds(t):t,c=de(r,s,l),u=de(n,s);for(let d=0;d<u.size;++d){const f=u.indexToLoc(d),p=f.map((h,g)=>h+e[g]);u.set(c.get(...p),...f)}return s==="string"?Zw(u.values):u.values}function As(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:a}=r;ne(s,"slice");const[i,l]=sg(s,o,a);eg(s,i,l);const c=n.data.get(s.dataId).values,u=T$(c,i,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const KP={kernelName:cd,backendName:"cpu",kernelFunc:As};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$(t,e,n,r,s,o,a){const i=e[0],l=o[0],c=new Array(l),u=new Array(i),d=e[1];if(l===0){if(i!==0)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${i}`);const m=St(n,0),x=St(s,0);return[m,[0,d],x,c,u]}let f=!0,p=0;const h=new Array(l).fill(0);for(let m=0;m<i;++m){const x=t[m*d];if(x<0)throw new Error(`indices(${m}, 0) is invalid: ${x} < 0`);if(x>=l)throw new Error(`indices(${m}, 0) is invalid: ${x} >= ${l}`);++h[x],f=f&&x>=p,p=x}let g=!0;for(let m=0;m<l;++m){const x=h[m]===0;c[m]=x,g=g&&!x,h[m]=Math.max(h[m],1),m>0&&(h[m]+=h[m-1])}if(g&&f){const m=t,x=r;for(let y=0;y<i;++y)u[y]=y;return[m,[i,d],x,c,u]}else{const m=h[l-1],x=St(n,m*d),y=St(s,m),w=new Array(l).fill(0);for(let v=0;v<i;++v){const $=t[v*d],b=w[$],C=($===0?0:h[$-1])+b;w[$]++;for(let I=0;I<d;++I)x[C*d+I]=t[v*d+I];y[C]=r[v],u[v]=C}for(let v=0;v<l;++v)if(w[v]===0){const b=v===0?0:h[v-1];x[b*d+0]=v;for(let C=1;C<d;++C)x[b*d+C]=0;y[b]=a}return[x,[m,d],y,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$(t,e,n,r,s){const o=L(r),a=e[0],i=s.length,l=[];let c=1,u=-1;for(let m=0;m<i;++m){const x=s[m];if(x===-1){if(u!==-1)throw new Error(`only one output dimension may be -1, not both ${u} and ${m}`);u=m,l.push(1)}else{if(x<0)throw new Error(`size ${m} must be non-negative, not ${x}`);c*=x,l.push(x)}}if(u!==-1){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const m=Math.trunc(o/c);if(c*m!==o)throw new Error(`Input to reshape is a SparseTensor with ${o}
          dense values, but the requested shape requires a multiple of ${c}. inputShape=${r} outputShape= ${l}`);l[u]=m}const d=L(l);if(d!==o)throw new Error(`Input to reshape is a tensor with ${o} dense values, but the requested shape has ${d}. inputShape=${r} outputShape=${l}`);const f=r.length,p=[];if(f>0){p[f-1]=1;for(let m=f-2;m>=0;--m)p[m]=p[m+1]*r[m+1]}const h=[];if(i>0){h[i-1]=1;for(let m=i-2;m>=0;--m)h[m]=h[m+1]*l[m+1]}const g=St(n,a*i);for(let m=0;m<a;++m){let x=0;for(let y=0;y<f;++y)x+=t[m*f+y]*p[y];for(let y=0;y<i;++y)g[m*i+y]=Math.trunc(x/h[y]),x%=h[y]}return[g,[a,i],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jg(t,e,n,r,s,o=!1,a=0){const i=r.length;if(i!==s.length)throw new Error("segmentIds and indices should have same size.");const l=[e[0],t.length/e[0]],c=l[1],d=i>0?s[i-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const f=e.slice();f[0]=d;const p=f.reduce((w,v)=>w*v,1),h=St(n,p);if(i===0)return d>0&&h.fill(a),[h,f];if(d<=0)throw new Error("segment ids must be >= 0");let g=0,m=1,x=0,y=s[g];for(;;){let w=0;if(m<i){if(w=s[m],y===w){++m;continue}if(y>=w)throw new Error("segment ids are not increasing")}if(y<0||y>=d)throw new Error(`Segment id ${y} out of range [0, ${d}), possibly because segmentIds input is not sorted.`);y>x&&h.fill(a,x*c,y*c);for(let v=g;v<m;++v){const $=r[v];if($<0||$>=l[0])throw new Error(`Bad: indices[${v}] == ${r[v]} out of range [0, ${l[0]})`);for(let b=0;b<c;b++)h[y*c+b]+=t[$*c+b]}if(o)for(let v=0;v<c;v++)h[y*c+v]/=m-g;if(g=m,++m,x=y+1,y=w,m>i)break}return x<d&&h.fill(a,x*c,d*c),[h,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qP=Hr(t=>Math.sqrt(t)),XP=be(Gi,t=>Math.sqrt(t)),YP={kernelName:Gi,backendName:"cpu",kernelFunc:XP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D$=Ze((t,e)=>{const n=t-e;return n*n}),QP=ot(Hi,D$),ZP={kernelName:Hi,backendName:"cpu",kernelFunc:QP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$(t,e,n,r){const s=de(t,e.dtype);for(let o=0;o<s.size;o++){const a=s.indexToLoc(o),i=new Array(a.length);for(let l=0;l<i.length;l++)i[l]=a[l]*n[l]+r[l];s.set(e.get(...i),...a)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JP{constructor(e,n,r,s,o,a){this.separator=_n(e),this.nGramWidths=n,this.leftPad=_n(r),this.rightPad=_n(s),this.padWidth=o,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,s,o,a){for(let i=0;i<o;++i){const l=this.getPadWidth(a),c=Math.max(0,l-i),u=Math.max(0,l-(o-(i+1))),d=a-(c+u),f=n+(c>0?0:i-l);let p=0;p+=c*this.leftPad.length;for(let y=0;y<d;++y)p+=e[f+y].length;p+=u*this.rightPad.length,p+=(c+u+d-1)*this.separator.length,r[s+i]=new Uint8Array(p);const g=r[s+i];let m=0;const x=y=>y.forEach(w=>g[m++]=w);for(let y=0;y<c;++y)x(this.leftPad),x(this.separator);for(let y=0;y<d-1;++y)x(e[f+y]),x(this.separator);if(d>0){x(e[f+d-1]);for(let y=0;y<u;++y)x(this.separator),x(this.rightPad)}else{for(let y=0;y<u-1;++y)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,n){const r=e.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=n[c]>=l;if(u=u&&n[c]<=r,!u)throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${r}]`);l=n[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,a=St("int32",s);if(r===0||s===0){const l=new Array(r);for(let c=0;c<=o;++c)a[c]=0;return[l,a]}a[0]=0;for(let l=1;l<=o;++l){const c=n[l]-n[l-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&u===0&&(u=1),a[l]=a[l-1]+u}const i=new Array(a[o]);for(let l=0;l<o;++l){const c=n[l];let u=a[l];if(this.nGramWidths.forEach(d=>{const f=n[l+1]-n[l],p=this.getNumNGrams(f,d);this.createNGrams(e,c,i,u,p,d),u+=p}),this.preserveShort&&u===a[l]){const d=n[l+1]-n[l];if(d===0)continue;const f=d+2*this.padWidth,p=1;this.createNGrams(e,c,i,u,p,f)}}return[i,a]}}function A$(t,e,n,r,s,o,a,i){return new JP(n,r,s,o,a,i).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e3(t,e,n,r){if(!t.length)return;if(e.length===0){for(let o=0;o<t.length;++o)r.push(t.subarray(o,o+1));return}if(e.length===1){const o=e[0];let a=t.indexOf(o);for(;a!==-1;){const i=t.subarray(0,a);(!n||i.length!==0)&&r.push(i),t=t.subarray(a+1),a=t.indexOf(o)}(!n||t.length!==0)&&r.push(t);return}let s=0;for(let o=0;o<t.length+1;o++)if(o===t.length||e.indexOf(t[o])!==-1){const a=t.subarray(s,o);(!n||a.length!==0)&&r.push(a),s=o+1}}function _$(t,e,n){const r=t.length,s=[];let o=0,a=0;const i=new Array(r);for(let f=0;f<r;++f){const p=s.length;e3(t[f],e,n,s);const h=s.length-p;i[f]=h,o+=h,a=Math.max(a,h)}const l=St("int32",o*2),c=new Array(o),u=[r,a];let d=0;for(let f=0;f<r;++f)for(let p=0;p<i[f];++p)l[d*2]=f,l[d*2+1]=p,c[d]=s[d],++d;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$(t,e){const n=St("int32",t.length);for(let r=0;r<t.length;++r)n[r]=iv(t[r]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O$=Ze((t,e)=>t-e),t3=Xg((t,e,n,r)=>({real:t-n,imag:e-r})),ex=ot(ji,O$,t3),n3={kernelName:ji,backendName:"cpu",kernelFunc:ex};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=de(n,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),a=new Array(t.rank);for(let l=0;l<a.length;l++)a[l]=o[l]%t.shape[l];const i=t.locToIndex(a);r.values[s]=t.values[i]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cl=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function L$(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const i=r-n+1,l=e-n+1,c=Math.log(i),u=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*u*(i-u)/i)*Math.sign(l-i/2),f=Math.max(n,Math.floor(e-l*u/i+d)),p=Math.min(r,Math.floor(e+(i-l)*u/i+d));L$(t,e,f,p)}const s=t[e];let o=n,a=r;for(Qn(t,n,e),Cl(t[r],s)>0&&Qn(t,n,r);o<a;){for(Qn(t,o,a),o++,a--;Cl(t[o],s)<0;)o=o+1;for(;Cl(t[a],s)>0;)a=a-1}Cl(t[n],s)===0?Qn(t,n,a):(a=a+1,Qn(t,a,r)),a<=e&&(n=a+1),e<=a&&(r=a-1)}}function B$(t,e,n,r,s){const o=e[e.length-1],[a,i]=[t.length/o,o],l=Je(n,a*r),c=Je("int32",a*r);for(let d=0;d<a;d++){const f=d*i,p=t.subarray(f,f+i);let h=new Array(p.length);p.forEach((y,w)=>h[w]={value:y,index:w}),r<h.length&&(L$(h,r),h=h.slice(0,r)),s&&h.sort(Cl);const g=d*r,m=l.subarray(g,g+r),x=c.subarray(g,g+r);for(let y=0;y<r;y++)m[y]=h[y].value,x[y]=h[y].index}const u=e.slice();return u[u.length-1]=r,[de(u,n,l),de(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(t,e,n,r){const s=ge(e,n)[0],o=[1,n[0],1];for(let h=0;h<s;h++)o[0]*=n[h];o[1]=n[s];for(let h=s+1;h<n.length;h++)o[2]*=n[h];const a={},i=new Int32Array(n[s]),l=new et(o,r,t),c=[],u=o[0]===1&&o[2]===1;for(let h=0;h<n[s];h++){let g;if(u)g=t[h].toString();else{const m=[];for(let x=0;x<o[0];x++)for(let y=0;y<o[2];y++)m.push(l.get(x,h,y));g=m.join(",")}if(a[g]!==void 0)i[h]=a[g];else{const m=Object.keys(a).length;a[g]=m,i[h]=m,c.push(h)}}const d=o.slice();d[1]=Object.keys(a).length;const f=new et(d,r);c.forEach((h,g)=>{for(let m=0;m<o[0];m++)for(let x=0;x<o[2];x++)f.set(l.get(m,h,x),m,g,x)});const p=n.slice();return p[s]=d[1],{outputValues:f.values,outputShape:p,indices:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var r3=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",simpleAbsImpl:e$,addImpl:t$,bincountImpl:Yg,bincountReduceImpl:n$,ceilImpl:r$,concatImpl:s$,equalImpl:o$,expImpl:i$,expm1Impl:c$,floorImpl:u$,gatherNdImpl:d$,gatherV2Impl:f$,greaterImpl:p$,greaterEqualImpl:h$,lessImpl:m$,lessEqualImpl:g$,linSpaceImpl:x$,logImpl:y$,maxImpl:v$,maximumImpl:w$,minimumImpl:$$,multiplyImpl:Qg,negImpl:b$,notEqualImpl:C$,prodImpl:k$,rangeImpl:S$,rsqrtImpl:I$,sigmoidImpl:HP,sliceImpl:T$,sparseFillEmptyRowsImpl:N$,sparseReshapeImpl:R$,sparseSegmentReductionImpl:Jg,sqrtImpl:qP,squaredDifferenceImpl:D$,stridedSliceImpl:F$,stringNGramsImpl:A$,stringSplitImpl:_$,stringToHashBucketFastImpl:P$,subImpl:O$,tileImpl:M$,topKImpl:B$,transposeImpl:Zg,uniqueImpl:V$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */cg("cpu",()=>new yf,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$=be(ii,t=>t>=0?t:Math.exp(t)-1),s3={kernelName:ii,backendName:"cpu",kernelFunc:W$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r;ne([s],"leakyRelu");const a=L(s.shape),i=n.data.get(s.dataId).values,l=Je("float32",a);for(let c=0;c<i.length;c++)l[c]=i[c]<0?o*i[c]:i[c];return n.makeTensorInfo(s.shape,"float32",l)}const o3={kernelName:_u,backendName:"cpu",kernelFunc:z$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3=Ze((t,e)=>t<0?e*t:t);function U$(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e;ne([r,s],"prelu");const o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,[i,l]=a3(r.shape,s.shape,o,a,"float32");return n.makeTensorInfo(l,"float32",i)}const i3={kernelName:Ju,backendName:"cpu",kernelFunc:U$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G$=be(_i,t=>Math.max(0,t)),l3={kernelName:_i,backendName:"cpu",kernelFunc:G$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H$=be(Pi,t=>Math.min(Math.max(0,t),6)),c3={kernelName:Pi,backendName:"cpu",kernelFunc:H$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tx(t,e,n,r,s){if(n==="linear")return Bn({inputs:{x:e},backend:t});if(n==="relu")return G$({inputs:{x:e},backend:t});if(n==="elu")return W$({inputs:{x:e},backend:t});if(n==="relu6")return H$({inputs:{x:e},backend:t});if(n==="prelu")return U$({inputs:{x:e,alpha:r},backend:t});if(n==="leakyrelu")return z$({inputs:{x:e},backend:t,attrs:{alpha:s}});if(n==="sigmoid")return E$({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Le(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:o}=r,a=L(s.shape),i=em(o,a),l=L(i);S(a===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const c=n.data.get(s.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;u.shape=i,d.shape=i}return{dataId:s.dataId,shape:i,dtype:s.dtype}}const u3={kernelName:rd,backendName:"cpu",kernelFunc:Le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:a,transposeB:i}=r;ne([s,o],"matMul");const l=s.shape.length,c=o.shape.length,u=a?s.shape[l-2]:s.shape[l-1],d=i?o.shape[c-1]:o.shape[c-2],f=a?s.shape[l-1]:s.shape[l-2],p=i?o.shape[c-2]:o.shape[c-1],h=s.shape.slice(0,-2),g=o.shape.slice(0,-2),m=L(h),x=L(g),y=m===x||m===1||x===1;S(l>=2&&c>=2&&y,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${g}).`);const v=(m>x?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([f,p]);S(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${a} and transposeB=${i} must match.`);const $=a?[m,u,f]:[m,f,u],b=i?[x,p,d]:[x,d,p],C=Le({inputs:{x:s},backend:n,attrs:{shape:$}}),I=Le({inputs:{x:o},backend:n,attrs:{shape:b}}),E=a?C.shape[1]:C.shape[2],T=a?C.shape[2]:C.shape[1],D=i?I.shape[1]:I.shape[2],F=Math.max(m,x),A=n.data.get(C.dataId).values,P=n.data.get(I.dataId).values,M=ae(C.shape),O=ae(I.shape),[U,B,G]=a?[M[0],1,M[1]]:[M[0],M[1],1],[j,_,V]=i?[1,O[1],O[0]]:[O[1],1,O[0]],W=T*D,K=de([F,T,D],C.dtype),q=K.values,Y=n.blockSize;for(let J=0;J<F;J++)for(let se=0;se<T;se+=Y)for(let oe=0;oe<D;oe+=Y)for(let ue=0;ue<E;ue+=Y){const pe=Math.min(se+Y,T),we=Math.min(oe+Y,D),Be=Math.min(ue+Y,E);for(let Te=se;Te<pe;Te++)for(let ke=oe;ke<we;ke++){let Se=0;for(let Ne=ue;Ne<Be;Ne++){const Ge=Math.min(J,m-1)*U,zn=Math.min(J,x-1)*V,at=A[Ge+Te*B+Ne*G],In=P[Ne*j+ke*_+zn];Se+=at*In}q[J*W+(Te*D+ke)]+=Se}}return n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(v,K.dtype,K.values)}const d3={kernelName:ru,backendName:"cpu",kernelFunc:j$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f3(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:a,preluActivationWeights:i}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;let f,p,h;const g=[];f=j$({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:c},backend:n}),a&&(p=bl({inputs:{a:f,b:a},backend:n}),g.push(f),f=p),u&&(h=tx(n,f,u,i,d),g.push(f),f=h);for(const x of g)n.disposeIntermediateTensorInfo(x);return f}const p3={kernelName:Qi,backendName:"cpu",kernelFunc:f3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h3=be(qa,t=>Math.acos(t)),m3={kernelName:qa,backendName:"cpu",kernelFunc:h3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g3=be(Xa,t=>Math.acosh(t)),x3={kernelName:Xa,backendName:"cpu",kernelFunc:g3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3(t){const{inputs:e,backend:n}=t,r=e;ne(e,"addN");const s=r.map(i=>n.data.get(i.dataId).values),o=de(r[0].shape,r[0].dtype),a=o.values;for(let i=0;i<r.length;i++){const l=s[i];for(let c=0;c<a.length;c++)a[c]+=l[c]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}const v3={kernelName:Yc,backendName:"cpu",kernelFunc:y3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;ne(s,"all");const i=ge(o,s.shape);let l=i;const c=Ye(l,s.shape.length);let u=s;c!=null&&(u=Zt({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Qe(l.length,s.shape.length)),ft("all",l,u.shape.length);const[d,f]=dt(u.shape,l),p=L(f),h=ut(L(d),u.dtype),g=n.data.get(u.dataId).values;for(let x=0;x<h.length;++x){const y=x*p;let w=g[y];for(let v=0;v<p;++v){const $=g[y+v];w=w&&$}h[x]=w}c!=null&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(d,u.dtype,h);if(a){const x=tt(d,i),y=Le({inputs:{x:m},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(m),y}return m}const $3={kernelName:Qc,backendName:"cpu",kernelFunc:w3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;ne(s,"any");const i=ge(o,s.shape);let l=i;const c=Ye(l,s.shape.length);let u=s;c!=null&&(u=Zt({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Qe(l.length,s.shape.length)),ft("any",l,u.shape.length);const[d,f]=dt(u.shape,l),p=L(f),h=ut(L(d),u.dtype),g=n.data.get(u.dataId).values;for(let x=0;x<h.length;++x){const y=x*p;let w=g[y];for(let v=0;v<p;++v){const $=g[y+v];w=w||$}h[x]=w}c!=null&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(d,u.dtype,h);if(a){const x=tt(d,i),y=Le({inputs:{x:m},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(m),y}return m}const C3={kernelName:Zc,backendName:"cpu",kernelFunc:b3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;ne(s,"argMax");let a=ge(o,s.shape);const i=Ye(a,s.shape.length);let l=s;const c=[];i!=null&&(l=Zt({inputs:{x:s},backend:n,attrs:{perm:i}}),c.push(l),a=Qe(a.length,l.shape.length)),a=[a[0]],ft("argMax",a,l.shape.length);const[u,d]=dt(l.shape,a),f=L(u),p=ut(f,"int32"),h=L(d),g=n.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const x=m*h;let y=g[x],w=0;for(let v=0;v<h;++v){const $=g[x+v];$>y&&(y=$,w=v)}p[m]=w}return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.makeTensorInfo(u,"int32",p)}const S3={kernelName:Jc,backendName:"cpu",kernelFunc:k3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;ne(s,"argMin");let a=ge(o,s.shape);const i=Ye(a,s.shape.length);let l=s;const c=[];i!=null&&(l=Zt({inputs:{x:s},backend:n,attrs:{perm:i}}),c.push(l),a=Qe(a.length,l.shape.length)),a=[a[0]],ft("argMin",a,l.shape.length);const[u,d]=dt(l.shape,a),f=L(u),p=ut(f,"int32"),h=L(d),g=n.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const x=m*h;let y=g[x],w=0;for(let v=0;v<h;++v){const $=g[x+v];$<y&&(y=$,w=v)}p[m]=w}return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.makeTensorInfo(u,"int32",p)}const E3={kernelName:eu,backendName:"cpu",kernelFunc:I3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T3=be(Ya,t=>Math.asin(t)),N3={kernelName:Ya,backendName:"cpu",kernelFunc:T3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R3=be(Qa,t=>Math.asinh(t)),D3={kernelName:Qa,backendName:"cpu",kernelFunc:R3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F3=be(Za,t=>Math.atan(t)),A3={kernelName:Za,backendName:"cpu",kernelFunc:F3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _3=Ze((t,e)=>Math.atan2(t,e)),P3=ot(ei,_3),O3={kernelName:ei,backendName:"cpu",kernelFunc:P3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M3=be(Ja,t=>Math.atanh(t)),L3={kernelName:Ja,backendName:"cpu",kernelFunc:M3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nx(t,e,n,r,s,o){const a=s.strideHeight,i=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,d=s.effectiveFilterWidth,f=s.padInfo.top,p=s.padInfo.left,h=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=de(s.outShape,n),m=g.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],w=s.outShape[3];for(let v=0;v<s.batchSize;++v){const $=v*x,b=v*r[0];for(let C=0;C<s.inChannels;++C)for(let I=0;I<s.outHeight;++I){const E=I*a-f,T=Math.max(0,E),D=Math.min(s.inHeight,u+E),F=$+I*y;for(let A=0;A<s.outWidth;++A){const P=A*i-p,M=Math.max(0,P),O=Math.min(s.inWidth,d+P);let U=h,B=0,G=0;for(let _=T;_<D;_+=l){const V=b+_*r[1];for(let W=M;W<O;W+=c){const K=V+W*r[2],q=t[K+C];o==="max"&&q>U?U=q:o==="avg"&&(B+=q,G++)}if(isNaN(U))break}const j=F+A*w+C;m[j]=o==="avg"?B/G:U}}}return g}function K$(t,e,n,r,s=!1,o=!1){const a=de(r.outShape,"int32"),i=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,f=r.effectiveFilterWidth,p=r.padInfo.top,h=r.padInfo.left,g=de(e,n,t);for(let m=0;m<r.batchSize;++m)for(let x=0;x<r.inChannels;++x)for(let y=0;y<r.outHeight;++y){const w=y*i-p;let v=w;for(;v<0;)v+=c;const $=Math.min(r.inHeight,d+w);for(let b=0;b<r.outWidth;++b){const C=b*l-h;let I=C;for(;I<0;)I+=u;const E=Math.min(r.inWidth,f+C);let T=Number.NEGATIVE_INFINITY,D=-1;for(let F=v;F<$;F+=c){const A=F-w;for(let P=I;P<E;P+=u){const M=P-C,O=g.get(m,F,P,x);O>T&&(T=O,s?D=o?((m*r.inHeight+F)*r.inWidth+P)*r.inChannels+x:(F*r.inWidth+P)*r.inChannels+x:D=A*f+M)}}a.set(D,m,y,b,x)}}return a}function q$(t,e,n,r,s,o){const a=s.strideDepth,i=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,d=s.dilationWidth,f=s.effectiveFilterDepth,p=s.effectiveFilterHeight,h=s.effectiveFilterWidth,g=s.padInfo.front,m=s.padInfo.top,x=s.padInfo.left,y=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=de(s.outShape,n),v=w.values,$=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],b=s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let E=0;E<s.batchSize;++E){const T=E*$,D=E*r[0];for(let F=0;F<s.inChannels;++F)for(let A=0;A<s.outDepth;++A){const P=A*a-g;let M=P;for(;M<0;)M+=c;const O=Math.min(s.inDepth,f+P),U=T+A*b;for(let B=0;B<s.outHeight;++B){const G=B*i-m;let j=G;for(;j<0;)j+=u;const _=Math.min(s.inHeight,p+G),V=U+B*C;for(let W=0;W<s.outWidth;++W){const K=W*l-x;let q=K;for(;q<0;)q+=d;const Y=Math.min(s.inWidth,h+K),J=V+W*I;let se=y,oe=0,ue=0;for(let we=M;we<O;we+=c){const Be=D+we*r[1];for(let Te=j;Te<_;Te+=u){const ke=Be+Te*r[2];for(let Se=q;Se<Y;Se+=d){const Ne=ke+Se*r[3],Ge=t[Ne+F];if(o==="max"&&Ge>se?se=Ge:o==="avg"&&(oe+=Ge,ue++),isNaN(se))break}if(isNaN(se))break}if(isNaN(se))break}const pe=J+F;v[pe]=o==="avg"?oe/ue:se}}}}return w}function B3(t,e){const n=de(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.front,p=e.padInfo.top,h=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let m=0;m<e.inChannels;++m)for(let x=0;x<e.outDepth;++x){const y=x*r-f;let w=y;for(;w<0;)w+=a;const v=Math.min(e.inDepth,c+y);for(let $=0;$<e.outHeight;++$){const b=$*s-p;let C=b;for(;C<0;)C+=i;const I=Math.min(e.inHeight,u+b);for(let E=0;E<e.outWidth;++E){const T=E*o-h;let D=T;for(;D<0;)D+=l;const F=Math.min(e.inWidth,d+T);let A=Number.NEGATIVE_INFINITY,P=-1;for(let M=w;M<v;M+=a){const O=M-y;for(let U=C;U<I;U+=i){const B=U-b;for(let G=D;G<F;G+=l){const j=G-T,_=t.get(g,M,U,G,m);_>=A&&(A=_,P=O*u*d+B*u+j)}}}n.set(P,g,x,$,E,m)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;ne(s,"avgPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,c=1;S(vt(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const u=hn(s.shape,o,a,c,i,l);let d;if(u.filterWidth===1&&u.filterHeight===1&&Ie(u.inShape,u.outShape))d=Bn({inputs:{x:s},backend:n});else{const f=n.data.get(s.dataId).values,p=ae(s.shape),h=nx(f,s.shape,s.dtype,p,u,"avg");d=n.makeTensorInfo(u.outShape,s.dtype,h.values)}return d}const W3={kernelName:tu,backendName:"cpu",kernelFunc:V3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:c}=r;ne(s,"avgPool3d");const u=nr(s.shape,o,a,1,i,l,c),d=n.data.get(s.dataId).values,f=q$(d,s.shape,s.dtype,ae(s.shape),u,"avg");return n.makeTensorInfo(f.shape,"float32",f.values)}const U3={kernelName:nu,backendName:"cpu",kernelFunc:z3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G3(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,{filterSize:a,strides:i,pad:l,dimRoundingMode:c}=r;ne([s,o],"avgPool3DGrad");const u=nr(o.shape,a,i,1,l,c),d=u.strideDepth,f=u.strideHeight,p=u.strideWidth,h=u.filterDepth,g=u.filterHeight,m=u.filterWidth,x=u.dilationDepth,y=u.dilationHeight,w=u.dilationWidth,v=u.effectiveFilterDepth,$=u.effectiveFilterHeight,b=u.effectiveFilterWidth,C=v-1-u.padInfo.front,I=b-1-u.padInfo.left,E=$-1-u.padInfo.top,T=de(o.shape,"float32"),D=1/(h*g*m),F=n.bufferSync(s);for(let A=0;A<u.batchSize;++A)for(let P=0;P<u.inChannels;++P)for(let M=0;M<u.inDepth;++M)for(let O=0;O<u.inHeight;++O)for(let U=0;U<u.inWidth;++U){const B=M-C,G=O-E,j=U-I;let _=0;for(let V=0;V<v;V+=x){const W=(B+V)/d;if(!(W<0||W>=u.outDepth||Math.floor(W)!==W))for(let K=0;K<$;K+=y){const q=(G+K)/f;if(!(q<0||q>=u.outHeight||Math.floor(q)!==q))for(let Y=0;Y<b;Y+=w){const J=(j+Y)/p;if(J<0||J>=u.outWidth||Math.floor(J)!==J)continue;_+=F.get(A,W,q,J,P)}}}T.set(_*D,A,M,O,U,P)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const H3={kernelName:um,backendName:"cpu",kernelFunc:G3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,a=o;ne([s,o],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=r,u=hn(a.shape,i,l,1,c),d=u.strideHeight,f=u.strideWidth,p=u.filterHeight,h=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,x=u.effectiveFilterHeight,y=u.effectiveFilterWidth,w=y-1-u.padInfo.left,v=x-1-u.padInfo.top,$=de(a.shape,"float32"),b=1/(p*h),C=n.data.get(s.dataId).values,I=de(s.shape,"float32",C);for(let E=0;E<u.batchSize;++E)for(let T=0;T<u.inChannels;++T)for(let D=0;D<u.inHeight;++D)for(let F=0;F<u.inWidth;++F){const A=D-v,P=F-w;let M=0;for(let O=0;O<x;O+=g){const U=(A+O)/d;if(!(U<0||U>=u.outHeight||Math.floor(U)!==U))for(let B=0;B<y;B+=m){const G=(P+B)/f;if(G<0||G>=u.outWidth||Math.floor(G)!==G)continue;M+=I.get(E,U,G,T)}}$.set(M*b,E,D,F,T)}return n.makeTensorInfo($.shape,$.dtype,$.values)}const K3={kernelName:cm,backendName:"cpu",kernelFunc:j3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,scale:o,offset:a,mean:i,variance:l}=e;S(i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ne([s,i,l,o,a],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);const u=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,f=n.data.get(l.dataId).values,p=o?n.data.get(o.dataId).values:new Float32Array([1]),h=a?n.data.get(a.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=h.length,x=p.length,y=f.length,w=d.length;let v=0,$=0,b=0,C=0;for(let I=0;I<u.length;++I)g[I]=h[v++]+(u[I]-d[$++])*p[b++]/Math.sqrt(f[C++]+c),v>=m&&(v=0),$>=w&&($=0),b>=x&&(b=0),C>=y&&(C=0);return n.makeTensorInfo(s.shape,s.dtype,g)}const X3={kernelName:Nu,backendName:"cpu",kernelFunc:q3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:a}=r;ne([s],"batchToSpaceND");const i=o.reduce((x,y)=>x*y),l=vl(s.shape,o,i),c=wl(l.length,o.length),u=$l(s.shape,o,i),d=Rg(a,o.length),f=Dg(u,a,o.length),p=Le({inputs:{x:s},backend:n,attrs:{shape:l}}),h=Zt({inputs:{x:p},backend:n,attrs:{perm:c}}),g=Le({inputs:{x:h},backend:n,attrs:{shape:u}}),m=As({inputs:{x:g},backend:n,attrs:{begin:d,size:f}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),m}const Q3={kernelName:su,backendName:"cpu",kernelFunc:Y3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:a}=r,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,c=Yg(i,l,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,c)}const J3={kernelName:ou,backendName:"cpu",kernelFunc:Z3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eO(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,i=ye(Array.from(o),Array.from(a));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const tO={kernelName:au,backendName:"cpu",kernelFunc:eO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nO=be(ri,(t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),rO={kernelName:ri,backendName:"cpu",kernelFunc:nO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sO=t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(L(e.shape)),s=n.data.get(e.dataId),o=s.complexTensorInfos.real,a=s.complexTensorInfos.imag,i=n.data.get(o.dataId).values,l=n.data.get(a.dataId).values;for(let c=0;c<i.length;c++){const u=i[c],d=l[c];r[c]=Math.hypot(u,d)}return n.makeOutput(r,e.shape,"float32")},oO={kernelName:lu,backendName:"cpu",kernelFunc:sO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lo(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.data.get(r.dataId).complexTensorInfos.imag,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}const aO={kernelName:Au,backendName:"cpu",kernelFunc:Lo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bo(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=ge(s,e[0].shape)[0];let a=Ln(e.map(g=>g.shape),o);if(L(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const i=e.filter(g=>L(g.shape)>0);if(i.length===1)return Bn({inputs:{x:i[0]},backend:n});const l=i.map(g=>g.shape);if(Eg(l,o),i[0].dtype==="complex64"){const g=i.map(v=>Fs({inputs:{input:v},backend:n})),m=i.map(v=>Lo({inputs:{input:v},backend:n})),x=Bo({inputs:g,backend:n,attrs:{axis:o}}),y=Bo({inputs:m,backend:n,attrs:{axis:o}}),w=Ht({inputs:{real:x,imag:y},backend:n});return g.forEach(v=>n.disposeIntermediateTensorInfo(v)),m.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(y),w}const c=i.map(g=>{const m=L(g.shape.slice(o));return Le({inputs:{x:g},backend:n,attrs:{shape:[-1,m]}})}),u=c.map(g=>({vals:n.data.get(g.dataId).values,shape:g.shape}));a=Ln(c.map(g=>g.shape),1);const d=c[0].shape[0]===1,f=s$(u,a,e[0].dtype,d),p=Ln(i.map(g=>g.shape),o),h=n.makeTensorInfo(p,e[0].dtype,f);return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),h}const iO={kernelName:cu,backendName:"cpu",kernelFunc:Bo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=r;ne([s,o],"conv2d");const d=rr(l),f=st(s.shape,o.shape,a,c,i,u,!1,d),p=f.filterHeight,h=f.filterWidth,g=f.dilationHeight,m=f.dilationWidth,x=f.padInfo.left,y=f.padInfo.top,w=f.dataFormat==="channelsLast",v=new et(f.outShape,s.dtype),$=ae(s.shape),b=ae(o.shape),C=$[0],I=w?$[1]:$[2],E=w?$[2]:1,T=w?1:$[1],D=v.strides[0],F=w?v.strides[1]:v.strides[2],A=w?v.strides[2]:1,P=w?1:v.strides[1],M=n.data.get(s.dataId).values,O=n.data.get(o.dataId).values,U=v.values;for(let B=0;B<f.batchSize;++B){const G=B*C,j=B*D;for(let _=0;_<f.outHeight;++_){const V=j+_*F,W=_*f.strideHeight-y;for(let K=0;K<p;++K){const q=W+K*g;if(q<0||q>=f.inHeight)continue;const Y=K*b[0],J=G+q*I;for(let se=0;se<f.outWidth;++se){const oe=V+se*A,ue=se*f.strideWidth-x;for(let pe=0;pe<h;++pe){const we=ue+pe*m;if(we<0||we>=f.inWidth)continue;const Be=Y+pe*b[1],Te=J+we*E;let ke=Be;for(let Se=0;Se<f.inChannels;++Se){const Ne=M[Te+Se*T];for(let Ge=0;Ge<f.outChannels;++Ge)U[oe+Ge*P]+=Ne*O[ke+Ge];ke+=f.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,U)}const lO={kernelName:uu,backendName:"cpu",kernelFunc:X$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:a,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;ne([s,o],"conv2dBackpropFilter");const d=rr(l),f=st(s.shape,u,a,1,i,c,!1,d),{strideHeight:p,strideWidth:h,filterHeight:g,filterWidth:m}=f,x=f.dataFormat==="channelsLast",y=new et(f.filterShape,"float32"),w=f.padInfo.left,v=f.padInfo.top,$=n.data.get(s.dataId).values,b=n.data.get(o.dataId).values,C=new et(s.shape,s.dtype,$),I=new et(o.shape,o.dtype,b);for(let E=0;E<g;++E){const T=Math.max(0,Math.ceil((v-E)/p)),D=Math.min(f.outHeight,(f.inHeight+v-E)/p);for(let F=0;F<m;++F){const A=Math.max(0,Math.ceil((w-F)/h)),P=Math.min(f.outWidth,(f.inWidth+w-F)/h);for(let M=0;M<f.inChannels;++M)for(let O=0;O<f.outChannels;++O){let U=0;for(let B=0;B<f.batchSize;++B)for(let G=T;G<D;++G){const j=E+G*p-v;for(let _=A;_<P;++_){const V=F+_*h-w;x?U+=C.get(B,j,V,M)*I.get(B,G,_,O):U+=C.get(B,M,j,V)*I.get(B,O,G,_)}}y.set(U,E,F,M,O)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const uO={kernelName:du,backendName:"cpu",kernelFunc:cO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dO(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:a,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=r;ne([s,o],"conv2dBackpropInput");const d=ae(o.shape),f=ae(s.shape);let p=rr(c);const h=st(a,o.shape,i,1,l,u,!1,p),g=new et(h.inShape,"float32"),m=g.values,x=n.data.get(s.dataId).values,y=n.data.get(o.dataId).values,[w,v,$]=d,{batchSize:b,filterHeight:C,filterWidth:I,inChannels:E,inHeight:T,inWidth:D,outChannels:F,outHeight:A,outWidth:P,strideHeight:M,strideWidth:O}=h;p=h.dataFormat;const U=C-1-h.padInfo.top,B=I-1-h.padInfo.left,G=p==="channelsLast",j=g.strides[0],_=G?g.strides[1]:g.strides[2],V=G?g.strides[2]:1,W=G?1:g.strides[1],K=f[0],q=G?f[1]:f[2],Y=G?f[2]:1,J=G?1:f[1];for(let se=0;se<b;++se)for(let oe=0;oe<E;++oe)for(let ue=0;ue<T;++ue){const pe=ue-U,we=Math.max(0,Math.ceil(pe/M)),Be=Math.min(A,(C+pe)/M);for(let Te=0;Te<D;++Te){const ke=Te-B,Se=Math.max(0,Math.ceil(ke/O)),Ne=Math.min(P,(I+ke)/O);let Ge=0;for(let at=we;at<Be;++at){const In=at*M-pe;for(let Kt=Se;Kt<Ne;++Kt){const Xr=Kt*O-ke,gn=K*se+q*at+Y*Kt,Un=w*(C-1-In)+v*(I-1-Xr)+$*oe;for(let lr=0;lr<F;++lr){const cr=x[gn+J*lr],ur=y[Un+lr];Ge+=cr*ur}}}const zn=j*se+_*ue+V*Te+W*oe;m[zn]=Ge}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const fO={kernelName:fu,backendName:"cpu",kernelFunc:dO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:i,dilations:l}=r;ne([s,o],"conv3d");const c=Vr(s.shape,o.shape,a,l,i),{filterDepth:u,filterHeight:d,filterWidth:f,dilationDepth:p,dilationHeight:h,dilationWidth:g,padInfo:m}=c,x=m.front,y=m.left,w=m.top,v=new et(c.outShape,s.dtype),$=n.data.get(s.dataId).values,b=n.data.get(o.dataId).values,C=v.values,I=ae(s.shape),E=ae(o.shape);for(let T=0;T<c.batchSize;++T){const D=T*I[0],F=T*v.strides[0];for(let A=0;A<c.outDepth;++A){const P=F+A*v.strides[1],M=A*c.strideDepth-x;for(let O=0;O<u;++O){const U=M+O*p;if(U<0||U>=c.inDepth)continue;const B=O*E[0],G=D+U*I[1];for(let j=0;j<c.outHeight;++j){const _=P+j*v.strides[2],V=j*c.strideHeight-w;for(let W=0;W<d;++W){const K=V+W*h;if(K<0||K>=c.inHeight)continue;const q=B+W*E[1],Y=G+K*I[2];for(let J=0;J<c.outWidth;++J){const se=_+J*c.outChannels,oe=J*c.strideWidth-y;for(let ue=0;ue<f;++ue){const pe=oe+ue*g;if(pe<0||pe>=c.inWidth)continue;const we=q+ue*E[2],Be=Y+pe*c.inChannels;let Te=we;for(let ke=0;ke<c.inChannels;++ke){const Se=$[Be+ke];for(let Ne=0;Ne<c.outChannels;++Ne)C[se+Ne]+=Se*b[Te+Ne];Te+=c.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const hO={kernelName:pu,backendName:"cpu",kernelFunc:pO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:a,pad:i,filterShape:l}=r;ne([s,o],"conv3dBackpropFilterV2");const c=ae(s.shape),u=ae(o.shape),d=Vr(s.shape,l,a,1,i),f=d.strideDepth,p=d.strideHeight,h=d.strideWidth,g=d.filterDepth,m=d.filterHeight,x=d.filterWidth,y=new et(d.filterShape,"float32"),w=y.values,[v,$,b,C]=y.strides,I=n.data.get(o.dataId).values,[E,T,D,F]=u,A=n.data.get(s.dataId).values,[P,M,O,U]=c,B=d.padInfo.front,G=d.padInfo.left,j=d.padInfo.top;for(let _=0;_<g;++_){const V=Math.max(0,Math.ceil((B-_)/f)),W=Math.min(d.outDepth,(d.inDepth+B-_)/f),K=_*v;for(let q=0;q<m;++q){const Y=Math.max(0,Math.ceil((j-q)/p)),J=Math.min(d.outHeight,(d.inHeight+j-q)/p),se=q*$+K;for(let oe=0;oe<x;++oe){const ue=Math.max(0,Math.ceil((G-oe)/h)),pe=Math.min(d.outWidth,(d.inWidth+G-oe)/h),we=oe*b+se;for(let Be=0;Be<d.inChannels;++Be){const Te=Be*C+we;for(let ke=0;ke<d.outChannels;++ke){let Se=0;for(let Ne=0;Ne<d.batchSize;++Ne){const Ge=Ne*P,zn=Ne*E;for(let at=V;at<W;++at){const Kt=(_+at*f-B)*M+Ge,Xr=at*T+zn;for(let gn=Y;gn<J;++gn){const lr=(q+gn*p-j)*O+Kt,cr=gn*D+Xr;for(let ur=ue;ur<pe;++ur){const Uf=(oe+ur*h-G)*U+lr,Gf=ur*F+cr;Se+=A[Uf+Be]*I[Gf+ke]}}}}w[Te+ke]=Se}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const gO={kernelName:dm,backendName:"cpu",kernelFunc:mO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xO(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{pad:a,strides:i,inputShape:l}=r;ne([s],"conv3dBackpropInputV2");const c=ae(s.shape),u=ae(o.shape),d=Vr(l,o.shape,i,1,a),f=new et(d.inShape,"float32"),p=f.values,[h,g,m,x]=f.strides,y=n.data.get(s.dataId).values,[w,v,$,b]=c,C=n.data.get(o.dataId).values,[I,E,T,D]=u,{batchSize:F,filterDepth:A,filterHeight:P,filterWidth:M,inChannels:O,inDepth:U,inHeight:B,inWidth:G,outChannels:j,outDepth:_,outHeight:V,outWidth:W,strideDepth:K,strideHeight:q,strideWidth:Y}=d,J=A-1-d.padInfo.front,se=P-1-d.padInfo.top,oe=M-1-d.padInfo.left;for(let ue=0;ue<F;++ue)for(let pe=0;pe<O;++pe)for(let we=0;we<U;++we){const Be=we-J,Te=Math.max(0,Math.ceil(Be/K)),ke=Math.min(_,(A+Be)/K);for(let Se=0;Se<B;++Se){const Ne=Se-se,Ge=Math.max(0,Math.ceil(Ne/q)),zn=Math.min(V,(P+Ne)/q);for(let at=0;at<G;++at){const In=at-oe,Kt=Math.max(0,Math.ceil(In/Y)),Xr=Math.min(W,(M+In)/Y);let gn=0;for(let Un=Te;Un<ke;++Un){const lr=Un*K-Be;for(let cr=Ge;cr<zn;++cr){const ur=cr*q-Ne;for(let Zo=Kt;Zo<Xr;++Zo){const Uf=Zo*Y-In,Gf=w*ue+v*Un+$*cr+b*Zo,UC=I*(A-1-lr)+E*(P-1-ur)+T*(M-1-Uf)+D*pe;for(let Ll=0;Ll<j;++Ll){const GC=y[Gf+Ll],HC=C[UC+Ll];gn+=GC*HC}}}}p[h*ue+g*we+m*Se+x*at+pe]=gn}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const yO={kernelName:hu,backendName:"cpu",kernelFunc:xO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vO=be(si,t=>Math.cos(t)),wO={kernelName:si,backendName:"cpu",kernelFunc:vO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $O=be(oi,t=>Math.cosh(t)),bO={kernelName:oi,backendName:"cpu",kernelFunc:$O};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:a}=e,{cropSize:i,method:l,extrapolationValue:c}=r,[u,d,f,p]=s.shape,h=o.shape[0],[g,m]=i,x=de([h,g,m,p],"float32"),y=n.data.get(o.dataId).values,w=n.data.get(a.dataId).values,v=n.data.get(s.dataId).values,$=ae(s.shape),b=ae(x.shape);for(let C=0;C<h;C++){const I=C*4,E=y[I],T=y[I+1],D=y[I+2],F=y[I+3],A=w[C];if(A>=u)continue;const P=g>1?(D-E)*(d-1)/(g-1):0,M=m>1?(F-T)*(f-1)/(m-1):0;for(let O=0;O<g;O++){const U=g>1?E*(d-1)+O*P:.5*(E+D)*(d-1);if(U<0||U>d-1){for(let B=0;B<m;B++)for(let G=0;G<p;G++){const j=G+B*b[2]+O*b[1]+C*b[0];x.values[j]=c}continue}if(l==="bilinear"){const B=Math.floor(U),G=Math.ceil(U),j=U-B;for(let _=0;_<m;_++){const V=m>1?T*(f-1)+_*M:.5*(T+F)*(f-1);if(V<0||V>f-1){for(let Y=0;Y<p;Y++){const J=Y+_*b[2]+O*b[1]+C*b[0];x.values[J]=c}continue}const W=Math.floor(V),K=Math.ceil(V),q=V-W;for(let Y=0;Y<p;Y++){let J=Y+W*$[2]+B*$[1]+A*$[0];const se=v[J];J=Y+K*$[2]+B*$[1]+A*$[0];const oe=v[J];J=Y+W*$[2]+G*$[1]+A*$[0];const ue=v[J];J=Y+K*$[2]+G*$[1]+A*$[0];const pe=v[J],we=se+(oe-se)*q,Be=ue+(pe-ue)*q;J=Y+_*b[2]+O*b[1]+C*b[0],x.values[J]=we+(Be-we)*j}}}else for(let B=0;B<m;++B){const G=m>1?T*(f-1)+B*M:.5*(T+F)*(f-1);if(G<0||G>f-1){for(let V=0;V<p;V++){const W=V+B*b[2]+O*b[1]+C*b[0];x.values[W]=c}continue}const j=Math.round(G),_=Math.round(U);for(let V=0;V<p;V++){const W=V+j*$[2]+_*$[1]+A*$[0],K=V+B*b[2]+O*b[1]+C*b[0];x.values[K]=v[W]}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const kO={kernelName:gu,backendName:"cpu",kernelFunc:CO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:a,reverse:i}=r;ne(s,"cumsum");const l=Ye([o],s.shape.length);let c=s;l!=null&&(c=Zt({inputs:{x:s},backend:n,attrs:{perm:l}}));const u=Qe(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=zt(c.dtype,"int32"),f=ut(L(c.shape),d),p=n.data.get(c.dataId).values,h=c.shape[c.shape.length-1],g=i?(x,y)=>x+h-y-1:(x,y)=>x+y;for(let x=0;x<p.length;x+=h)for(let y=0;y<h;y++){const w=g(x,y);if(y===0)f[w]=a?0:p[w];else{const v=g(x,y-1);f[w]=a?p[v]+f[v]:p[w]+f[v]}}const m=n.makeTensorInfo(c.shape,d,f);if(l!=null){const x=Yd(l),y=Zt({inputs:{x:m},backend:n,attrs:{perm:x}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),y}return m}const IO={kernelName:mu,backendName:"cpu",kernelFunc:SO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:a,binaryOutput:i}=r;if(s.shape.length===1){const l=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values,u=Yg(l,c,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,u)}else if(s.shape.length===2){const l=n.bufferSync(s),c=n.bufferSync(o),u=n$(l,c,a,i);return n.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const TO={kernelName:xu,backendName:"cpu",kernelFunc:EO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:a}=r;S(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const i=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],d=l*o,f=c*o,p=u/(o*o),h=n.data.get(s.dataId).values,g=new Float32Array(i*d*f*p);let m=0;for(let x=0;x<i;++x)for(let y=0;y<d;++y){const w=Math.floor(y/o),v=y%o;for(let $=0;$<f;++$){const b=Math.floor($/o),C=$%o,I=(v*o+C)*p;for(let E=0;E<p;++E){const D=E+I+u*(b+c*(w+l*x));g[m++]=h[D]}}}return n.makeTensorInfo([i,d,f,p],s.dtype,g)}const RO={kernelName:yu,backendName:"cpu",kernelFunc:NO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:i,dilations:l,dimRoundingMode:c}=r;ne([s,o],"depthwiseConv2DNative");const u=ae(s.shape),d=ae(o.shape);let f=l;f==null&&(f=[1,1]),S(vt(a,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${f}'`);const p=st(s.shape,o.shape,a,f,i,c,!0),{filterHeight:h,filterWidth:g,dilationHeight:m,dilationWidth:x,padInfo:y}=p,w=y.left,v=y.top,$=p.outChannels/p.inChannels,b=new et(p.outShape,s.dtype),C=n.data.get(s.dataId).values,I=n.data.get(o.dataId).values,E=b.values;for(let T=0;T<p.batchSize;++T){const D=T*u[0],F=T*b.strides[0];for(let A=0;A<p.outHeight;++A){const P=F+A*b.strides[1],M=A*p.strideHeight-v;for(let O=0;O<h;++O){const U=M+O*m;if(U<0||U>=p.inHeight)continue;const B=O*d[0],G=D+U*u[1];for(let j=0;j<p.outWidth;++j){const _=P+j*b.strides[2],V=j*p.strideWidth-w;for(let W=0;W<g;++W){const K=V+W*x;if(K<0||K>=p.inWidth)continue;const q=B+W*d[1],Y=G+K*p.inChannels;let J=_,se=q;for(let oe=0;oe<p.inChannels;++oe){const ue=C[Y+oe];for(let pe=0;pe<$;++pe)E[J+pe]+=ue*I[se+pe];J+=$,se+=$}}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const DO={kernelName:vu,backendName:"cpu",kernelFunc:Y$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=r;ne([s,o],"depthwiseConv2dNativeBackpropFilter");const d=st(s.shape,u,a,i,l,c,!0),{strideHeight:f,strideWidth:p,filterHeight:h,filterWidth:g}=d,m=new et(d.filterShape,"float32"),x=d.padInfo.left,y=d.padInfo.top,w=d.outChannels/d.inChannels,v=n.data.get(s.dataId).values,$=new et(s.shape,s.dtype,v),b=n.data.get(o.dataId).values,C=new et(o.shape,o.dtype,b);for(let I=0;I<h;++I){const E=Math.max(0,Math.ceil((y-I)/f)),T=Math.min(d.outHeight,(d.inHeight+y-I)/f);for(let D=0;D<g;++D){const F=Math.max(0,Math.ceil((x-D)/p)),A=Math.min(d.outWidth,(d.inWidth+x-D)/p);for(let P=0;P<d.outChannels;++P){const M=Math.trunc(P/w),O=P%w;let U=0;for(let B=0;B<d.batchSize;++B)for(let G=E;G<T;++G){const j=I+G*f-y;for(let _=F;_<A;++_){const V=D+_*p-x;U+=$.get(B,j,V,M)*C.get(B,G,_,P)}}m.set(U,I,D,M,O)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const AO={kernelName:wu,backendName:"cpu",kernelFunc:FO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _O(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=r;ne([s,o],"depthwiseConv2DNativeBackpropInput");const d=ae(s.shape),f=ae(o.shape),p=st(u,o.shape,a,i,l,c,!0),h=new et(p.inShape,"float32"),g=h.values,[m,x,y]=h.strides,w=n.data.get(s.dataId).values,[v,$,b]=d,C=n.data.get(o.dataId).values,[I,E,T]=f,{batchSize:D,filterHeight:F,filterWidth:A,inChannels:P,inHeight:M,inWidth:O,outChannels:U,outHeight:B,outWidth:G,strideHeight:j,strideWidth:_}=p,V=F-1-p.padInfo.top,W=A-1-p.padInfo.left,K=U/P;for(let q=0;q<D;++q)for(let Y=0;Y<P;++Y)for(let J=0;J<M;++J){const se=J-V,oe=Math.max(0,Math.ceil(se/j)),ue=Math.min(B,(F+se)/j);for(let pe=0;pe<O;++pe){const we=pe-W,Be=Math.max(0,Math.ceil(we/_)),Te=Math.min(G,(A+we)/_);let ke=0;for(let Se=oe;Se<ue;++Se){const Ne=Se*j-se;for(let Ge=Be;Ge<Te;++Ge){const zn=Ge*_-we,at=v*q+$*Se+b*Ge,In=I*(F-1-Ne)+E*(A-1-zn)+T*Y;for(let Kt=0;Kt<K;++Kt){const Xr=Y*K+Kt,gn=w[at+Xr],Un=C[In+Kt];ke+=gn*Un}}}g[m*q+x*J+y*pe+Y]=ke}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}const PO={kernelName:$u,backendName:"cpu",kernelFunc:_O};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OO(t){const{inputs:e,backend:n}=t,{x:r}=e,s=L(r.shape),o=n.data.get(r.dataId).values,a=de([s,s],r.dtype),i=a.values;for(let c=0;c<o.length;c++)i[c*s+c]=o[c];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,a.dtype,a.values)}const MO={kernelName:bu,backendName:"cpu",kernelFunc:OO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LO={kernelName:Cu,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s}=t,{strides:o,pad:a,dilations:i}=n,l=e,c=l.data.get(r.dataId).values,u=r.shape.length,d=l.data.get(s.dataId).values,f=s.shape.length,{batchSize:p,inHeight:h,inWidth:g,inChannels:m,outHeight:x,outWidth:y,padInfo:w,strideHeight:v,strideWidth:$,filterHeight:b,filterWidth:C,dilationHeight:I,dilationWidth:E,outShape:T}=ll(r.shape,s.shape,o,a,"NHWC",i),D=L(T),F=T.length,A=St(r.dtype,D);for(let M=0;M<p;++M)for(let O=0;O<x;++O){const U=O*v-w.top;for(let B=0;B<y;++B){const G=B*$-w.left;for(let j=0;j<m;++j){let _=Number.MIN_SAFE_INTEGER;for(let W=0;W<b;++W){const K=U+W*I;if(K>=0&&K<h)for(let q=0;q<C;++q){const Y=G+q*E;if(Y>=0&&Y<g){const J=wn([M,K,Y,j],u,ae(r.shape)),se=wn([W,q,j],f,ae(s.shape)),oe=c[J]+d[se];oe>_&&(_=oe)}}}const V=wn([M,O,B,j],F,ae(T));A[V]=_}}}return{dataId:l.write(_r(A,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BO={kernelName:pm,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:o}=t,{strides:a,pad:i,dilations:l}=n,c=e,u=un(r.shape,c.data.get(r.dataId).values),d=un(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:p,inWidth:h,inChannels:g,outHeight:m,outWidth:x,padInfo:y,strideHeight:w,strideWidth:v,filterHeight:$,filterWidth:b,dilationHeight:C,dilationWidth:I,outShape:E}=ll(r.shape,s.shape,a,i,"NHWC",l);S(o.rank===E.length,()=>`Error in ${pm}, dy must have the same rank as output ${E.length}, but got ${o.rank}`);const T=un(E,c.data.get(o.dataId).values),D=rm(s.shape,s.dtype);for(let A=0;A<f;++A)for(let P=0;P<m;++P){const M=P*w-y.top;for(let O=0;O<x;++O){const U=O*v-y.left;for(let B=0;B<g;++B){let G=Number.MIN_SAFE_INTEGER,j=0,_=0;for(let V=0;V<$;++V){const W=M+V*C;if(W>=0&&W<p)for(let K=0;K<b;++K){const q=U+K*I;if(q>=0&&q<h){const Y=u[A][W][q][B]+d[V][K][B];Y>G&&(G=Y,j=V,_=K)}}}D[j][_][B]+=T[A][P][O][B]}}}return{dataId:c.write(_r(D,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VO={kernelName:fm,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:o}=t,{strides:a,pad:i,dilations:l}=n,c=e,u=un(r.shape,c.data.get(r.dataId).values),d=un(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:p,inWidth:h,inChannels:g,outHeight:m,outWidth:x,padInfo:y,strideHeight:w,strideWidth:v,filterHeight:$,filterWidth:b,dilationHeight:C,dilationWidth:I,outShape:E}=ll(r.shape,s.shape,a,i,"NHWC",l);S(o.rank===E.length,()=>`Error in ${fm}, dy must have the same rank as output ${E.length}, but got ${o.rank}`);const T=un(E,c.data.get(o.dataId).values),D=rm(r.shape,r.dtype);for(let A=0;A<f;++A)for(let P=0;P<m;++P){const M=P*w-y.top;for(let O=0;O<x;++O){const U=O*v-y.left;for(let B=0;B<g;++B){let G=Number.MIN_SAFE_INTEGER,j=M<0?0:M,_=U<0?0:U;for(let V=0;V<$;++V){const W=M+V*C;if(W>=0&&W<p)for(let K=0;K<b;++K){const q=U+K*I;if(q>=0&&q<h){const Y=u[A][W][q][B]+d[V][K][B];Y>G&&(G=Y,j=W,_=q)}}}D[A][j][_][B]+=T[A][P][O][B]}}}return{dataId:c.write(_r(D,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;ne(s,"sum");let i;s.dtype==="bool"?i=Gr({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):i=Bn({inputs:{x:s},backend:n});const l=i.shape.length,c=ge(o,i.shape),u=Ye(c,l);let d=c,f=i;u!=null&&(f=Zt({inputs:{x:i},backend:n,attrs:{perm:u}}),d=Qe(d.length,l)),ft("sum",d,f.shape.length);const[p,h]=dt(f.shape,d),g=zt(f.dtype,"int32");let m=vf(n,p,g);const x=L(h),y=n.data.get(m.dataId).values,w=n.data.get(f.dataId).values;for(let v=0;v<y.length;++v){const $=v*x;let b=0;for(let C=0;C<x;++C)b+=w[$+C];y[v]=b}if(a){const v=tt(m.shape,c),$=m;m=Le({inputs:{x:m},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo($)}return n.disposeIntermediateTensorInfo(i),u!=null&&n.disposeIntermediateTensorInfo(f),m}const WO={kernelName:ud,backendName:"cpu",kernelFunc:kl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zO(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:a,summedDims:i,idDims:l}=zg(s,o.length);Gg(a.length,l,o);const{path:c,steps:u}=Hg(i,l),d=u.length;let f=null,p=a.length;const h=[];for(let g=0;g<d;++g){for(const m of u[g]){const{permutationIndices:x,expandDims:y}=Ug(p,l[m]);let w;jg(x)?w=o[m]:(w=Zt({inputs:{x:o[m]},backend:n,attrs:{perm:x}}),h.push(w));const v=w.shape.slice();for(let $=0;$<y.length;++$)v.splice(y[$],0,1);Ie(w.shape,v)||(w=Le({inputs:{x:w},backend:n,attrs:{shape:v}}),h.push(w)),f===null?f=w:(f=wf({inputs:{a:w,b:f},backend:n}),h.push(f))}g<d-1&&(c[g]>=0&&(f=kl({inputs:{x:f},backend:n,attrs:{axis:c[g]-(a.length-p),keepDims:!1}}),h.push(f)),p--)}for(const g of h)g!==f&&n.disposeIntermediateTensorInfo(g);return f}const UO={kernelName:ku,backendName:"cpu",kernelFunc:zO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GO(t){const{inputs:e,backend:n}=t,{dy:r,y:s}=e;ne([r,s],"eluGrad");const o=new Float32Array(L(s.shape)),a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values;for(let l=0;l<a.length;++l){const c=a[l];c>=1?o[l]=i[l]:o[l]=i[l]*(c+1)}return n.makeTensorInfo(s.shape,"float32",o)}const HO={kernelName:hm,backendName:"cpu",kernelFunc:GO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jO=_g,KO=Pg,qO=Og,XO=Mg,YO=Lg,QO=Bg,ZO=be(li,t=>{const e=Math.sign(t),n=Math.abs(t),r=1/(1+jO*n);return e*(1-((((QO*r+YO)*r+XO)*r+qO)*r+KO)*r*Math.exp(-n*n))}),JO={kernelName:li,backendName:"cpu",kernelFunc:ZO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $f(t){const{inputs:e,backend:n,attrs:r}=t,{input:s}=e,{dim:o}=r,a=s.shape.length,i=s.shape.slice();let l=o;return o<0&&(S(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),i.splice(l,0,1),Le({inputs:{x:s},backend:n,attrs:{shape:i}})}const eM={kernelName:Su,backendName:"cpu",kernelFunc:$f};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tM=Ze((t,e)=>t/e),rx=ot(ai,tM),sx={kernelName:ai,backendName:"cpu",kernelFunc:rx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(t,e,n){const r=t.shape,s=r[0],o=r[1],a=n.data.get(t.dataId),i=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,c=[s,o],u=L(c),d=Je("float32",u),f=Je("float32",u);for(let m=0;m<s;m++){const x=As({inputs:{x:i},backend:n,attrs:{begin:[m,0],size:[1,o]}}),y=As({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,o]}}),w=Ht({inputs:{real:x,imag:y},backend:n}),{real:v,imag:$}=nM(w,e,n),b=ar(v,$);for(let C=0;C<o;C++){const I=Vg(b,C);d[m*o+C]=I.real,f[m*o+C]=I.imag}n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w)}const p=n.makeTensorInfo(c,"float32",d),h=n.makeTensorInfo(c,"float32",f),g=Ht({inputs:{real:p,imag:h},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),g}function nM(t,e,n){const r=L(t.shape),s=n.data.get(t.dataId),o=n.data.get(s.complexTensorInfos.real.dataId).values,a=n.data.get(s.complexTensorInfos.imag.dataId).values;if(rM(r)){const i=ox(o,a,r,e,n),l=[t.shape[0],t.shape[1]];if(e){const c=n.makeTensorInfo(l,"float32",i.real),u=n.makeTensorInfo(l,"float32",i.imag),d=n.makeTensorInfo([],"float32",er(r,"float32")),f=Bn({inputs:{x:d},backend:n}),p=sx.kernelFunc({inputs:{a:c,b:d},backend:n}),h=sx.kernelFunc({inputs:{a:u,b:f},backend:n}),g=n.data.get(p.dataId).values,m=n.data.get(h.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),{real:g,imag:m}}return i}else{const i=ar(o,a),l=sM(i,r,e);return zw(l)}}function rM(t){return(t&t-1)==0}function ox(t,e,n,r,s){if(n===1)return{real:t,imag:e};const o=ar(t,e),a=n/2,i=Uw(o),l=i.real,c=i.imag,u=[l.length],d=s.makeTensorInfo(u,"float32",l),f=s.makeTensorInfo(u,"float32",c),p=Ht({inputs:{real:d,imag:f},backend:s}),h=Gw(o),g=h.real,m=h.imag,x=[g.length],y=s.makeTensorInfo(x,"float32",g),w=s.makeTensorInfo(x,"float32",m),v=Ht({inputs:{real:y,imag:w},backend:s}),$=ox(l,c,a,r,s),b=$.real,C=$.imag,I=[b.length],E=s.makeTensorInfo(I,"float32",b),T=s.makeTensorInfo(I,"float32",C),D=Ht({inputs:{real:E,imag:T},backend:s}),F=ox(g,m,a,r,s),A=F.real,P=F.imag,M=[A.length],O=s.makeTensorInfo(M,"float32",A),U=s.makeTensorInfo(M,"float32",P),B=Ht({inputs:{real:O,imag:U},backend:s}),G=jw(n,r),j=[G.real.length],_=s.makeTensorInfo(j,"float32",G.real),V=s.makeTensorInfo(j,"float32",G.imag),W=Ht({inputs:{real:_,imag:V},backend:s}),K=wf({inputs:{a:W,b:B},backend:s}),q=bl({inputs:{a:D,b:K},backend:s}),Y=ex({inputs:{a:D,b:K},backend:s}),J=Fs({inputs:{input:q},backend:s}),se=Fs({inputs:{input:Y},backend:s}),oe=Lo({inputs:{input:q},backend:s}),ue=Lo({inputs:{input:Y},backend:s}),pe=Bo({inputs:[J,se],backend:s,attrs:{axis:0}}),we=Bo({inputs:[oe,ue],backend:s,attrs:{axis:0}}),Be=s.data.get(pe.dataId).values,Te=s.data.get(we.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(J),s.disposeIntermediateTensorInfo(oe),s.disposeIntermediateTensorInfo(se),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(we),{real:Be,imag:Te}}function sM(t,e,n){const r=new Float32Array(e*2);for(let s=0;s<e;s++){let o=0,a=0;for(let i=0;i<e;i++){const l=Kw(s*i,e,n),c=Vg(t,i);o+=c.real*l.real-c.imag*l.imag,a+=c.real*l.imag+c.imag*l.real}n&&(o/=e,a/=e),Hw(r,o,a,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oM(t){const{inputs:e,backend:n}=t,{input:r}=e,s=L(r.shape),o=r.shape[r.shape.length-1],a=s/o,i=Le({inputs:{x:r},backend:n,attrs:{shape:[a,o]}}),l=Q$(i,!1,n),c=Le({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),c}const aM={kernelName:Iu,backendName:"cpu",kernelFunc:oM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ax(t){const{backend:e,attrs:n}=t,{shape:r,value:s,dtype:o}=n,a=o||vo(s),i=St(a,L(r));return lM(i,s,a),e.makeTensorInfo(r,a,i)}const iM={kernelName:Eu,backendName:"cpu",kernelFunc:ax};function lM(t,e,n){t.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cM={kernelName:Tu,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,s=n,o=Je(r.dtype,L(r.shape)),[a,i,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let f=0;f<a;f++){const p=f*l*i*c;for(let h=0;h<i;h++){const g=h*(l*c);for(let m=0;m<l;m++){const x=m*c;for(let y=0;y<c;y++){const w=Math.round(l-m-1),v=p+g+x+y;let $=u[v];if(w>=0&&w<l){const b=w*c,C=p+g+b+y;$=u[C]}o[v]=$}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uM=Ze((t,e)=>Math.floor(t/e)),dM=ot(pi,uM,null,"int32"),fM={kernelName:pi,backendName:"cpu",kernelFunc:dM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:h}=r;let g=X$({inputs:{x:s,filter:o},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:f}});if(a){const m=g;g=bl({inputs:{a:g,b:a},backend:n}),n.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=tx(n,g,p,i,h),n.disposeIntermediateTensorInfo(m)}return g}const hM={kernelName:Zi,backendName:"cpu",kernelFunc:pM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:h}=r;let g=Y$({inputs:{x:s,filter:o},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:f}});if(a){const m=g;g=bl({inputs:{a:g,b:a},backend:n}),n.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=tx(n,g,p,i,h),n.disposeIntermediateTensorInfo(m)}return g}const gM={kernelName:Ji,backendName:"cpu",kernelFunc:mM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xM(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=L(r.shape),a=s.shape,i=a[a.length-1],[l,c,u,d]=zd(r,s);if(c===0)return n.makeTensorInfo(l,r.dtype,[]);const f=n.data.get(s.dataId).values,p=n.bufferSync(r),h=d$(f,p,r.dtype,c,i,u,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,h.values)}const yM={kernelName:Du,backendName:"cpu",kernelFunc:xM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:a,batchDims:i}=r;ne([s,o],"gatherV2");const l=ge(a,s.shape)[0],c=n.data.get(o.dataId).values,u=s.shape[l];for(let v=0;v<c.length;++v){const $=c[v];S($<=u-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${u-1}]`)}let d=i;i==null&&(d=0);const f=L(o.shape),p=qg(s,o,l,d),h=Le({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=Le({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,f/p.batchSize]}}),m=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize],x=n.bufferSync(g),y=n.bufferSync(h),w=f$(y,x,m);return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,w.dtype,w.values)}const wM={kernelName:Ru,backendName:"cpu",kernelFunc:vM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $M(t){const{inputs:e,backend:n}=t,{input:r}=e,s=L(r.shape),o=r.shape[r.shape.length-1],a=s/o,i=Le({inputs:{x:r},backend:n,attrs:{shape:[a,o]}}),l=Q$(i,!0,n),c=Le({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),c}const bM={kernelName:Fu,backendName:"cpu",kernelFunc:$M};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CM=be(xi,t=>Number.isFinite(t)?1:0,"bool"),kM={kernelName:xi,backendName:"cpu",kernelFunc:CM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SM=be(yi,t=>Math.abs(t)===1/0?1:0,"bool"),IM={kernelName:yi,backendName:"cpu",kernelFunc:SM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EM=be(vi,t=>Number.isNaN(t)?1:0,"bool"),TM={kernelName:vi,backendName:"cpu",kernelFunc:EM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NM(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,a=x$(r,s,o);return e.makeTensorInfo([a.length],"float32",a)}const RM={kernelName:Pu,backendName:"cpu",kernelFunc:NM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DM=be(Ci,t=>Math.log1p(t)),FM={kernelName:Ci,backendName:"cpu",kernelFunc:DM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AM=Ze((t,e)=>t&&e),_M=ot(ki,AM,null,"bool"),PM={kernelName:ki,backendName:"cpu",kernelFunc:_M};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OM=be(Si,t=>t?0:1,"bool"),MM={kernelName:Si,backendName:"cpu",kernelFunc:OM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LM=Ze((t,e)=>t||e),BM=ot(Ii,LM,null,"bool"),VM={kernelName:Ii,backendName:"cpu",kernelFunc:BM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:a,alpha:i,beta:l}=r;ne(s,"LRN");const c=s.shape[3],u=c-1,d=n.data.get(s.dataId).values,f=L(s.shape),p=new Float32Array(f);function h(g){const m=g%c;let x=g-m+Math.max(0,m-o);const y=g-m+Math.min(m+o,u);let w=0;for(;x<=y;x++){const v=d[x];w+=v*v}return w}for(let g=0;g<f;g++){const m=h(g),x=d[g]*Math.pow(a+i*m,-l);p[g]=x}return n.makeTensorInfo(s.shape,s.dtype,p)}const zM={kernelName:Ou,backendName:"cpu",kernelFunc:WM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:a}=e,{depthRadius:i,bias:l,alpha:c,beta:u}=r;ne(a,"LRNGrad");const d=L(a.shape),f=a.shape[3],p=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,g=n.data.get(o.dataId).values,m=new Float32Array(d),x=d;for(let y=0;y<x;y++){const w=y%f,v=y-w+Math.max(0,w-i),$=y-w+Math.min(f,w+i+1);let b=0;for(let C=v;C<$;C++)b+=Math.pow(h[C],2);b=c*b+l;for(let C=v;C<$;C++){let I=-2*c*u*h[C]*g[y]/b;y===C&&(I+=Math.pow(b,-u)),I*=p[y],m[C]+=I}}return n.makeTensorInfo(a.shape,s.dtype,m)}const GM={kernelName:mm,backendName:"cpu",kernelFunc:UM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:a}=r,i=n;let l=s.shape;const c=l.length,u=ge(o,l);let d=u;const f=Ye(d,c);let p=i.data.get(s.dataId).values;if(f!=null){const v=new Array(c);for(let $=0;$<v.length;$++)v[$]=l[f[$]];p=Zg(p,l,s.dtype,f,v),d=Qe(d.length,c),l=v}ne(s,"max"),ft("max",d,c);const[h,g]=dt(l,d),m=L(g),x=v$(p,m,h,s.dtype),y=i.write(x,h,s.dtype);let w=h;return a&&(w=tt(h,u)),{dataId:y,shape:w,dtype:s.dtype}}const HM={kernelName:Mu,backendName:"cpu",kernelFunc:Z$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;ne(s,"maxPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,c=1;S(vt(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const u=hn(s.shape,o,a,c,i,l);let d;if(u.filterWidth===1&&u.filterHeight===1&&Ie(u.inShape,u.outShape))d=Bn({inputs:{x:s},backend:n});else{const f=n.data.get(s.dataId).values,p=ae(s.shape),h=nx(f,s.shape,s.dtype,p,u,"max");d=n.makeTensorInfo(u.outShape,s.dtype,h.values)}return d}const KM={kernelName:Lu,backendName:"cpu",kernelFunc:jM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:c}=r;ne(s,"maxPool3d");const u=nr(s.shape,o,a,1,i,l,c),d=n.data.get(s.dataId).values,f=q$(d,s.shape,s.dtype,ae(s.shape),u,"max");return n.makeTensorInfo(f.shape,"float32",f.values)}const XM={kernelName:Bu,backendName:"cpu",kernelFunc:qM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YM(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,{filterSize:a,strides:i,pad:l,dimRoundingMode:c}=r;ne([s,o],"maxPool3DGrad");const u=nr(o.shape,a,i,1,l,c),d=n.bufferSync(o),f=B3(d,u),p=u.strideDepth,h=u.strideHeight,g=u.strideWidth,m=u.dilationDepth,x=u.dilationHeight,y=u.dilationWidth,w=u.effectiveFilterDepth,v=u.effectiveFilterHeight,$=u.effectiveFilterWidth,b=w-1-u.padInfo.front,C=$-1-u.padInfo.left,I=v-1-u.padInfo.top,E=de(o.shape,"float32"),T=n.bufferSync(s);for(let D=0;D<u.batchSize;++D)for(let F=0;F<u.inChannels;++F)for(let A=0;A<u.inDepth;++A)for(let P=0;P<u.inHeight;++P)for(let M=0;M<u.inWidth;++M){const O=A-b,U=P-I,B=M-C;let G=0;for(let j=0;j<w;j+=m){const _=(O+j)/p;if(!(_<0||_>=u.outDepth||Math.floor(_)!==_))for(let V=0;V<v;V+=x){const W=(U+V)/h;if(!(W<0||W>=u.outHeight||Math.floor(W)!==W))for(let K=0;K<$;K+=y){const q=(B+K)/g;if(q<0||q>=u.outWidth||Math.floor(q)!==q)continue;const Y=w*v*$-1-f.get(D,_,W,q,F),J=j*v*$+V*$+K,se=Y===J?1:0;if(se===0)continue;G+=T.get(D,_,W,q,F)*se}}}E.set(G,D,A,P,M,F)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}const QM={kernelName:xm,backendName:"cpu",kernelFunc:YM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZM(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:a}=e,i=o;ne([o,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,f=hn(i.shape,l,c,1,u,d),p=n.data.get(i.dataId).values,h=de(f.outShape,i.dtype,K$(p,i.shape,i.dtype,f).values),g=f.strideHeight,m=f.strideWidth,x=f.dilationHeight,y=f.dilationWidth,w=f.effectiveFilterHeight,v=f.effectiveFilterWidth,$=v-1-f.padInfo.left,b=w-1-f.padInfo.top,C=de(i.shape,"float32"),I=n.data.get(s.dataId).values,E=de(s.shape,"float32",I);for(let T=0;T<f.batchSize;++T)for(let D=0;D<f.inChannels;++D)for(let F=0;F<f.inHeight;++F)for(let A=0;A<f.inWidth;++A){const P=F-b,M=A-$;let O=0;for(let U=0;U<w;U+=x){const B=(P+U)/g;if(!(B<0||B>=f.outHeight||Math.floor(B)!==B))for(let G=0;G<v;G+=y){const j=(M+G)/m;if(j<0||j>=f.outWidth||Math.floor(j)!==j)continue;const _=w*v-1-h.get(T,B,j,D),V=U*v+G,W=_===V?1:0;if(W===0)continue;O+=E.get(T,B,j,D)*W}}C.set(O,T,F,A,D)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}const JM={kernelName:gm,backendName:"cpu",kernelFunc:ZM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eL(t,e,n,r,s){const o=ae(e),a=nx(t,e,n,o,s,"max"),i=K$(t,e,n,s,!0,r);return[a.values,i.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tL={kernelName:Vu,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:o,pad:a,includeBatchInIndex:i}=e,l=n;ne(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=hn(r.shape,s,o,[1,1],a),[d,f]=eL(c,r.shape,r.dtype,i,u),p=l.write(d,u.outShape,r.dtype),h=l.write(f,u.outShape,r.dtype);return[{dataId:p,shape:u.outShape,dtype:r.dtype},{dataId:h,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nL(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,i=ge(o,s.shape),c=dt(s.shape,i)[1],u=L(c),d=[],f=n.makeTensorInfo([],"float32",new Float32Array([u]));d.push(f);const p=Gr({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});d.push(p);const h=rx({inputs:{a:p,b:f},backend:n});d.push(h);const g=kl({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:a}});return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),g}const rL={kernelName:Wu,backendName:"cpu",kernelFunc:nL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sL(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;ne(s,"min");const i=ge(o,s.shape);let l=i;const c=Ye(l,s.shape.length);let u=s;c!=null&&(u=Zt({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Qe(l.length,s.shape.length)),ft("min",l,u.shape.length);const[d,f]=dt(u.shape,l),p=L(f),h=ut(L(d),u.dtype),g=n.data.get(u.dataId).values;for(let x=0;x<h.length;++x){const y=x*p;let w=g[y];for(let v=0;v<p;++v){const $=g[y+v];(Number.isNaN($)||$<w)&&(w=$)}h[x]=w}c!=null&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(d,u.dtype,h);if(a){const x=tt(d,i),y=Le({inputs:{x:m},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(m),y}return m}const oL={kernelName:zu,backendName:"cpu",kernelFunc:sL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aL(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,mode:a}=r;ne(s,"mirrorPad");const i=o.map((w,v)=>w[0]+s.shape[v]+w[1]),l=o.map(w=>w[0]),c=o.map((w,v)=>w[0]+s.shape[v]),u=a==="reflect"?0:1,d=n.data.get(s.dataId).values,f=s.shape.length,p=ae(s.shape),h=L(i),g=i.length,m=ae(i),x=Je(s.dtype,h);for(let w=0;w<h;w++){let v=wo(w,g,m);for(let b=0;b<g;b++)v[b]<l[b]?v[b]=l[b]*2-v[b]-u:v[b]>=c[b]&&(v[b]=(c[b]-1)*2-v[b]+u);v=v.map((b,C)=>b-l[C]);const $=wn(v,f,p);x[w]=d[$]}return{dataId:n.write(x,i,s.dtype),shape:i,dtype:s.dtype}}const iL={kernelName:Uu,backendName:"cpu",kernelFunc:aL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lL=Ze((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),cL=ot(Ni,lL),uL={kernelName:Ni,backendName:"cpu",kernelFunc:cL};var J$={exports:{}};(function(t){(function(e,n,r){function s(l){var c=this,u=i();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function o(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function a(l,c){var u=new s(l),d=c&&c.state,f=u.next;return f.int32=function(){return u.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,d&&(typeof d=="object"&&o(d,u),f.state=function(){return o(u,{})}),f}function i(){var l=4022871197,c=function(u){u=u.toString();for(var d=0;d<u.length;d++){l+=u.charCodeAt(d);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.alea=a})(tn,t,!1)})(J$);var eb={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},i===(i|0)?l.x=i:c+=i;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l}function a(i,l){var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.xor128=a})(tn,t,!1)})(eb);var tb={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,i===(i|0)?l.x=i:c+=i;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l.v=i.v,l.d=i.d,l}function a(i,l){var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.xorwow=a})(tn,t,!1)})(tb);var nb={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this;l.next=function(){var u=l.x,d=l.i,f,p;return f=u[d],f^=f>>>7,p=f^f<<24,f=u[d+1&7],p^=f^f>>>10,f=u[d+3&7],p^=f^f>>>3,f=u[d+4&7],p^=f^f<<7,f=u[d+7&7],f=f^f<<13,p^=f^f<<9,u[d]=p,l.i=d+1&7,p};function c(u,d){var f,p=[];if(d===(d|0))p[0]=d;else for(d=""+d,f=0;f<d.length;++f)p[f&7]=p[f&7]<<15^d.charCodeAt(f)+p[f+1&7]<<13;for(;p.length<8;)p.push(0);for(f=0;f<8&&p[f]===0;++f);for(f==8&&(p[7]=-1),u.x=p,u.i=0,f=256;f>0;--f)u.next()}c(l,i)}function o(i,l){return l.x=i.x.slice(),l.i=i.i,l}function a(i,l){i==null&&(i=+new Date);var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(u.x&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.xorshift7=a})(tn,t,!1)})(nb);var rb={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this;l.next=function(){var u=l.w,d=l.X,f=l.i,p,h;return l.w=u=u+1640531527|0,h=d[f+34&127],p=d[f=f+1&127],h^=h<<13,p^=p<<17,h^=h>>>15,p^=p>>>12,h=d[f]=h^p,l.i=f,h+(u^u>>>16)|0};function c(u,d){var f,p,h,g,m,x=[],y=128;for(d===(d|0)?(p=d,d=null):(d=d+"\0",p=0,y=Math.max(y,d.length)),h=0,g=-32;g<y;++g)d&&(p^=d.charCodeAt((g+32)%d.length)),g===0&&(m=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,g>=0&&(m=m+1640531527|0,f=x[g&127]^=p+m,h=f==0?h+1:0);for(h>=128&&(x[(d&&d.length||0)&127]=-1),h=127,g=4*128;g>0;--g)p=x[h+34&127],f=x[h=h+1&127],p^=p<<13,f^=f<<17,p^=p>>>15,f^=f>>>12,x[h]=p^f;u.w=m,u.X=x,u.i=h}c(l,i)}function o(i,l){return l.i=i.i,l.w=i.w,l.X=i.X.slice(),l}function a(i,l){i==null&&(i=+new Date);var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(u.X&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.xor4096=a})(tn,t,!1)})(rb);var sb={exports:{}};(function(t){(function(e,n,r){function s(i){var l=this,c="";l.next=function(){var d=l.b,f=l.c,p=l.d,h=l.a;return d=d<<25^d>>>7^f,f=f-p|0,p=p<<24^p>>>8^h,h=h-d|0,l.b=d=d<<20^d>>>12^f,l.c=f=f-p|0,l.d=p<<16^f>>>16^h,l.a=h-d|0},l.a=0,l.b=0,l.c=2654435769|0,l.d=1367130551,i===Math.floor(i)?(l.a=i/4294967296|0,l.b=i|0):c+=i;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function o(i,l){return l.a=i.a,l.b=i.b,l.c=i.c,l.d=i.d,l}function a(i,l){var c=new s(i),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,p=(c.next()>>>0)/4294967296,h=(f+p)/(1<<21);while(h===0);return h},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&o(u,c),d.state=function(){return o(c,{})}),d}n&&n.exports?n.exports=a:r&&r.amd?r(function(){return a}):this.tychei=a})(tn,t,!1)})(sb);var ob={exports:{}};(function(t){(function(e,n){var r=this,s=256,o=6,a=52,i="random",l=n.pow(s,o),c=n.pow(2,a),u=c*2,d=s-1,f;function p(v,$,b){var C=[];$=$==!0?{entropy:!0}:$||{};var I=x(m($.entropy?[v,w(e)]:v==null?y():v,3),C),E=new h(C),T=function(){for(var D=E.g(o),F=l,A=0;D<c;)D=(D+A)*s,F*=s,A=E.g(1);for(;D>=u;)D/=2,F/=2,A>>>=1;return(D+A)/F};return T.int32=function(){return E.g(4)|0},T.quick=function(){return E.g(4)/4294967296},T.double=T,x(w(E.S),e),($.pass||b||function(D,F,A,P){return P&&(P.S&&g(P,E),D.state=function(){return g(E,{})}),A?(n[i]=D,F):D})(T,I,"global"in $?$.global:this==n,$.state)}n["seed"+i]=p;function h(v){var $,b=v.length,C=this,I=0,E=C.i=C.j=0,T=C.S=[];for(b||(v=[b++]);I<s;)T[I]=I++;for(I=0;I<s;I++)T[I]=T[E=d&E+v[I%b]+($=T[I])],T[E]=$;(C.g=function(D){for(var F,A=0,P=C.i,M=C.j,O=C.S;D--;)F=O[P=d&P+1],A=A*s+O[d&(O[P]=O[M=d&M+F])+(O[M]=F)];return C.i=P,C.j=M,A})(s)}function g(v,$){return $.i=v.i,$.j=v.j,$.S=v.S.slice(),$}function m(v,$){var b=[],C=typeof v,I;if($&&C=="object")for(I in v)try{b.push(m(v[I],$-1))}catch{}return b.length?b:C=="string"?v:v+"\0"}function x(v,$){for(var b=v+"",C,I=0;I<b.length;)$[d&I]=d&(C^=$[d&I]*19)+b.charCodeAt(I++);return w($)}function y(){try{var v;return f&&(v=f.randomBytes)?v=v(s):(v=new Uint8Array(s),(r.crypto||r.msCrypto).getRandomValues(v)),w(v)}catch{var $=r.navigator,b=$&&$.plugins;return[+new Date,r,b,r.screen,w(e)]}}function w(v){return String.fromCharCode.apply(0,v)}if(x(n.random(),e),t.exports){t.exports=p;try{f=require("crypto")}catch{}}})([],Math)})(ob);var dL=J$.exports,fL=eb.exports,pL=tb.exports,hL=nb.exports,mL=rb.exports,gL=sb.exports,_s=ob.exports;_s.alea=dL;_s.xor128=fL;_s.xorwow=pL;_s.xorshift7=hL;_s.xor4096=mL;_s.tychei=gL;var xL=_s;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ab(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,a=s.shape.length;let i=o;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);const l=ge([i],s.shape),c=Z$({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=tt(c.shape,l),d=Le({inputs:{x:c},backend:n,attrs:{shape:u}}),f=ex({inputs:{a:s,b:d},backend:n}),p=l$({inputs:{x:f},backend:n}),h=kl({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=Le({inputs:{x:h},backend:n,attrs:{shape:u}}),m=rx({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),m}const yL={kernelName:pd,backendName:"cpu",kernelFunc:ab};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vL(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:a,normalized:i}=r;ne(s,"multinomial");const l=i?s:ab({inputs:{logits:s},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],d=n.data.get(l.dataId).values,f=[c,o],p=ut(L(f),"int32");for(let h=0;h<c;++h){const g=h*u,m=new Float32Array(u-1);m[0]=d[g];for(let w=1;w<m.length;++w)m[w]=m[w-1]+d[g+w];const x=xL.alea(a.toString()),y=h*o;for(let w=0;w<o;++w){const v=x();p[y+w]=m.length;for(let $=0;$<m.length;$++)if(v<m[$]){p[y+w]=$;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(f,"int32",p)}const wL={kernelName:Gu,backendName:"cpu",kernelFunc:vL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $L=lf;function bL(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=r;ne(s,"NonMaxSuppression");const c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,{selectedIndices:d}=$L(c,u,a,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const CL={kernelName:ju,backendName:"cpu",kernelFunc:bL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kL=cf;function SL(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=r;ne(s,"NonMaxSuppressionPadded");const u=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,{selectedIndices:f,validOutputs:p}=kL(u,d,a,i,l,c);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const IL={kernelName:Ku,backendName:"cpu",kernelFunc:SL};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EL=uf;function TL(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=r;ne(s,"NonMaxSuppressionWithScore");const u=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,f=a,p=i,h=l,g=c,{selectedIndices:m,selectedScores:x}=EL(u,d,f,p,h,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const NL={kernelName:qu,backendName:"cpu",kernelFunc:TL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RL(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{depth:o,onValue:a,offValue:i}=r;ne(s,"oneHot");const l=L(s.shape),c=new Float32Array(l*o);c.fill(i);const u=n.data.get(s.dataId).values;for(let d=0;d<l;++d)u[d]>=0&&u[d]<o&&(c[d*o+u[d]]=a);return n.makeTensorInfo([...s.shape,o],"int32",c)}const DL={kernelName:Yu,backendName:"cpu",kernelFunc:RL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bf(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=Fs({inputs:{input:r},backend:n}),o=bf({inputs:{x:s},backend:n}),a=Lo({inputs:{input:r},backend:n}),i=bf({inputs:{x:a},backend:n}),l=Ht({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return ax({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const FL={kernelName:Nd,backendName:"cpu",kernelFunc:bf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=Fs({inputs:{input:r},backend:n}),o=ib({inputs:{x:s},backend:n}),a=Lo({inputs:{input:r},backend:n}),i=bf({inputs:{x:a},backend:n}),l=Ht({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return ax({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const AL={kernelName:Xu,backendName:"cpu",kernelFunc:ib};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lb(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return $f({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,a=e[0].dtype;e.forEach(u=>{ct(o,u.shape,"All tensors passed to stack must have matching shapes"),S(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],l=e.map(u=>{const d=$f({inputs:{input:u},backend:n,attrs:{dim:s}});return i.push(d),d}),c=Bo({inputs:l,backend:n,attrs:{axis:s}});return i.forEach(u=>n.disposeIntermediateTensorInfo(u)),c}const _L={kernelName:Qu,backendName:"cpu",kernelFunc:lb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PL(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:a}=r;ne(s,"pad");const i=o.map((y,w)=>y[0]+s.shape[w]+y[1]),l=o.map(y=>y[0]),c=n.data.get(s.dataId).values,u=L(s.shape),d=s.shape.length,f=ae(s.shape),p=L(i),h=i.length,g=ae(i),m=Je(s.dtype,p);a!==0&&m.fill(a);for(let y=0;y<u;y++){const v=wo(y,d,f).map((b,C)=>b+l[C]),$=wn(v,h,g);m[$]=c[y]}return{dataId:n.write(m,i,s.dtype),shape:i,dtype:s.dtype}}const cb={kernelName:Zu,backendName:"cpu",kernelFunc:PL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OL=Ze((t,e)=>Math.pow(t,e)),ML=ot(Fi,OL),LL={kernelName:Fi,backendName:"cpu",kernelFunc:ML};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BL(t){const{backend:e,attrs:n}=t,{start:r,stop:s,dtype:o,step:a}=n,i=S$(r,s,a,o);return e.makeTensorInfo([i.length],o,i)}const VL={kernelName:td,backendName:"cpu",kernelFunc:BL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WL=be(Ai,t=>1/t),zL={kernelName:Ai,backendName:"cpu",kernelFunc:WL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UL(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:a,size:i}=r;ne(s,"resizeBilinear");const l=ae(s.shape),[c,u]=i,[d,f,p,h]=s.shape,g=n.data.get(s.dataId).values,m=new Float32Array(L([d,c,u,h])),x=[o&&c>1?f-1:f,o&&u>1?p-1:p],y=[o&&c>1?c-1:c,o&&u>1?u-1:u];let w=0;const v=x[0]/y[0],$=x[1]/y[1];for(let b=0;b<d;b++)for(let C=0;C<c;C++){let I;a?I=v*(C+.5)-.5:I=v*C;const E=Math.max(0,Math.floor(I)),T=I-E,D=Math.min(f-1,Math.ceil(I)),F=b*l[0]+E*l[1],A=b*l[0]+D*l[1];for(let P=0;P<u;P++){let M;a?M=$*(P+.5)-.5:M=$*P;const O=Math.max(0,Math.floor(M)),U=M-O,B=Math.min(p-1,Math.ceil(M)),G=F+O*l[2],j=A+O*l[2],_=F+B*l[2],V=A+B*l[2];for(let W=0;W<h;W++){const K=g[G+W],q=g[j+W],Y=g[_+W],J=g[V+W],se=K+(Y-K)*U,oe=q+(J-q)*U,ue=se+(oe-se)*T;m[w++]=ue}}}return n.makeTensorInfo([d,c,u,h],"float32",m)}const GL={kernelName:od,backendName:"cpu",kernelFunc:UL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HL(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:a}=r;ne([o,s],"resizeBilinearGrad");const i=ae(s.shape),[l,c,u,d]=s.shape,[,f,p]=o.shape,h=new Float32Array(l*c*u*d),g=[a&&f>1?c-1:c,a&&p>1?u-1:u],m=[a&&f>1?f-1:f,a&&p>1?p-1:p],x=g[0]/m[0],y=g[1]/m[1],w=n.data.get(o.dataId).values;let v=0;for(let $=0;$<l;$++){const b=$*i[0];for(let C=0;C<f;C++){const I=C*x,E=Math.floor(I),T=Math.min(Math.ceil(I),c-1),D=b+E*i[1],F=b+T*i[1],A=I-E,P=1-A;for(let M=0;M<p;M++){const O=M*y,U=Math.floor(O),B=Math.min(Math.ceil(O),u-1),G=O-U,j=1-G,_=D+U*i[2],V=D+B*i[2],W=F+U*i[2],K=F+B*i[2],q=P*j,Y=P*G,J=A*j,se=A*G;for(let oe=0;oe<d;oe++){const ue=w[v++];h[_+oe]+=ue*q,h[V+oe]+=ue*Y,h[W+oe]+=ue*J,h[K+oe]+=ue*se}}}}return n.makeTensorInfo([l,u,c,d],"float32",h)}const jL={kernelName:vm,backendName:"cpu",kernelFunc:HL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KL(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:a,size:i}=r;ne(s,"resizeNearestNeighbor");const l=ae(s.shape),[c,u]=i,[d,f,p,h]=s.shape,g=n.data.get(s.dataId).values,m=new Float32Array(d*c*u*h),x=[o&&c>1?f-1:f,o&&u>1?p-1:p],y=[o&&c>1?c-1:c,o&&u>1?u-1:u],w=x[0]/y[0],v=x[1]/y[1];let $=0;for(let b=0;b<d;b++){const C=b*l[0];for(let I=0;I<c;I++){const E=a?w*(I+.5):w*I;let T=Math.min(f-1,o?Math.round(E):Math.floor(E));a&&(T=Math.max(0,T));const D=C+T*l[1];for(let F=0;F<u;F++){const A=a?v*(F+.5):v*F;let P=Math.min(p-1,o?Math.round(A):Math.floor(A));a&&(P=Math.max(0,P));const M=D+P*l[2];for(let O=0;O<h;O++){const U=g[M+O];m[$++]=U}}}}return n.makeTensorInfo([d,c,u,h],s.dtype,m)}const qL={kernelName:sd,backendName:"cpu",kernelFunc:KL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XL(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:a}=r;ne([o,s],"resizeNearestNeighborGrad");const i=ae(s.shape),l=ae(o.shape),[c,u,d,f]=s.shape,[,p,h]=o.shape,g=new Float32Array(c*u*d*f),m=n.data.get(o.dataId).values,x=[a&&p>1?u-1:u,a&&h>1?d-1:d],y=[a&&p>1?p-1:p,a&&h>1?h-1:h],w=x[0]/y[0],v=x[1]/y[1],$=1/w,b=1/v,C=Math.ceil($)*2+2,I=Math.ceil(b)*2+2;for(let E=0;E<c;E++){const T=E*i[0];for(let D=0;D<u;D++){const F=T+D*i[1],A=Math.floor(D*$),P=Math.floor(A-C/2);for(let M=0;M<d;M++){const O=F+M*i[2],U=Math.floor(M*b),B=Math.floor(U-I/2);for(let G=0;G<f;G++){let j=0;for(let _=0;_<C;_++){const V=_+P;if(V<0||V>=p)continue;const W=T+V*l[1],K=V*w,q=Math.min(u-1,a?Math.round(K):Math.floor(K));if(D===q)for(let Y=0;Y<I;Y++){const J=Y+B;if(J<0||J>=h)continue;const se=W+J*l[2],oe=J*v,ue=Math.min(d-1,a?Math.round(oe):Math.floor(oe));M===ue&&(j+=m[se+G])}}g[O+G]=j}}}}return n.makeTensorInfo(s.shape,s.dtype,g)}const YL={kernelName:ym,backendName:"cpu",kernelFunc:XL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QL(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r;ne(s,"reverse");const a=s.shape.length,i=ge(o,s.shape);if(a===0)return Bn({inputs:{x:s},backend:n});const l=new et(s.shape,s.dtype),c=n.bufferSync(s);for(let u=0;u<l.size;u++){const d=l.indexToLoc(u),f=d.slice();i.forEach(p=>f[p]=s.shape[p]-1-f[p]),l.set(c.get(...f),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const ZL={kernelName:ad,backendName:"cpu",kernelFunc:QL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JL={kernelName:Dd,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:a}=e,i=n,l=Je(r.dtype,L(r.shape)),[c,u,d,f]=r.shape,[p,h]=Ng(a,u,d),g=255,m=Math.sin(s),x=Math.cos(s),y=i.data.get(r.dataId).values;for(let v=0;v<c;v++){const $=v*d*u*f;for(let b=0;b<u;b++){const C=b*(d*f);for(let I=0;I<d;I++){const E=I*f;for(let T=0;T<f;T++){const D=[c,b,I,T],F=D[2],A=D[1];let P=(F-p)*x-(A-h)*m,M=(F-p)*m+(A-h)*x;P=Math.round(P+p),M=Math.round(M+h);let O=o;if(typeof o!="number"&&(T===3?O=g:O=o[T]),P>=0&&P<d&&M>=0&&M<u){const B=M*(d*f),G=P*f,j=$+B+G+T;O=y[j]}const U=$+C+E+T;l[U]=O}}}}return{dataId:i.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e4=be(Oi,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1}),t4={kernelName:Oi,backendName:"cpu",kernelFunc:e4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ub(t,e,n,r,s,o,a,i,l,c){const u=[r/s,s],d=t.values,f=e.values;if(r===0)return de(n,e.dtype);const p=de(u,e.dtype);p.values.fill(l);for(let h=0;h<o;h++){const g=[];let m=0;for(let x=0;x<a;x++){const y=d[h*a+x];g.push(y),m+=y*i[x]}if(m<0||m>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let x=0;x<s;x++)c?p.values[m*s+x]+=f[h*s+x]:p.values[m*s+x]=e.rank===0?f[0]:f[h*s+x]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n4(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:a}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Ro(o,s,a),f=!0,p=n.bufferSync(s),h=n.bufferSync(o),g=ub(p,h,a,d,c,l,i,u,0,f);return n.makeTensorInfo(a,g.dtype,g.values)}const r4={kernelName:id,backendName:"cpu",kernelFunc:n4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e;ne([r,s,o],"select");const a=r.shape.length,i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values,u=zt(s.dtype,o.dtype),d=ut(L(s.shape),u);let f=0;const p=a===0||a>1||s.shape.length===1?1:L(s.shape.slice(1));for(let h=0;h<i.length;h++)for(let g=0;g<p;g++)i[h]===1?d[f++]=l[h]:d[f++]=c[h];return n.makeTensorInfo(s.shape,u,d)}const o4={kernelName:ld,backendName:"cpu",kernelFunc:s4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a4=Fg,i4=Ag,l4=be(Li,t=>t>=0?i4*t:a4*(Math.exp(t)-1)),c4={kernelName:Li,backendName:"cpu",kernelFunc:l4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u4=be(Wi,t=>t<0?-1:t>0?1:0),d4={kernelName:Wi,backendName:"cpu",kernelFunc:u4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f4=be(Bi,t=>Math.sin(t)),p4={kernelName:Bi,backendName:"cpu",kernelFunc:f4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h4=be(Vi,t=>Math.sinh(t)),m4={kernelName:Vi,backendName:"cpu",kernelFunc:h4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g4=11920928955078125e-23,db=Math.log(g4)+2,x4=be(Ui,t=>{const e=t>-db,n=t<db,r=Math.exp(t);let s;return n?s=r:e?s=t:s=Math.log(1+r),s}),y4={kernelName:Ui,backendName:"cpu",kernelFunc:x4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:a}=r;ne([s],"spaceToBatchND");const i=L(o),l=[[0,0]];l.push(...a);for(let b=1+o.length;b<s.shape.length;++b)l.push([0,0]);const c=cb.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),u=vl(c.shape,o,i,!1),d=wl(u.length,o.length,!1),f=$l(c.shape,o,i,!1),g=Le({inputs:{x:c},backend:n,attrs:{shape:u}}),y=Zt({inputs:{x:g},backend:n,attrs:{perm:d}}),$=Le({inputs:{x:y},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),$}const w4={kernelName:dd,backendName:"cpu",kernelFunc:v4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $4(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values,u=n.data.get(a.dataId).values[0],[d,f,p,h,g]=N$(i,r.shape,r.dtype,l,s.dtype,c,u);return[n.makeTensorInfo(f,r.dtype,d),n.makeTensorInfo([f[0]],s.dtype,p),n.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(m=>Number(m)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const b4={kernelName:hd,backendName:"cpu",kernelFunc:$4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C4(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(n.data.get(s.dataId).values),i=n.data.get(r.dataId).values,l=Array.from(n.data.get(o.dataId).values),[c,u,d]=R$(i,r.shape,r.dtype,a,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}const k4={kernelName:md,backendName:"cpu",kernelFunc:C4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S4(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,[c,u]=Jg(a,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(u,r.dtype,c)}const I4={kernelName:gd,backendName:"cpu",kernelFunc:S4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E4(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,[c,u]=Jg(a,r.shape,r.dtype,i,l);return n.makeTensorInfo(u,r.dtype,c)}const T4={kernelName:xd,backendName:"cpu",kernelFunc:E4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N4(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:a}=e,{outputShape:i}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:f}=Ro(o,s,i),p=!1,h=n.bufferSync(s),g=n.bufferSync(o),m=n.data.get(a.dataId).values[0],x=ub(h,g,i,f,u,c,l,d,m,p);return n.makeTensorInfo(i,x.dtype,x.values)}const R4={kernelName:yd,backendName:"cpu",kernelFunc:N4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:a}=r,i=ge(a,s.shape)[0],l=Kg(s,o,i),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(d=>{const f=[...u];f[i]=d;const p=As({inputs:{x:s},backend:n,attrs:{begin:c,size:f}});return c[i]+=d,p})}const F4={kernelName:fd,backendName:"cpu",kernelFunc:D4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A4={kernelName:wm,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;ne(n,"square");const s=r.data.get(n.dataId).values,o=new Float32Array(s.length);for(let i=0;i<s.length;++i){const l=s[i];o[i]=l*l}return{dataId:r.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _4=be(Yi,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),P4={kernelName:Yi,backendName:"cpu",kernelFunc:_4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:a,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:f}=r;ne(s,"stridedSlice");const{finalShapeSparse:p,finalShape:h,isIdentity:g,sliceDim0:m,isSimpleSlice:x,begin:y,end:w,strides:v}=og(s.shape,o,a,i,l,c,u,d,f);let $;if(g)$=Le({inputs:{x:s},backend:n,attrs:{shape:h}});else if(m||x){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const b=tg(y,w,v),C=As({inputs:{x:s},backend:n,attrs:{begin:y,size:b}});$=Le({inputs:{x:C},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(C)}else{const b=n.bufferSync(s),C=F$(p,b,v,y);$=n.makeTensorInfo(h,C.dtype,C.values)}return $}const M4={kernelName:vd,backendName:"cpu",kernelFunc:O4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=e,f=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[h,g]=A$(f,p,s,o,a,i,l,c);return[n.makeTensorInfo([h.length],"string",h),n.makeTensorInfo(d.shape,"int32",g)]}const B4={kernelName:wd,backendName:"cpu",kernelFunc:L4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V4(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const i=n.data.get(o.dataId).values,l=n.data.get(a.dataId).values[0],[c,u,d]=_$(i,l,s),f=u.length;return[n.makeTensorInfo([f,2],"int32",c),n.makeTensorInfo([f],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const W4={kernelName:$d,backendName:"cpu",kernelFunc:V4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z4(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=n.data.get(o.dataId).values,i=P$(a,s);return n.makeTensorInfo(o.shape,"int32",i)}const U4={kernelName:bd,backendName:"cpu",kernelFunc:z4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G4=be(Ki,t=>Math.tan(t)),H4={kernelName:Ki,backendName:"cpu",kernelFunc:G4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j4=be(qi,t=>Math.tanh(t)),K4={kernelName:qi,backendName:"cpu",kernelFunc:j4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;ne(s,"tile");const a=M$(n.bufferSync(s),o);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const X4={kernelName:Xi,backendName:"cpu",kernelFunc:q4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:a}=r;ne(s,"topk");const i=n.data.get(s.dataId).values,[l,c]=B$(i,s.shape,s.dtype,o,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}const Q4={kernelName:Cd,backendName:"cpu",kernelFunc:Y4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z4(t){const{inputs:e,attrs:n,backend:r}=t,{image:s,transforms:o}=e,{interpolation:a,fillMode:i,fillValue:l,outputShape:c}=n,[u,d,f,p]=s.shape,[h,g]=c!=null?c:[d,f],m=[u,h,g,p],x=ae(s.shape),y=x[0],w=x[1],v=x[2],$=Je(s.dtype,L(m));$.fill(l);const b=r.data.get(s.dataId).values,C=r.data.get(o.dataId).values;for(let E=0;E<u;++E){const T=o.shape[0]===1?C:C.subarray(E*8,E*8+8);for(let D=0;D<h;++D)for(let F=0;F<g;++F)for(let A=0;A<p;++A){let P;const M=T[6]*F+T[7]*D+1;if(M===0)continue;const O=(T[0]*F+T[1]*D+T[2])/M,U=(T[3]*F+T[4]*D+T[5])/M,B=fb(O,f,i),G=fb(U,d,i);switch(a){case"nearest":P=sB(b,d,f,y,w,v,E,G,B,A,l);break;case"bilinear":P=oB(b,d,f,y,w,v,E,G,B,A,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const j=E*y+D*w+F*v+A;$[j]=P}return r.makeTensorInfo(m,s.dtype,$)}return{dataId:r.write($,m,s.dtype),shape:s.shape,dtype:s.dtype}}const J4={kernelName:kd,backendName:"cpu",kernelFunc:Z4};function fb(t,e,n){switch(n){case"reflect":return eB(t,e);case"wrap":return tB(t,e);case"nearest":return rB(t,e);case"constant":default:return nB(t)}}function eB(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const r=2*e;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-e?n+r:-n-1}else if(n>e-1)if(e<=1)n=0;else{const r=2*e;n-=r*Math.trunc(n/r),n>=e&&(n=r-n-1)}return Dr(0,n,e-1)}function tB(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const r=e-1;n+=e*(Math.trunc(-n/r)+1)}else if(n>e-1)if(e<=1)n=0;else{const r=e-1;n-=e*Math.trunc(n/r)}return Dr(0,n,e-1)}function nB(t,e){return t}function rB(t,e){return Dr(0,t,e-1)}function Sl(t,e,n,r,s,o,a,i,l,c,u){const d=a*r+i*s+l*o+c;return 0<=i&&i<e&&0<=l&&l<n?t[d]:u}function sB(t,e,n,r,s,o,a,i,l,c,u){const d=Math.round(i),f=Math.round(l);return Sl(t,e,n,r,s,o,a,d,f,c,u)}function oB(t,e,n,r,s,o,a,i,l,c,u){const d=Math.floor(i),f=Math.floor(l),p=d+1,h=f+1,g=(h-l)*Sl(t,e,n,r,s,o,a,d,f,c,u)+(l-f)*Sl(t,e,n,r,s,o,a,d,h,c,u),m=(h-l)*Sl(t,e,n,r,s,o,a,p,f,c,u)+(l-f)*Sl(t,e,n,r,s,o,a,p,h,c,u);return(p-i)*g+(i-d)*m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:o}=e;ne(o,"unique");const a=r.data.get(o.dataId).values,{outputValues:i,outputShape:l,indices:c}=V$(a,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}const iB={kernelName:Id,backendName:"cpu",kernelFunc:aB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lB(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const a=s.shape.length,i=s.shape[o],l=new Array(a-1);let c=0;for(let p=0;p<a;p++)p!==o&&(l[c++]=s.shape[p]);const u=new Array(a).fill(0),d=s.shape.slice();d[o]=1;const f=new Array(i);for(let p=0;p<f.length;p++){u[o]=p;const h=As({inputs:{x:s},backend:n,attrs:{begin:u,size:d}});f[p]=Le({inputs:{x:h},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(h)}return f}const cB={kernelName:Ed,backendName:"cpu",kernelFunc:lB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uB(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:a}=r;ne(s,"unsortedSegmentSum");const i=s.shape.length,l=o.shape.length,c=[],u=[],d=i-l;let f=o;for(let h=0;h<d;++h){const g=$f({inputs:{input:f},backend:n,attrs:{dim:h+1}});f=g,u.push(g)}for(let h=0;h<a;++h){const g=er(h,"int32"),m=n.makeTensorInfo([],"int32",g),x=a$({inputs:{a:m,b:f},backend:n}),y=Gr({inputs:{x},backend:n,attrs:{dtype:"float32"}}),w=wf({inputs:{a:y,b:s},backend:n}),v=kl({inputs:{x:w},backend:n,attrs:{axis:0,keepDims:!1}});c.push(v),u.push(m),u.push(x),u.push(y),u.push(w),u.push(v)}const p=lb({inputs:c,backend:n,attrs:{axis:0}});return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),p}const dB={kernelName:Td,backendName:"cpu",kernelFunc:uB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fB=[p3,oP,m3,x3,dP,v3,$3,C3,S3,E3,N3,D3,A3,O3,L3,W3,U3,H3,K3,d3,X3,Q3,J3,tO,cP,pP,rO,aP,oO,iO,uO,fO,lO,gO,yO,hO,wO,bO,kO,IO,TO,RO,DO,AO,PO,MO,LO,VO,BO,sx,UO,s3,HO,hP,JO,mP,eM,xP,aM,iM,cM,vP,fM,hM,gM,yM,wM,$P,CP,iP,bM,aO,kM,IM,TM,o3,SP,EP,RM,NP,FM,PM,MM,VM,zM,GM,DP,KM,XM,QM,JM,tL,HM,rL,oL,AP,iL,uL,wL,PP,MP,CL,IL,NL,BP,DL,AL,_L,cb,LL,i3,zP,VL,lP,zL,l3,c3,u3,GL,jL,qL,YL,ZL,JL,t4,GP,r4,o4,c4,jP,d4,p4,m4,KP,yL,y4,w4,b4,k4,I4,T4,R4,F4,YP,A4,ZP,P4,M4,B4,W4,U4,n3,WO,H4,K4,X4,Q4,VP,J4,iB,cB,dB,FL];for(const t of fB)_d(t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ps={},ix={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function pB(t,e){Ps[t]=e}function Vn(t){if(!(t in Ps)){const n=mB(t);if(n!==null)Ps[t]=n;else return console.log("Could not get context for WebGL version",t),null}const e=Ps[t];return e.isContextLost()?(delete Ps[t],Vn(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Ps[t])}function hB(t){if(typeof OffscreenCanvas!="undefined"&&t===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function mB(t){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=hB(t);return e.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete Ps[t]},!1),t===1?e.getContext("webgl",ix)||e.getContext("experimental-webgl",ix):e.getContext("webgl2",ix)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Il;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(Il||(Il={}));var Jt;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(Jt||(Jt={}));var pt;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(pt||(pt={}));function El(t,e){return[e,t]}function gB(t,e){return t*e}function Cf(t){const e=L(t),n=Math.ceil(e/4);return jc(n)}function Vo(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function xB(t,e){const[n,r]=Vo(t,e);return n*r*4}function lx(t,e){const n=t;let r,s,o,a,i,l,c,u,d,f;return z().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,o=n.RGBA16F,a=n.RGBA32F,i=n.RED,c=4,u=1,d=n.HALF_FLOAT,f=n.FLOAT):(r=t.RGBA,s=t.RGBA,o=t.RGBA,a=n.RGBA,i=t.RGBA,c=4,u=4,d=e!=null?e.HALF_FLOAT_OES:null,f=t.FLOAT),l=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function re(t,e){const n=e();return z().getBool("DEBUG")&&yB(t),n}function yB(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+bB(t,e))}const vB=596e-10,wB=65504;function $B(t){return!!(z().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||vB<Math.abs(t)&&Math.abs(t)<wB)}function bB(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function kf(t,e){return ir(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function CB(t,e){const n=ir(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(re(t,()=>t.shaderSource(n,e)),re(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function kB(t,e){const n=ir(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(re(t,()=>t.shaderSource(n,e)),re(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw IB(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const SB=/ERROR: [0-9]+:([0-9]+):/g;function IB(t,e){const n=SB.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],s=t.split(`
`),o=s.length.toString().length+2,a=s.map((d,f)=>ds((f+1).toString(),o)+d);let i=0;for(let d=0;d<a.length;d++)i=Math.max(a[d].length,i);const l=a.slice(0,r-1),c=a.slice(r-1,r),u=a.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${ds(c[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function EB(t){return ir(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function TB(t,e){if(re(t,()=>t.linkProgram(e)),t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function cx(t,e){if(re(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function NB(t,e){const n=ir(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return re(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),re(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function RB(t,e){const n=ir(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return re(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),re(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function DB(t){return ir(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function FB(t,e){const n=z().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function AB(t){return ir(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function pb(t,e,n,r,s,o,a){const i=t.getAttribLocation(e,n);return i===-1?!1:(re(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),re(t,()=>t.vertexAttribPointer(i,s,t.FLOAT,!1,o,a)),re(t,()=>t.enableVertexAttribArray(i)),!0)}function _B(t,e,n){BB(t,n),re(t,()=>t.activeTexture(t.TEXTURE0+n)),re(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function PB(t,e,n){return ir(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function OB(t,e,n){return t.getUniformLocation(e,n)}function MB(t,e,n,r){re(t,()=>_B(t,e,r)),re(t,()=>t.uniform1i(n,r))}function ux(t,e,n){re(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),re(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function hb(t,e){re(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),re(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Sf(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+LB(t,e))}function LB(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function ir(t,e,n){const r=re(t,()=>e());if(r==null)throw new Error(n);return r}function BB(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Wo(t,e=2){return L(t.slice(0,t.length-e))}function zo(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function dx(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[Wo(t),...zo(t)]),e}function VB(t,e=!1){let n=z().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(n=n*2,t=t.map((s,o)=>o>=t.length-2?Zh(t[o]):t[o]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=Jn(t).newShape);let r=L(t);if(t.length<=1&&r<=n)return[1,r];if(t.length===2&&t[0]<=n&&t[1]<=n)return t;if(t.length===3&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(t.length===3&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const s=Wo(t);let o=2,a=2;return t.length&&([o,a]=zo(t)),r=s*(o/2)*(a/2),jc(r).map(i=>i*2)}return jc(r)}function If(t){return t%2==0}function Ef(t,e){if(t=t.slice(-2),e=e.slice(-2),Ie(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r||If(n)&&If(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&If(t[0])&&If(e[0])}let fx,px;function WB(t){if(fx==null){const e=Vn(t);fx=e.getParameter(e.MAX_TEXTURE_SIZE)}return fx}function zB(t){if(px==null){const e=Vn(t);px=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,px)}function UB(t){if(t===0)return 0;let e;const n=Vn(t);return mn(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:mn(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function mn(t,e){return t.getExtension(e)!=null}function mb(t){try{if(Vn(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function GB(t){if(t===0)return!1;const e=Vn(t);if(t===1){if(!mn(e,"OES_texture_float"))return!1}else if(!mn(e,"EXT_color_buffer_float"))return!1;return hx(e)}function HB(t){if(t===0)return!1;const e=Vn(t);if(t===1){if(!mn(e,"OES_texture_float")||!mn(e,"WEBGL_color_buffer_float"))return!1}else{if(mn(e,"EXT_color_buffer_float"))return hx(e);const r="EXT_color_buffer_half_float";if(mn(e,r)){const s=e.getExtension(r);return jB(e,s)}return!1}return hx(e)}function hx(t){const e=lx(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);const r=1,s=1;t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,r,s,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(o),a}function jB(t,e){const n=lx(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);const s=1,o=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,s,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const a=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,a),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(a),i}function KB(t){return t!==2?!1:Vn(t).fenceSync!=null}function Tl(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&S(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ie=z();ie.registerFlag("HAS_WEBGL",()=>ie.getNumber("WEBGL_VERSION")>0);ie.registerFlag("WEBGL_VERSION",()=>mb(2)?2:mb(1)?1:0);ie.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ie.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ie.get("WEBGL_VERSION")===2);ie.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ie.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ie.registerFlag("WEBGL_PACK",()=>ie.getBool("HAS_WEBGL"));ie.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_PACK_CLIP",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_PACK_REDUCE",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_LAZILY_UNPACK",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_CONV_IM2COL",()=>ie.getBool("WEBGL_PACK"));ie.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>WB(ie.getNumber("WEBGL_VERSION")));ie.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>zB(ie.getNumber("WEBGL_VERSION")));ie.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=ie.getNumber("WEBGL_VERSION");return t===0?0:UB(t)});ie.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ie.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Om());ie.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>GB(ie.getNumber("WEBGL_VERSION")));ie.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ie.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ie.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ie.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>HB(ie.getNumber("WEBGL_VERSION")));ie.registerFlag("WEBGL_FENCE_API_ENABLED",()=>KB(ie.getNumber("WEBGL_VERSION")));ie.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ie.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ie.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});ie.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Om()?1:-1,t=>{if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});ie.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ie.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ie.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ie.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tt(){let t,e,n,r,s,o,a,i,l,c;return z().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",s="texture",o="outputColor",a="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Os(t,e,n="index"){const r=ae(e);return r.map((s,o)=>{const a=`int ${t[o]} = ${n} / ${s}`,i=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`;return`${a}; ${i};`}).join("")}function Tf(t,e,n="index"){const r=ae(e);return r.map((s,o)=>{const a=`int ${t[o]} = ${n} / outShapeStrides[${o}]`,i=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${a}; ${i};`}).join("")}function qB(t,e){const n=t.length,r=t.map(o=>`${e}[${o}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let o=n-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function XB(t,e,n="index"){const r=t.map((o,a)=>a),s=qB(r,e);return s.map((o,a)=>{const i=`int ${t[a]} = ${n} / ${s[a]}`,l=a===s.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * ${s[a]}`:`index -= ${t[a]} * ${s[a]}`;return`${i}; ${l};`}).join("")}function mx(t){const e=ae(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function gx(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const gb=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:xb}=Jw;function YB(t,e,n){const r=[];if(t.forEach(p=>{const h=L(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${h>1?`[${h}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){const{uniformShape:g}=xx(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`);break}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const s=r.join(`
`),o=t.map(p=>QB(p,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),a=e.texShape,i=Tt(),l=eV(i);let c,u,d=rV(i);return e.isPacked?(c=ZB(e.logicalShape,a,n.enableShapeUniforms),u=nV(i)):(c=JB(e.logicalShape,a,n.enableShapeUniforms),u=tV(i)),n.packedInputs&&(d+=iV),[d,l,u,s,c,o,n.userCode].join(`
`)}function Uo(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return vV(t,e);case 1:return $V(t,e);case 2:return CV(t,e);case 3:return SV(t,e);case 4:return EV(t,e);case 5:return TV(t);case 6:return NV(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function yb(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return yV(t);case 1:return wV(t,e);case 2:return bV(t,e);case 3:return kV(t,e);default:return IV(t,e)}}function QB(t,e,n=!1,r){let s="";n?s+=yb(t,r):s+=Uo(t,r);const o=t.shapeInfo.logicalShape,a=e.logicalShape;return o.length<=a.length&&(n?s+=RV(t,e):s+=DV(t,e)),s}function ZB(t,e,n){switch(t.length){case 0:return vb();case 1:return lV(t,e,n);case 2:return gV(t,e,n);case 3:return uV(t,e,n);default:return fV(t,e,n)}}function JB(t,e,n){switch(t.length){case 0:return vb();case 1:return cV(t,e,n);case 2:return xV(t,e,n);case 3:return dV(t,e,n);case 4:return pV(t,e,n);case 5:return hV(t,e);case 6:return mV(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function eV(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function tV(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function nV(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function rV(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${sV}
    ${oV}
    ${aV}
  `}const sV=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,oV=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,aV=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,iV=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function vb(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function lV(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function cV(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function uV(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),o=s*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function dV(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Tf(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=Os(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function fV(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),o=s*Math.ceil(t[t.length-2]/2);let a=o,i="",l="b, r, c";for(let c=2;c<t.length-1;c++)a*=t[t.length-c-1],i=`
      int b${c} = index / ${a};
      index -= b${c} * ${a};
    `+i,l=`b${c}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${i}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${t.length}(${l});
    }
  `}function pV(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Tf(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Os(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function hV(t,e){const n=Os(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function mV(t,e){const n=Os(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function gV(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Ie(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function xV(t,e,n){return Ie(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Ms(t){return`offset${t}`}function yV(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Tt();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function vV(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,o]=t.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=Ms(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});
      return sampleTexture(${n}, uv);
    }
  `;const[i,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${i}, ${l}, ${a});
      return sampleTexture(${n}, uv);
    }
  `}function wV(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,o=Tt();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;const a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function $V(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Go(t)}
      }
    `;const s=t.shapeInfo.texShape,o=s[0],a=s[1];if(a===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Ms(n);return a===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${a}, index + ${i});
      return sampleTexture(${n}, uv);
    }
  `}function bV(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,a=o[0],i=o[1],l=Tt();if(o!=null&&Ie(n,o))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function CV(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(o!=null&&Ie(n,o)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=o[0],p=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:a,keptDims:i}=Jn(n),l=a;if(l.length<n.length){const f=Ho(t,l),p=["row","col"];return`
      ${Uo(f,e)}
      float ${s}(int row, int col) {
        return ${s}(${jo(p,i)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Go(t)}
      }
    `;const c=o[0],u=o[1],d=Ms(r);return u===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function kV(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){const f=n.slice(1),p=[1,2],h=Ho(t,f),g=["b","row","col"];return`
        ${yb(h,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${jo(g,p)});
        }
      `}const i=Tt();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `;const l=a[0],c=a[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${u}, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `}function SV(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],a=n[2],{newShape:i,keptDims:l}=Jn(n),c=i;if(c.length<n.length){const g=Ho(t,c),m=["row","col","depth"];return`
        ${Uo(g,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${jo(m,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${a}, 1)));
        ${Go(t)}
      }
    `;const u=t.shapeInfo.texShape,d=u[0],f=u[1],p=t.shapeInfo.flatOffset;if(f===o&&p==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===a&&p==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;const h=Ms(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * ${o} + col * ${a} + depth + ${h};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${a} + depth + ${h};
        vec2 uv = uvFromFlat(${d}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function IV(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Tt();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const o=t.shapeInfo.logicalShape,a=o.length,i=t.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=l[0],u=l[1],d=Math.ceil(o[a-1]/2);let f=d*Math.ceil(o[a-2]/2),p="int b, int row, int col",h=`b * ${f} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<a-1;g++)p=`int b${g}, `+p,f*=o[a-g-1],h=`b${g} * ${f} + `+h;return`
    vec4 ${r}(${p}) {
      int index = ${h};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${s.texture2D}(${n}, uv);
    }
  `}function EV(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],a=n[2]*o,i=n[1]*a,{newShape:l,keptDims:c}=Jn(n);if(l.length<n.length){const y=Ho(t,l),w=["row","col","depth","depth2"];return`
      ${Uo(y,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${jo(w,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${o}, 1)));
        ${Go(t)}
      }
    `;const u=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],p=d[1],h=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(p===i&&u==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${h}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===o&&u==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const x=Ms(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${f}, ${p}, index + ${x});
      return sampleTexture(${r}, uv);
    }
  `}function TV(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],o=e[3]*s,a=e[2]*o,i=e[1]*a,{newShape:l,keptDims:c}=Jn(e);if(l.length<e.length){const g=Ho(t,l),m=["row","col","depth","depth2","depth3"];return`
      ${Uo(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${jo(m,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${o}, ${s})) +
          depth3;
        ${Go(t)}
      }
    `;const u=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],p=d[1];if(p===i&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===s&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const h=Ms(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${o} +
          depth2 * ${s} + depth3 + ${h};
      vec2 uv = uvFromFlat(${f}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function NV(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=Jn(e);if(s.length<e.length){const m=Ho(t,s),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${Uo(m)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${jo(x,o)});
      }
    `}const a=e[5],i=e[4]*a,l=e[3]*i,c=e[2]*l,u=e[1]*c;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Go(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,p=f[0],h=f[1];if(h===u&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===a&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const g=Ms(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${g};
      vec2 uv = uvFromFlat(${p}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Go(t){const e=t.name,n=L(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function RV(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=xb(t.shapeInfo.logicalShape,e.logicalShape),l=Ce(a),c=a-o;let u;const d=["x","y","z","w","u","v"];o===0?u="":a<2&&i.length>=1?u="coords = 0;":u=i.map(y=>`coords.${d[y+c]} = 0;`).join(`
`);let f="";a<2&&o>0?f="coords":f=t.shapeInfo.logicalShape.map((y,w)=>`coords.${d[w+c]}`).join(", ");let p="return outputValue;";const g=L(t.shapeInfo.logicalShape)===1,x=L(e.logicalShape)===1;if(o===1&&!g&&!x)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!x)a===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(i.length){const y=o-2,w=o-1;i.indexOf(y)>-1&&i.indexOf(w)>-1?p="return vec4(outputValue.x);":i.indexOf(y)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(w)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${f});
      ${p}
    }
  `}function DV(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.texShape,a=t.shapeInfo.texShape,i=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&i===l&&t.shapeInfo.flatOffset==null&&Ie(a,o))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=Ce(l),u=xb(t.shapeInfo.logicalShape,e.logicalShape),d=l-i;let f;const p=["x","y","z","w","u","v"];i===0?f="":l<2&&u.length>=1?f="coords = 0;":f=u.map(g=>`coords.${p[g+d]} = 0;`).join(`
`);let h="";return l<2&&i>0?h="coords":h=t.shapeInfo.logicalShape.map((g,m)=>`coords.${p[m+d]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${r}(${h});
    }
  `}function Ce(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function xx(t,e,n){const{newShape:r,keptDims:s}=Jn(e),o=e.length,a=t&&o===3&&e[0]===1,i=a?e.slice(1):r,l=!t&&o>1&&!Ie(e,n)&&r.length<o||a;return{useSqueezeShape:l,uniformShape:l?i:e,keptDims:s}}function Ho(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function jo(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FV(t,e,n,r){const s=n.map((w,v)=>{const $={logicalShape:w.shape,texShape:w.isUniform?null:w.texData.texShape,isUniform:w.isUniform,isPacked:w.isUniform?!1:w.texData.isPacked,flatOffset:null};return w.texData!=null&&w.texData.slice!=null&&w.texData.slice.flatOffset>0&&($.flatOffset=w.texData.slice.flatOffset),{name:e.variableNames[v],shapeInfo:$}}),o=s.map(w=>w.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=YB(s,a,e),l=t.createProgram(i);let c=null;const u=t.getUniformLocation(l,"NAN",!1);z().getNumber("WEBGL_VERSION")===1&&(c=t.getUniformLocation(l,"INFINITY",!1));const d=!1,f={},p={},h={};for(let w=0;w<e.variableNames.length;w++){const v=e.variableNames[w];f[v]=t.getUniformLocation(l,v,d),f[`offset${v}`]=t.getUniformLocation(l,`offset${v}`,d),e.enableShapeUniforms&&(p[`${v}Shape`]=t.getUniformLocation(l,`${v}Shape`,d),h[`${v}TexShape`]=t.getUniformLocation(l,`${v}TexShape`,d))}let g,m,x;e.enableShapeUniforms&&(g=t.getUniformLocation(l,"outShape",d),x=t.getUniformLocation(l,"outShapeStrides",d),m=t.getUniformLocation(l,"outTexShape",d));const y=[];return e.customUniforms&&e.customUniforms.forEach((w,v)=>{y[v]=t.getUniformLocation(l,w.name,d)}),{program:e,source:i,webGLProgram:l,uniformLocations:f,customUniformLocations:y,inShapeInfos:o,outShapeInfo:a,infLoc:c,nanLoc:u,inShapesLocations:p,inTexShapesLocations:h,outShapeLocation:g,outShapeStridesLocation:x,outTexShapeLocation:m}}function wb(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const s=n.logicalShape,o=e[r],a=o.shape;if(!Ie(s,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${a} must match`);if(n.isUniform&&o.isUniform)return;const i=n.texShape,l=o.isUniform?null:o.texData.texShape;if(!Ie(i,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${l} must match`)})}function AV(t,e,n,r,s){e.program.enableShapeUniforms||(wb(e.inShapeInfos,n),wb([e.outShapeInfo],[r]));const o=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o,a[0],a[1]):t.setOutputMatrixTexture(o,a[0],a[1]),t.setProgram(e.webGLProgram),z().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((l,c)=>{const u=e.program.variableNames[c],d=e.uniformLocations[u],f=e.uniformLocations[`offset${u}`],p=e.inShapesLocations[`${u}Shape`],h=e.inTexShapesLocations[`${u}TexShape`];if(p){const{uniformShape:g}=xx(e.program.packedInputs,l.shape,l.texData.texShape);switch(g.length){case 1:t.gl.uniform1iv(p,new Int32Array(g));break;case 2:t.gl.uniform2iv(p,new Int32Array(g));break;case 3:t.gl.uniform3iv(p,new Int32Array(g));break;case 4:t.gl.uniform4iv(p,new Int32Array(g));break}}if(h&&t.gl.uniform2i(h,l.texData.texShape[0],l.texData.texShape[1]),d!=null){if(l.isUniform){if(L(l.shape)<2)t.gl.uniform1f(d,l.uniformValues[0]);else{let g=l.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),t.gl.uniform1fv(d,g)}return}l.texData.slice!=null&&f!=null&&t.gl.uniform1i(f,l.texData.slice.flatOffset),t.setInputMatrixTexture(l.texData.texture,d,c)}});const i=e.outShapeLocation;if(i)switch(r.shape.length){case 1:t.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(i,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=ae(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s&&e.program.customUniforms.forEach((l,c)=>{const u=e.customUniformLocations[c],d=s[c];if(l.type==="float")t.gl.uniform1fv(u,d);else if(l.type==="vec2")t.gl.uniform2fv(u,d);else if(l.type==="vec3")t.gl.uniform3fv(u,d);else if(l.type==="vec4")t.gl.uniform4fv(u,d);else if(l.type==="int")t.gl.uniform1iv(u,d);else if(l.type==="ivec2")t.gl.uniform2iv(u,d);else if(l.type==="ivec3")t.gl.uniform3iv(u,d);else if(l.type==="ivec4")t.gl.uniform4iv(u,d);else throw Error(`uniform type ${l.type} is not supported yet.`)}),t.executeProgram()}function _V(t,e,n){let r="";e.concat(n).forEach(a=>{const i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:d}=xx(t.packedInputs,a.shape,l);let f="",p="",h="";if(u.length===1&&t.packedInputs){const $=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${$[0]>1}_${$[1]>1}`}else if(u.length===2&&!t.packedInputs)p=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!t.packedInputs){const $=ae(u);h=`${$[0]===l[1]}_${$[$.length-1]===l[1]}`}const g=a.shape.length,m=u.length===2&&Ie(a.shape,l),x=L(a.shape)===1,y=Ao(a.shape,n.shape),w=!t.packedInputs&&g===n.shape.length&&Ie(l,n.texData.texShape),v=t.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${g}_${w}_${c?d:""}_${u.length}_${x}_${y}_${m}_${f}_${p}_${h}_${v}_${i}`}else{const l=a.isUniform?"uniform":a.texData.texShape;r+=`${a.shape}_${l}_${i}`}});const s=t.userCode;let o=t.constructor.name;return o+="_"+r+"_"+s+`${z().getNumber("WEBGL_VERSION")}`,o}function en(t){return z().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PV{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Il.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Tt();this.outputShape=e,this.enableShapeUniforms=en(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Tf(["r","c","d"],e):Os(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Il.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Tt();this.outputShape=e,this.enableShapeUniforms=en(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Tf(["r","c","d"],e):Os(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MV{constructor(e){this.variableNames=["A"],this.outTexUsage=Jt.DOWNLOAD;const n=Tt();this.outputShape=e,this.userCode=`
      ${gb}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Jt.DOWNLOAD;const n=Tt();this.outputShape=e,this.userCode=`
      ${gb}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BV{constructor(e,n=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Tt();this.outputShape=e,this.enableShapeUniforms=en(this.outputShape.length);let s="result";n&&(s="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?gx():mx(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VV{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Tt();this.outputShape=e,this.enableShapeUniforms=en(this.outputShape.length);let s="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){const l=a*2+i;s+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?gx():mx(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WV(t){const e=Tt(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return CB(t,n)}function zV(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return NB(t,e)}function UV(t){const e=new Uint16Array([0,1,2,2,1,3]);return RB(t,e)}function Nl(t,e,n,r,s,o){FB(e,n);const a=DB(t),i=t.TEXTURE_2D;return re(t,()=>t.bindTexture(i,a)),re(t,()=>t.texParameteri(i,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),re(t,()=>t.texParameteri(i,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),re(t,()=>t.texParameteri(i,t.TEXTURE_MIN_FILTER,t.NEAREST)),re(t,()=>t.texParameteri(i,t.TEXTURE_MAG_FILTER,t.NEAREST)),re(t,()=>t.texImage2D(i,0,r,e,n,0,s,o,null)),re(t,()=>t.bindTexture(t.TEXTURE_2D,null)),a}function $b(t){return t.internalFormatFloat}function GV(t,e,n,r){const[s,o]=El(e,n);return Nl(t,s,o,$b(r),r.textureFormatFloat,t.FLOAT)}function bb(t){return t.internalFormatHalfFloat}function HV(t,e,n,r){const[s,o]=El(e,n);return Nl(t,s,o,bb(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Cb(t){return t.downloadTextureFormat}function jV(t,e,n,r){const[s,o]=El(e,n);return Nl(t,s,o,Cb(r),t.RGBA,t.UNSIGNED_BYTE)}function kb(t){return t.internalFormatPackedFloat}function KV(t,e,n,r){const[s,o]=Vo(e,n);return Nl(t,s,o,kb(r),t.RGBA,t.FLOAT)}function Sb(t){return t.internalFormatPackedHalfFloat}function qV(t,e,n,r){const[s,o]=Vo(e,n);return Nl(t,s,o,Sb(r),t.RGBA,r.textureTypeHalfFloat)}function XV(t,e,n){const r=0,s=3*4,o=3*4+2*4;return re(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),pb(t,e,"clipSpacePos",n,3,o,r)&&pb(t,e,"uv",n,2,o,s)}function YV(t,e,n,r,s,o){re(t,()=>t.bindTexture(t.TEXTURE_2D,e));let a,i,l;s instanceof Uint8Array?(a=new Uint8Array(n*r*4),i=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*r*4),i=t.FLOAT,l=o.internalFormatPackedFloat),a.set(s),re(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,i,a)),re(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function QV(t,e,n){re(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?re(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):re(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),re(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function ZV(t,e,n,r){const s=t.createBuffer();re(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const i=4*4*e*n;return re(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)),re(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),re(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}function JV(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function eW(t,e,n,r){const[s,o]=El(e,n),a=4,i=new Uint8Array(gB(e*n,a));return re(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function tW(t,e,n,r,s,o,a,i){const l=t,c=new Float32Array(xB(o,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function nW(t,e,n){const r=new Float32Array(e*n*4);return re(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rW{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const n=z().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,pB(n,e)):this.gl=Vn(n);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(z().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=kf(this.gl,o),mn(this.gl,a))this.textureHalfFloatExtension=kf(this.gl,a);else if(z().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),mn(this.gl,s))this.colorBufferHalfFloatExtension=kf(this.gl,s);else if(z().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",mn(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(mn(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=zV(this.gl),this.indexBuffer=UV(this.gl),this.framebuffer=AB(this.gl),this.textureConfig=lx(this.gl,this.textureHalfFloatExtension)}get debug(){return z().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;re(e,()=>e.finish()),re(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),re(e,()=>e.deleteFramebuffer(this.framebuffer)),re(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),re(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),re(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),GV(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),HV(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),jV(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),QV(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,s){this.throwIfDisposed(),YV(this.gl,e,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),qV(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),KV(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(hb(this.gl,this.framebuffer),this.outputTexture=null),re(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>eW(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,s,o,a){return tW(this.gl,e,n,r,s,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return JV(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const s=ZV(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(z().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const a=s.clientWaitSync(o,0,0);return a===s.ALREADY_SIGNALED||a===s.CONDITION_SATISFIED},n=o}else z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>nW(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl,r=kB(n,e);this.vertexShader==null&&(this.vertexShader=WV(n));const s=EB(n);return re(n,()=>n.attachShader(s,this.vertexShader)),re(n,()=>n.attachShader(s,r)),TB(n,s),this.debug&&cx(n,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=XV(n,this.program,this.vertexBuffer)),s}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&re(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&cx(this.gl,this.program),re(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?PB(this.gl,e,n):OB(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),re(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),MB(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[s,o]=Vo(n,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,n,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,n)}setOutputPackedMatrixWriteRegion(e,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&cx(this.gl,this.program),Sf(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),re(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),re(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=kf(this.gl,z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Jh(()=>this.disposed||this.isQueryAvailable(e,z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=sW(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),!(this.itemsToPoll.length>1)&&Jh(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),ux(this.gl,e,this.framebuffer),this.debug&&Sf(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(ux(this.gl,this.outputTexture,this.framebuffer),this.debug&&Sf(this.gl)):hb(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const s=this.gl;ux(s,e,this.framebuffer),this.debug&&Sf(s),this.outputTexture=e,re(s,()=>s.viewport(0,0,n,r)),re(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,s){this.throwIfDisposed(),re(this.gl,()=>this.gl.scissor(e,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function sW(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:oW,bincountImpl:Ib,bincountReduceImpl:aW,ceilImpl:iW,concatImpl:lW,equalImpl:cW,expImpl:uW,expm1Impl:dW,floorImpl:fW,gatherNdImpl:pW,gatherV2Impl:hW,greaterImpl:mW,greaterEqualImpl:gW,lessImpl:xW,lessEqualImpl:yW,linSpaceImpl:vW,logImpl:wW,maxImpl:$W,maximumImpl:bW,minimumImpl:CW,multiplyImpl:kW,negImpl:SW,notEqualImpl:IW,prodImpl:EW,rangeImpl:TW,rsqrtImpl:NW,sigmoidImpl:RW,simpleAbsImpl:Eb,sliceImpl:DW,sparseFillEmptyRowsImpl:FW,sparseReshapeImpl:AW,sparseSegmentReductionImpl:Tb,sqrtImpl:_W,stridedSliceImpl:PW,stringNGramsImpl:OW,stringSplitImpl:MW,stringToHashBucketFastImpl:LW,subImpl:BW,tileImpl:VW,topKImpl:WW,transposeImpl:yx,uniqueImpl:zW}=r3;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nb(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function Nt(t,e){return e===1?[t]:Nb(t,e)}function UW(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GW{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const n=e.length;if(n===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const r=Nt("rc",n),s=Ce(n),o=jW(n,e,r),a=KW(n,e[e.length-1],e[e.length-2],r),i=qW(e,r);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}}function HW(t,e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let a=2;a<t;a++)o=`${e[e.length-1-a]},`+o;n.push(o)}return n}function jW(t,e,n){if(t===1)return`rc > ${e[0]}`;let r="";for(let s=t-2;s<t;s++)r+=`${n[s]} >= ${e[s]}`,s<t-1&&(r+="||");return r}function KW(t,e,n,r){if(t===1)return"";const s=r.slice(-2);return`
    int r = ${s[0]};
    int c = ${s[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${e};
    bool rEdge = rp1 >= ${n};
  `}function qW(t,e){const n=t.length,r=HW(n,e);return n===1?`getA(rc),
            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${r[0]}),
          cEdge ? 0. : getA(${r[1]}),
          rEdge ? 0. : getA(${r[2]}),
          rEdge || cEdge ? 0. : getA(${r[3]})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rb{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=en(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${XW(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?gx():mx(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function XW(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?XB(["r","c","d"],"inputShape"):Os(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YW{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,n,r){const s=Fb(n,r),o=Ab(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const a=Db(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[o].shift();return this.usedTextures[o].push(l),l}let i;return s===pt.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===pt.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===pt.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===pt.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===pt.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,n,r,s){if(this.freeTextures==null)return;const o=Fb(r,s),a=Ab(n,o,s);a in this.freeTextures||(this.freeTextures[a]=[]);const i=Db(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=z().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const c=this.usedTextures[a],u=c.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function QW(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}function Db(t,e,n,r,s){const o=ZW(e,r);let a;if(s){const[l,c]=Vo(t[0],t[1]);a=l*c}else{const[l,c]=El(t[0],t[1]);a=l*c}const i=QW(n,o);return a*i}function ZW(t,e){switch(t){case pt.PACKED_2X2_FLOAT32:return kb(e);case pt.PACKED_2X2_FLOAT16:return Sb(e);case pt.UNPACKED_FLOAT32:return $b(e);case pt.UNPACKED_FLOAT16:return bb(e);case pt.PACKED_4X1_UNSIGNED_BYTE:return Cb(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function JW(t){return z().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?pt.PACKED_2X2_FLOAT32:pt.UNPACKED_FLOAT32:t?pt.PACKED_2X2_FLOAT16:pt.UNPACKED_FLOAT16}function Fb(t,e){if(t===Jt.UPLOAD)return pt.PACKED_2X2_FLOAT32;if(t===Jt.RENDER||t==null)return JW(e);if(t===Jt.DOWNLOAD||t===Jt.PIXELS)return pt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function Ab(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jr{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=en(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Sn="if (isnan(x)) return x;",ez="return x;",_b="return abs(x);",tz="return (x >= 0.0) ? x : (exp(x) - 1.0);",nz=Sn+`
  return (x < 0.0) ? 0.0 : x;
`,rz=Sn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Nf="return x;",sz="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oz="return x;",az=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,iz=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lz=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cz="return 1.0 / (1.0 + exp(-1.0 * x));";class Ko{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=en(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uz{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const n=e.length,r=Nt("rc",n),s=Ce(n),o=UW(n,r),a=r.slice(-2),i=n<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dz=nf,fz=1e-7,pz=1e-4,Rf={};function hz(t){return t in Rf||(Rf[t]={}),Rf[t]}const mz=z().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),gz=600;function xz(){return z().global.screen==null?1024:z().global.screen.height*z().global.screen.width*window.devicePixelRatio*gz/1024/1024}class Df extends Hc{constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!z().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){const n=Vn(z().getNumber("WEBGL_VERSION"));this.binaryCache=hz(z().getNumber("WEBGL_VERSION")),this.gpgpu=new rW(n),this.canvas=n.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new YW(this.gpgpu),this.numMBBeforeWarning=xz(),this.texData=new Qh(this,Br())}nextDataId(){return Df.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,n,r){if((z().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||z().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:e,usage:Jt.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,s,o){if(z().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:n,usage:Jt.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:a,shape:i,isPacked:l}=n;if(a!=null){let f;l?f=new Ko(i,Nf):f=new jr(i,Nf);const p=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:s}],s),h=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),h}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let u;c&&(u=Wt());let d;if(s==="complex64"){const f=this.readSync(o.real.dataId),p=this.readSync(o.imag.dataId);d=ar(f,p)}else d=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Wt()-u),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const h=this.pendingRead.get(e);return new Promise(g=>h.push(g))}const n=this.texData.get(e),{values:r,shape:s,slice:o,dtype:a,complexTensorInfos:i,isPacked:l}=n;if(o!=null){let h;l?h=new Ko(s,Nf):h=new jr(s,Nf);const g=this.runWebGLProgram(h,[{dataId:e,shape:s,dtype:a}],a),m=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),m}if(r!=null)return this.convertAndCacheOnCPU(e);if(!z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&z().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(a!=="complex64"&&z().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const h=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(h.texture,...Cf(s))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(a==="complex64"){const h=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),g=h[0],m=h[1];d=ar(g,m)}else if(c==null)d=this.getValuesFromTexture(e);else{const h=L(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,h)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const h=this.gpgpu.gl;re(h,()=>h.deleteBuffer(c))}const f=this.convertAndCacheOnCPU(e,d),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(h=>h(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Br().removeDataId(e,this),this.pendingDeletes--),f}bufferSync(e){const n=this.readSync(e.dataId);let r=n;if(e.dtype==="string")try{r=n.map(s=>gs(s))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return de(e.shape,e.dtype,r)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!$B(r))throw z().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:s}=this.texData.get(e),o=L(n);if(z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(p.texture,...Cf(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(f),h}const a=z().getBool("WEBGL_PACK")&&s===!0,i=a?dx(n):n,l=a?new LV(i):new MV(i),c=this.runWebGLProgram(l,[{shape:i,dtype:r,dataId:e}],"float32"),u=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=Zn(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=Zn(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(o);i.kernelMs=By(l),i.getExtraProfileInfo=()=>l.map((c,u)=>({name:a[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Wt(),endMs:null}}endTimer(e){return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Wt(),e)}async getQueryTime(e){if(z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:s,usage:o,isPacked:a,slice:i}=this.texData.get(e),l=i&&i.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,o,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=mz){return z().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&L(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){At("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return dz(e.shape,n)}packedUnaryOp(e,n,r){const s=new Ko(e.shape,n),o=this.compileAndRun(s,[e],r);return Br().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=Eb(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(z().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,_b,e.dtype);const n=new jr(e.shape,_b),r=this.compileAndRun(n,[e]);return Br().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&An(r[0])){const o=r.map(a=>_n(a));s=this.write(o,e,n)}else s=this.write(r,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,r){const{dataId:s}=this.makeTensorInfo(e,n,r);return Br().makeTensorFromDataId(s,e,n,this)}unpackTensor(e){const n=new uz(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new GW(e.shape),r=!0;return this.runWebGLProgram(n,[e],e.dtype,null,r)}packedReshape(e,n){const r=[Wo(e.shape),...zo(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Wo(n),...zo(n)],a=new Rb(o,r),i=!0,l=[r],c=this.runWebGLProgram(a,[s],e.dtype,l,i);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(e){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:o}=n,a=dx(s);let i;const l=Cf(a);r?i=new OV(a):i=new PV(a);const c=!0,u=[l],d=this.runWebGLProgram(i,[{shape:a,dtype:o,dataId:e}],o,u,c);return{dtype:o,shape:s,dataId:d.dataId}}runWebGLProgram(e,n,r,s,o=!1){const a=this.makeTensorInfo(e.outputShape,r),i=this.texData.get(a.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===Il.DENSE){const m=Cf(e.outputShape);i.texShape=m.map(x=>x*2)}if(e.outTexUsage!=null&&(i.usage=e.outTexUsage),L(a.shape)===0)return i.values=Je(a.dtype,0),a;const l=[],c=n.map(m=>{if(m.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(m.dataId);if(x.texture==null){if(!e.packedInputs&&L(m.shape)<=z().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:m.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=m.shape)}else if(!!x.isPacked!=!!e.packedInputs)m=x.isPacked?this.unpackTensor(m):this.packTensor(m),l.push(m),x=this.texData.get(m.dataId);else if(x.isPacked&&!Ef(x.shape,m.shape)){const y=m,w=m.shape;m.shape=x.shape,m=this.packedReshape(m,w),l.push(m),x=this.texData.get(m.dataId),y.shape=w}return this.uploadToGPU(m.dataId),{shape:m.shape,texData:x,isUniform:!1}});this.uploadToGPU(a.dataId);const u={shape:a.shape,texData:i,isUniform:!1},d=_V(e,c,u),f=this.getAndSaveBinary(d,()=>FV(this.gpgpu,e,c,u)),p=this.activeTimers!=null;let h;p&&(h=this.startTimer()),AV(this.gpgpu,f,c,u,s),l.forEach(m=>this.disposeIntermediateTensorInfo(m)),p&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)}));const g=z().get("WEBGL_FLUSH_THRESHOLD");if(g>0){const m=Wt();m-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=m)}if(!z().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&o===!1){const m=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),m}return a}compileAndRun(e,n,r,s,o=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,s,o)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(z().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Xe(()=>{if(!z().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=z().getBool("DEBUG");z().set("DEBUG",!1);const n=this.abs(ve(1e-8)).dataSync()[0];if(z().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?fz:pz}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:s,values:o,texture:a,usage:i,isPacked:l}=n;if(a!=null)return;const c=this.activeTimers!=null;let u;c&&(u=Wt());let d=n.texShape;if(d==null&&(d=VB(r,l),n.texShape=d),o!=null){const f=dx(r);let p,h=d[1],g=d[0];const m=o instanceof Uint8Array||o instanceof Uint8ClampedArray;l?([h,g]=Vo(d[0],d[1]),p=new VV(f,m)):p=new BV(f,m);const x=this.makeTensorInfo([g,h],s);m?this.texData.get(x.dataId).usage=Jt.PIXELS:this.texData.get(x.dataId).usage=Jt.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),h,g,o);const y=[[g,h]],w=!0,v=this.runWebGLProgram(p,[x],s,y,w),$=this.texData.get(v.dataId);n.texture=$.texture,n.texShape=$.texShape,n.isPacked=$.isPacked,n.usage=$.usage,this.disposeIntermediateTensorInfo(x),this.texData.delete(v.dataId),n.values=null,c&&(this.uploadWaitMs+=Wt()-u)}else{const f=this.acquireTexture(d,i,s,l);n.texture=f}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:s}=r;return this.releaseGPUData(e),n!=null&&(r.values=yz(n,s)),r.values}acquireTexture(e,n,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*Kc(n)}}Df.nextDataId=0;function yz(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Mm()&&cg("webgl",()=>new Df,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pb=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class qo{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=ye(n,r),this.enableShapeUniforms=en(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ff=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;class Rl{constructor(e,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ye(n,r);const o=this.outputShape.length;this.enableShapeUniforms=en(o);let a="";if(s)if(o===0||L(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ce(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Nt("coords",o);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const vz={kernelName:gi,backendName:"webgl",kernelFunc:jt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kr(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(o.dataId),i=jt({inputs:{x:r},backend:n}),l=jt({inputs:{x:s},backend:n});return a.complexTensorInfos={real:i,imag:l},o}const wz={kernelName:iu,backendName:"webgl",kernelFunc:Kr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ob="return (a < 0.) ? b * a : a;",Mb=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $z(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,a=n.makeTensorInfo([],"float32",er(o,"float32")),i=z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rl(Mb,s.shape,a.shape):new qo(Ob,s.shape,a.shape),l=n.runWebGLProgram(i,[s,a],"float32");return n.disposeIntermediateTensorInfo(a),l}const bz={kernelName:_u,backendName:"webgl",kernelFunc:$z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lb="return (a < 0.) ? b * a : a;",Bb=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Cz(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,o=z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rl(Bb,r.shape,s.shape):new qo(Lb,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],"float32")}const kz={kernelName:Ju,backendName:"webgl",kernelFunc:Cz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vb="if (isnan(x)) return x;",Sz=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Iz=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function me({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{const{x:a}=s,i=o,l=r||a.dtype;if(i.shouldExecuteOnCPU([a])&&n!=null){const d=i.texData.get(a.dataId),f=n(d.values,l);return i.makeTensorInfo(a.shape,l,f)}const c=z().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Ko(a.shape,e):u=new jr(a.shape,t),i.runWebGLProgram(u,[a],l)}}function ht({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:a,backend:i})=>{const{a:l,b:c}=a,u=i;if(r&&l.dtype==="complex64"){const h=u.texData.get(l.dataId),g=u.texData.get(c.dataId),[m,x]=[[h.complexTensorInfos.real,g.complexTensorInfos.real],[h.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(w=>{const[v,$]=w,b={dataId:v.dataId,dtype:v.dtype,shape:l.shape},C={dataId:$.dataId,dtype:$.dtype,shape:c.shape},I=new qo(t,l.shape,c.shape);return u.runWebGLProgram(I,[b,C],zt(v.dtype,$.dtype))}),y=Kr({inputs:{real:m,imag:x},backend:u});return u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(x),y}const d=o||zt(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&s!=null){const h=u.texData.get(l.dataId).values,g=u.texData.get(c.dataId).values,m=l.dtype==="string"?Ds(h):h,x=l.dtype==="string"?Ds(g):g,[y,w]=s(l.shape,c.shape,m,x,d),v=u.makeTensorInfo(w,d),$=u.texData.get(v.dataId);return $.values=y,v}const f=z().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return f?p=new Rl(e,l.shape,c.shape,n):p=new qo(t,l.shape,c.shape),u.runWebGLProgram(p,[l,c],d)}}function Af(t,e=!1){if(t==="linear")return e?oz:ez;if(t==="relu")return e?iz:nz;if(t==="elu")return e?az:tz;if(t==="relu6")return e?lz:rz;if(t==="prelu")return e?Bb:Lb;if(t==="leakyrelu")return e?Mb:Ob;if(t==="sigmoid")return e?cz:sz;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wb{constructor(e,n,r,s=!1,o=!1,a=!1,i=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=en(this.outputShape.length);const u=s?e[1]:e[2],d=Math.ceil(u/2),f=s?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",h=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",x="";i&&(l?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:c?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,x="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let w="rc.x",v="rc.x";e[0]<n[0]?w=`int(min(float(rc.x), ${e[0]-1}.))`:n[0]<e[0]&&(v=`int(min(float(rc.x), ${n[0]-1}.))`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${d}; i++) {
          int batchA = ${w};
          int batchB = ${v};
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${g[0]});
          result += (${h[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${x}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zb={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Ub{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ye(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gb="return a * b;";function vx(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=zt(r.dtype,s.dtype);if(r.dtype==="complex64"){const i=n.texData.get(r.dataId),l=n.texData.get(s.dataId),c=new Ub(zb.REAL,r.shape,s.shape),u=new Ub(zb.IMAG,r.shape,s.shape),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:r.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],f=n.runWebGLProgram(c,d,"float32"),p=n.runWebGLProgram(u,d,"float32"),h=Kr({inputs:{real:f,imag:p},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),h}if(n.shouldExecuteOnCPU([r,s])){const i=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[c,u]=kW(r.shape,s.shape,i.values,l.values,o),d=n.makeTensorInfo(u,o),f=n.texData.get(d.dataId);return f.values=c,d}let a;return z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Rl(Gb,r.shape,s.shape):a=new qo(Gb,r.shape,s.shape),n.runWebGLProgram(a,[r,s],o)}const Ez={kernelName:Ri,backendName:"webgl",kernelFunc:vx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tz(t,e,n){const r=[Wo(t.shape),...zo(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[Wo(e),...zo(e)],a=new Rb(o,r),i=!0,l=[r],c=n.runWebGLProgram(a,[s],t.dtype,l,i);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ee(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:o}=r,a=n,i=L(s.shape),l=em(o,i),c=L(l);S(i===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const u=a.texData.get(s.dataId);return u.isPacked&&!Ef(s.shape,l)&&!(u.texture!==null&&Ef(u.shape,l))?Tz(s,l,a):(a.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const Nz={kernelName:rd,backendName:"webgl",kernelFunc:ee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hb{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:a}=e;this.outputShape=[s,a];const i=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(n!=null){const d=1/n;c=`sumValue += dot(values * ${kt(d)?d.toPrecision(2):d}, ones);`}let u="";o%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${i};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rz{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:a}=e;this.outputShape=[s,a];let i="0.0",l="";n==="prod"?i="1.0":n==="min"?(i="1.0 / 1e-20",l="min"):n==="max"&&(i="-1.0 / 1e-20",l="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const u=Math.floor(r/4)*4,d=r%4;let f=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";n==="all"?(i="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):n==="any"&&(i="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let h="";o%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dz(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=xf(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function Ls(t,e,n,r){const s=Dz(t.shape);let o=t;for(let a=0;a<s.length;a++){const{inSize:i,windowSize:l,outSize:c}=s[a];let u,d;n==="mean"?u=a===0?new Hb({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c},i):new Hb({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c}):u=new Rz({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c},n),d=o,o=r.runWebGLProgram(u,[o],e),d.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(d)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fz{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let a=0;a<r.length;a++)r[a]=e[n[a]];this.outputShape=r,this.rank=r.length;const s=Ce(this.rank),o=Az(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function Az(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _z{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let u=0;u<r.length;u++)r[u]=e[n[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Ce(this.rank),o=Nb("rc",this.rank),a=new Array(this.rank);for(let u=0;u<n.length;u++)a[n[u]]=o[u];const i=`vec2(${a.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _f(t,e,n){const r=z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _z(t.shape,e):new Fz(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pz(t,e,n,r){const s=e,o=t.shape.length,a=ge(s,t.shape);let i=a;const l=Ye(i,o),c=l!=null;let u=t;c&&(u=_f(t,l,r),i=Qe(i.length,o)),ft("sum",i,o);const[d,f]=dt(u.shape,i);let p=d;n&&(p=tt(d,a));const h=L(f),m=L(t.shape)/h,x=ee({inputs:{x:u},attrs:{shape:[m,h]},backend:r}),y=Ld(t.dtype),w=Ls(x,y,"sum",r),v=ee({inputs:{x:w},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(w),c&&r.disposeIntermediateTensorInfo(u),v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;return Pz(s,o,a,n)}const Oz={kernelName:ud,backendName:"webgl",kernelFunc:Pf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rt(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:o}=r,a=n,i=s.shape.length,l=new Array(i);for(let u=0;u<l.length;u++)l[u]=s.shape[o[u]];let c;if(a.shouldExecuteOnCPU([s])){const d=a.texData.get(s.dataId).values,f=yx(d,s.shape,s.dtype,o,l);c=a.makeTensorInfo(l,s.dtype);const p=a.texData.get(c.dataId);p.values=f}else c=_f(s,o,a);return c}const Mz={kernelName:Sd,backendName:"webgl",kernelFunc:Rt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jb=1e3;function Of({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:l=null}){const c=t.shape.length,u=e.shape.length,d=n?t.shape[c-2]:t.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],p=n?t.shape[c-1]:t.shape[c-2],h=r?e.shape[u-2]:e.shape[u-1],g=t.shape.slice(0,-2),m=e.shape.slice(0,-2),x=L(g),y=L(m),w=x===y||x===1||y===1;S(c>=2&&u>=2&&w,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${g}) and (${m}).`);const $=(x>y?t.shape.slice(0,-2):e.shape.slice(0,-2)).concat([p,h]);S(d===f,()=>`Error in matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const b=n?[x,d,p]:[x,p,d],C=r?[y,h,f]:[y,f,h],I=ee({inputs:{x:t},backend:s,attrs:{shape:b}}),E=ee({inputs:{x:e},backend:s,attrs:{shape:C}}),T=[I,E],D=Math.max(x,y),F=n?I.shape[1]:I.shape[2],A=o!=null,P=a!=null,M=l==="leakyrelu",O=l!=null?Af(l,!0):null,U=A||P||M||O!=null;let B;if((p===1||h===1)&&F>jb&&U===!1){let j=I,_=E;n&&(j=Rt({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),T.push(j)),r&&(_=Rt({inputs:{x:E},backend:s,attrs:{perm:[0,2,1]}}),T.push(_));const V=h!==1,W=h===1;let K=j;V&&(K=ee({inputs:{x:j},backend:s,attrs:{shape:[D,F,1]}}),T.push(K));const q=h===1?2:1;let Y=_;W&&(Y=ee({inputs:{x:_},backend:s,attrs:{shape:[D,1,F]}}),T.push(Y));const J=vx({inputs:{a:K,b:Y},backend:s});B=Pf({inputs:{x:J},backend:s,attrs:{axis:q,keepDims:!0}}),T.push(J)}else{const j=zt(t.dtype,e.dtype),_=new Wb(b,C,[D,p,h],n,r,A,O,P,M),V=[I,E];if(o!=null&&V.push(o),P&&V.push(a),M){const W=s.makeTensorInfo([],"float32",er(i,"float32"));V.push(W),T.push(W)}B=s.runWebGLProgram(_,V,j)}const G=ee({inputs:{x:B},backend:s,attrs:{shape:$}});T.push(B);for(const j of T)s.disposeIntermediateTensorInfo(j);return G}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lz(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:a,preluActivationWeights:i}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;return Of({a:s,b:o,transposeA:l,transposeB:c,backend:n,bias:a,preluActivationWeights:i,leakyreluAlpha:d,activation:u})}const Bz={kernelName:Qi,backendName:"webgl",kernelFunc:Lz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kb="return abs(x);";function Vz(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=n.texData.get(r.dataId),a=Eb(o.values);return n.makeTensorInfo(r.shape,r.dtype,a)}let s;return z().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Ko(r.shape,Kb):s=new jr(r.shape,Kb),n.runWebGLProgram(s,[r],r.dtype)}const Wz={kernelName:Xc,backendName:"webgl",kernelFunc:Vz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zz=Sn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Uz=me({opSnippet:zz}),Gz={kernelName:qa,backendName:"webgl",kernelFunc:Uz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hz=Sn+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,jz=me({opSnippet:Hz}),Kz={kernelName:Xa,backendName:"webgl",kernelFunc:jz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qb="return a + b;",qz=ht({opSnippet:qb,packedOpSnippet:qb,supportsComplex:!0,cpuKernelImpl:oW}),Xz={kernelName:$o,backendName:"webgl",kernelFunc:qz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yz{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((o,a)=>`T${a}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qz{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((o,a)=>`T${a}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mf(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return jt({inputs:{x:r[0]},backend:n});if(r.length>z().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=Mf({inputs:r.slice(0,l),backend:n}),u=Mf({inputs:r.slice(l),backend:n});return Mf({inputs:[c,u],backend:n})}const s=r.map(l=>l.dtype).reduce((l,c)=>zt(l,c)),o=r.map(l=>l.shape),i=z().getBool("WEBGL_PACK")?new Qz(r[0].shape,o):new Yz(r[0].shape,o);return n.runWebGLProgram(i,r,s)}const Zz={kernelName:Yc,backendName:"webgl",kernelFunc:Mf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jz(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,i=s.shape.length,l=ge(o,s.shape);let c=l;const u=Ye(c,i);let d=s;u!=null&&(d=Rt({inputs:{x:s},backend:n,attrs:{perm:u}}),c=Qe(c.length,i)),ft("all",c,i);const[f,p]=dt(d.shape,c),h=L(p),g=ee({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}}),m=Ls(g,g.dtype,"all",n);let x;if(a){const y=tt(f,l);x=ee({inputs:{x:m},backend:n,attrs:{shape:y}})}else x=ee({inputs:{x:m},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),u!=null&&n.disposeIntermediateTensorInfo(d),x}const eU={kernelName:Qc,backendName:"webgl",kernelFunc:Jz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,i=s.shape.length,l=ge(o,s.shape);let c=l;const u=Ye(c,i);let d=s;u!=null&&(d=Rt({inputs:{x:s},backend:n,attrs:{perm:u}}),c=Qe(c.length,i)),ft("any",c,i);const[f,p]=dt(d.shape,c),h=L(p),g=ee({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}}),m=Ls(g,g.dtype,"any",n);let x;if(a){const y=tt(f,l);x=ee({inputs:{x:m},backend:n,attrs:{shape:y}})}else x=ee({inputs:{x:m},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),u!=null&&n.disposeIntermediateTensorInfo(d),x}const nU={kernelName:Zc,backendName:"webgl",kernelFunc:tU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rU{constructor(e,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:a}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];const i=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sU{constructor(e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],a=Math.ceil(o/n);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),s||this.variableNames.push("bestIndicesA");const i=this.outputShape,l=i.length,c=Ce(l),u=Nt("coords",l);let d,f;if(a===1){f=l+1;const I=Ce(f);d=`
        ${I} sourceLocR = ${I}(${u.join()}, 0);
        ++${u[l-1]};
        ${I} sourceLocG = ${I}(${u.join()}, 0);
        ++${u[l-2]};
        ${I} sourceLocA = ${I}(${u.join()}, 0);
        --${u[l-1]};
        ${I} sourceLocB = ${I}(${u.join()}, 0);
        --${u[l-2]};`}else f=l,d=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,f),h="."+p[f-1],g=p.map(I=>"int "+I),m=Nt("sourceLocR",f-1).concat("inIdx.r"),x=Nt("sourceLocG",f-1).concat("inIdx.g"),y=Nt("sourceLocB",f-1).concat("inIdx.b"),w=Nt("sourceLocA",f-1).concat("inIdx.a"),v=r==="max"?"greaterThan":"lessThan",$=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${w.join()})));`,b=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,C=s?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${C}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${i[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${i[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${b};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${$}
          vec4 candidate = ${b};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xb(t,e,n,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const a=xf(o),i={windowSize:a,inSize:o,batchSize:s,outSize:Math.ceil(o/a)},l=new rU(i,n,r==null),c=[e];r!=null&&c.push(r);const u=t.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const d=Xb(t,e,n,u);return t.disposeIntermediateTensorInfo(u),d}function Yb(t,e,n,r=null){const s=r!=null?r.shape:e.shape,o=s[s.length-1],a=xf(o),i=new sU(s,a,n,r==null),l=r==null?[e]:[e,r],c=t.runWebGLProgram(i,l,"int32");if(c.shape.length===e.shape.length){const u=Yb(t,e,n,c);return t.disposeIntermediateTensorInfo(c),u}return c}function Qb(t,e,n,r){const s=[n];if(ft("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!z().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],a=t.texData.get(e.dataId),i=a!==null&&a.isPacked;let l=e;i&&(l=t.unpackTensor(e),o.push(l));const[c,u]=dt(l.shape,s),d=L(u),f=ee({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}});o.push(f);const p=Xb(t,f,r);o.push(p);const h=ee({inputs:{x:p},backend:t,attrs:{shape:c}});return o.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}return Yb(t,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oU(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let a=ge(o,s.shape);const i=Ye(a,s.shape.length);let l=s;const c=[];i!=null&&(l=Rt({inputs:{x:s},backend:n,attrs:{perm:i}}),c.push(l),a=Qe(a.length,l.shape.length)),ft("argMax",[a[0]],l.shape.length);const u=Qb(n,l,a[0],"max");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),u}const aU={kernelName:Jc,backendName:"webgl",kernelFunc:oU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iU(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let a=ge(o,s.shape);const i=Ye(a,s.shape.length);let l=s;const c=[];i!=null&&(l=Rt({inputs:{x:s},backend:n,attrs:{perm:i}}),c.push(l),a=Qe(a.length,l.shape.length)),ft("argMin",[a[0]],l.shape.length);const u=Qb(n,l,a[0],"min");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),u}const lU={kernelName:eu,backendName:"webgl",kernelFunc:iU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cU=Sn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,uU=me({opSnippet:cU}),dU={kernelName:Ya,backendName:"webgl",kernelFunc:uU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fU=Sn+"return log(x + sqrt(x * x + 1.0));",pU=me({opSnippet:fU}),hU={kernelName:Qa,backendName:"webgl",kernelFunc:pU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mU=Sn+`
  return atan(x);
`,gU=me({opSnippet:mU}),xU={kernelName:Za,backendName:"webgl",kernelFunc:gU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yU=Sz+`
  return atan(a, b);
`,vU=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Iz+`
  return result;
`,wU=ht({opSnippet:yU,packedOpSnippet:vU}),$U={kernelName:ei,backendName:"webgl",kernelFunc:wU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bU=Sn+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,CU=me({opSnippet:bU}),kU={kernelName:Ja,backendName:"webgl",kernelFunc:CU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dl{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const g=n==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(g||(y="-1.0 / 1e-20"),r){const I=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${l});
        const ivec2 pads = ivec2(${p}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?m:x:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let v=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(v="avgValue / count");const $=Math.floor(a/4)*4,b=a%4,C=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${p}, ${h});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${$}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${C}
          }

          int xC = xCCorner + ${$};
          if (${b===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${C}
          } else if (${b===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${C}
          } else if (${b===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${C}
          }
        }
        setOutput(${v});
      }
    `}}class wx{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,f=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,g=e.effectiveFilterWidth,m=e.padInfo.front,x=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const w=n==="avg";let v="0.0";if(w||(v="-1.0 / 1e-20"),r){const T=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${l}, ${c});
        const ivec3 pads = ivec3(${m}, ${x}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${T} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let b=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(b="avgValue / count");const C=Math.floor(a/4)*4,I=a%4,E=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${l}, ${c});
      const ivec3 pads = ivec3(${m}, ${x}, ${y});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${C}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${C};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${E}
            }
          }
          setOutput(${b});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SU(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;Tl(s,"avgPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,c=1;S(vt(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const u=hn(s.shape,o,a,c,i,l);if(u.filterWidth===1&&u.filterHeight===1&&Ie(u.inShape,u.outShape))return jt({inputs:{x:s},backend:n});const d=new Dl(u,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}const IU={kernelName:tu,backendName:"webgl",kernelFunc:SU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EU(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:c}=r,u=[1,1,1],d=nr(s.shape,o,a,u,i,l,c),f=new wx(d,"avg",!1);return n.runWebGLProgram(f,[s],"float32")}const TU={kernelName:nu,backendName:"webgl",kernelFunc:EU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NU{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,d=c-1-e.padInfo.left,f=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${d});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class RU{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=d-1-e.padInfo.front,g=f-1-e.padInfo.top,m=p-1-e.padInfo.left,x=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${g}, ${m});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,a=o,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=r,d=[1,1,1],f=nr(a.shape,i,l,d,c,u),p=new RU(f);return n.runWebGLProgram(p,[s],a.dtype)}const FU={kernelName:um,backendName:"webgl",kernelFunc:DU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AU(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,a=o;Tl([s,o],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=r,u=hn(a.shape,i,l,1,c),d=new NU(u);return n.runWebGLProgram(d,[s],a.dtype)}const _U={kernelName:cm,backendName:"webgl",kernelFunc:AU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PU(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:a,transposeB:i}=r;return Of({a:s,b:o,transposeA:a,transposeB:i,backend:n})}const OU={kernelName:ru,backendName:"webgl",kernelFunc:PU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MU{constructor(e,n,r,s,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],ye(e,n),ye(e,r);let i="0.0";s!=null&&(ye(e,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="1.0";o!=null&&(ye(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LU{constructor(e,n,r,s,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ye(e,n),ye(e,r);let i="vec4(0.0)";s!=null&&(ye(e,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(ye(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BU=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:o,offset:a,scale:i}=t;S(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const c=[r,s,o];let u=null;a!=null&&(u=a.shape,c.push(a));let d=null;i!=null&&(d=i.shape,c.push(i));const f=z().getBool("WEBGL_PACK_NORMALIZATION")?new LU(r.shape,s.shape,o.shape,u,d,l):new MU(r.shape,s.shape,o.shape,u,d,l);return e.runWebGLProgram(f,c,c[0].dtype)},VU={kernelName:Nu,backendName:"webgl",kernelFunc:BU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WU{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Ce(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=zU(this.rank);let s;const o=e.map((a,i)=>`sourceLoc.${$x[i]} = start[${i}] + coords.${$x[i]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const $x=["x","y","z","w","u","v"];function zU(t){if(t===1)return"sourceLoc";if(t<=6)return $x.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UU{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Ce(this.rank),r=Nt("coords",this.rank),s=Nt("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,a=`getChannel(getSource(${s.join()}), ${o})`,i=`
      result.x = ${a};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${a};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${a};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((u,d)=>`start[${d}]`).join()});`:e.map((u,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${i}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GU(t,e,n,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(n,t.dtype),a=r.texData.get(o.dataId);Object.assign(a,s),a.refCount=1,a.shape=n,a.dtype=t.dtype;let i=rg(e,ae(t.shape));s.slice&&(i+=s.slice.flatOffset),a.slice={flatOffset:i,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),o}function Xo(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:a}=r,[i,l]=sg(s,o,a);if(eg(s,i,l),L(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const d=n.texData.get(s.dataId),f=DW(d.values,i,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,f)}const{isPacked:c}=n.texData.get(s.dataId),u=ng(s.shape,i,l);if(c||!u){const d=z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UU(l):new WU(l),f=[i];return n.runWebGLProgram(d,[s],s.dtype,f)}return n.uploadToGPU(s.dataId),GU(s,i,l,n)}const HU={kernelName:cd,backendName:"webgl",kernelFunc:Xo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jU=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:a}=r;S(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((y,w)=>y*w),l=vl(s.shape,o,i),c=wl(l.length,o.length),u=$l(s.shape,o,i),d=Rg(a,o.length),f=Dg(u,a,o.length),p=[],h=ee({inputs:{x:s},backend:n,attrs:{shape:l}}),g=Rt({inputs:{x:h},backend:n,attrs:{perm:c}}),m=ee({inputs:{x:g},backend:n,attrs:{shape:u}}),x=Xo({inputs:{x:m},backend:n,attrs:{begin:d,size:f}});return p.push(h),p.push(g),p.push(m),p.forEach(y=>n.disposeIntermediateTensorInfo(y)),x},KU={kernelName:su,backendName:"webgl",kernelFunc:jU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qU(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:a}=r,i=n.readSync(s.dataId),l=n.readSync(o.dataId),c=Ib(i,l,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,c)}const XU={kernelName:ou,backendName:"webgl",kernelFunc:qU};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YU(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,o=n.readSync(r.dataId),a=n.readSync(s.dataId),i=ye(Array.from(o),Array.from(a));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const QU={kernelName:au,backendName:"webgl",kernelFunc:YU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZU="return float(a != b);",Zb=ht({opSnippet:ZU,cpuKernelImpl:IW,dtype:"bool"}),JU={kernelName:Di,backendName:"webgl",kernelFunc:Zb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fl(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return jt({inputs:{x:s.complexTensorInfos.real},backend:n})}const eG={kernelName:nd,backendName:"webgl",kernelFunc:Fl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tG="return float(int(x));";function nG(t,e){const n=new jr(t.shape,tG),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bx(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return jt({inputs:{x:s},backend:n});const a=Es(s.shape),i=bx({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Kr({inputs:{real:i,imag:a},backend:n});return a.dispose(),n.disposeIntermediateTensorInfo(i),l}if(s.dtype==="complex64"){const a=Fl({inputs:{input:s},backend:n}),i=bx({inputs:{x:a},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(a),i}if(!tm(s.dtype,o)){const a=jt({inputs:{x:s},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32")return nG(s,n);if(o==="bool"){const a=n.makeTensorInfo([],"bool",Je("bool",1)),l=Zb({inputs:{a:s,b:a},backend:n});return n.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const rG={kernelName:ti,backendName:"webgl",kernelFunc:bx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jb="return ceil(x);",sG=me({opSnippet:Jb,packedOpSnippet:Jb,cpuKernelImpl:iW}),oG={kernelName:ni,backendName:"webgl",kernelFunc:sG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aG{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:o,clipValueMax:a}=r;let i;z().getBool("WEBGL_PACK_CLIP")?i=new iG(s.shape):i=new aG(s.shape);const l=[[o],[a]];return n.runWebGLProgram(i,[s],s.dtype,l)}const cG={kernelName:ri,backendName:"webgl",kernelFunc:lG};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uG{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eC(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function dG(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.texData.get(r.dataId),o=new uG(r.shape),a=[eC(r,s.complexTensorInfos.real),eC(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,a,a[0].dtype)}const fG={kernelName:lu,backendName:"webgl",kernelFunc:dG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pG{constructor(e){this.outputShape=[],this.outputShape=Ln(e,1),this.variableNames=e.map((a,i)=>`T${i}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let a=1;a<n.length;a++)n[a]=n[a-1]+e[a][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<n.length;a++){const i=n[a-1];r.push(`else if (yC < ${n[a]}) setOutput(getT${a}(yR, yC-${i}));`)}const s=n.length,o=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hG{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ln(e,n);const r=this.outputShape,s=r.length,o=Ce(s),a=Nt("coords",s),i=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((g,m)=>`T${m}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let g=1;g<l.length;g++)l[g]=l[g-1]+e[g][n];const c=i[n],u=i.slice(-2),d=i.join();let f=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${u.join()}));
        }`;for(let g=1;g<l.length;g++){const m=l[g-1];f+=`
        if (${c} < ${l[g]}  && ${c} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${Lf(i,c,m)}),
            vec2(${Lf(u,c,m)}));
        }`}const p=l.length,h=l[l.length-1];f+=`
        return getChannel(
          getT${p}(${Lf(i,c,h)}),
          vec2(${Lf(u,c,h)}));`,this.userCode=`
      float getValue(${i.map(g=>"int "+g)}) {
        ${f}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[s-1]} = ${a[s-1]} + 1;
        if (${a[s-1]} < ${r[s-1]}) {
          result.g = getValue(${a});
        }

        ${a[s-2]} = ${a[s-2]} + 1;
        if (${a[s-2]} < ${r[s-2]}) {
          result.a = getValue(${a});
        }

        ${a[s-1]} = ${a[s-1]} - 1;
        if (${a[s-2]} < ${r[s-2]} &&
            ${a[s-1]} < ${r[s-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Lf(t,e,n){const r=t.indexOf(e);return t.map((o,a)=>a===r?`${o} - ${n}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bf(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return jt({inputs:{x:s.complexTensorInfos.imag},backend:n})}const mG={kernelName:Au,backendName:"webgl",kernelFunc:Bf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yo(t,e,n){const r=t[0].dtype;if(r==="complex64"){const u=t.map(g=>Fl({inputs:{input:g},backend:n})),d=t.map(g=>Bf({inputs:{input:g},backend:n})),f=Yo(u,e,n),p=Yo(d,e,n),h=Kr({inputs:{real:f,imag:p},backend:n});return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),d.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),h}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const u=t.map(x=>{const y=L(x.shape.slice(e));return ee({inputs:{x},backend:n,attrs:{shape:[-1,y]}})}),d=u.map(x=>({vals:n.readSync(x.dataId),shape:x.shape})),f=Ln(u.map(x=>x.shape),1),p=u[0].shape[0]===1,h=lW(d,f,r,p),g=Ln(t.map(x=>x.shape),e),m=n.makeTensorInfo(g,r,h);return u.forEach(x=>n.disposeIntermediateTensorInfo(x)),m}if(t.length>z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(t.length/2),d=Yo(t.slice(0,u),e,n),f=Yo(t.slice(u),e,n),p=Yo([d,f],e,n);return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),p}if(z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const u=new hG(t.map(d=>d.shape),e);return n.runWebGLProgram(u,t,r)}const{tensors2D:o,outShape:a}=gG(t,e,n),i=new pG(o.map(u=>u.shape)),l=n.runWebGLProgram(i,o,r);o.forEach(u=>n.disposeIntermediateTensorInfo(u));const c=ee({inputs:{x:l},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(l),c}function gG(t,e,n){const r=Ln(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>ee({inputs:{x:o},attrs:{shape:[-1,L(o.shape.slice(e))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tC(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=ge(s,e[0].shape)[0],a=Ln(e.map(c=>c.shape),o);if(L(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const i=e.filter(c=>L(c.shape)>0);if(i.length===1)return jt({inputs:{x:i[0]},backend:n});const l=i.map(c=>c.shape);return Eg(l,o),Yo(i,o,n)}const xG={kernelName:cu,backendName:"webgl",kernelFunc:tC};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nC{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,f=e.filterHeight,p=e.filterWidth,h=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,m=e.dataFormat==="channelsLast",x=m?1:2,y=m?2:3,w=m?3:1;let v="",$="";r&&(s?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:v=`
          float activation(float x) {
            ${r}
          }
        `,$="result = activation(result);");const b=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${b}
        ${$}
        setOutput(result);
      }
    `}}class yG{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,d=e.filterDepth,f=e.filterHeight,p=e.filterWidth,h=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${i});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vG{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=en(this.outputShape.length);const{dataFormat:r}=n,s=Tt(),o=r==="channelsLast",a=o?0:1,i=o?1:2,l=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let c="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.y + ${d};
          pos = rc.x + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+d}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+d}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rC({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const l=t.shape,c=r.texData.get(t.dataId),u=n.inChannels,d=l[0]*l[1]*l[2],f=n.outChannels,p=n.dataFormat==="channelsLast",h=!1,g=!1;let m;const x=[];if(!((d===1||f===1)&&u>jb)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!=0&&Ie(c.shape.slice(-3),l.slice(-3))){const v=l[0]*l[1]*(l[2]+1),$={dataId:t.dataId,shape:[1,v,n.inChannels],dtype:t.dtype},b=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,S(Ef(c.shape,$.shape),()=>`packed reshape ${c.shape} to ${$.shape} isn't free`);const C=ee({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});x.push(C);const I=Of({a:$,b:C,backend:r,transposeA:h,transposeB:g,bias:s,activation:i,preluActivationWeights:o,leakyreluAlpha:a}),E=r.texData.get(I.dataId);S(E.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=b,E.shape=n.outShape,m=jt({inputs:{x:I},backend:r}),m.shape=n.outShape,x.push(I)}else{const v=p?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],$=ee({inputs:{x:t},backend:r,attrs:{shape:[1,v,n.inChannels]}}),b=ee({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),C=Of({a:$,b,transposeA:h,transposeB:g,backend:r,bias:s,activation:i,preluActivationWeights:o,leakyreluAlpha:a});m=ee({inputs:{x:C},backend:r,attrs:{shape:n.outShape}}),x.push($),x.push(b),x.push(C)}for(const v of x)r.disposeIntermediateTensorInfo(v);return m}function sC({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:d,outHeight:f,dataFormat:p}=n,h=p==="channelsLast",g=l*c*u,m=f*d,x=[g,m],y=!0,w=!1,v=[],$=ee({inputs:{x:t},backend:r,attrs:{shape:t.shape.slice(1)}}),b=ee({inputs:{x:e},backend:r,attrs:{shape:[1,g,L(e.shape)/g]}});v.push($),v.push(b);const C=new vG(x,n),I=[$.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],E=r.runWebGLProgram(C,[$],"float32",I),T=ee({inputs:{x:E},backend:r,attrs:{shape:[1,x[0],x[1]]}});v.push(E),v.push(T);const D=s!=null,F=o!=null,A=i==="leakyrelu",P=i?Af(i,!0):null,M=new Wb(T.shape,b.shape,[1,m,n.outChannels],y,w,D,P,F,A),O=[T,b];if(s&&O.push(s),F&&O.push(o),A){const j=r.makeTensorInfo([],"float32",er(a,"float32"));O.push(j),v.push(j)}const U=r.runWebGLProgram(M,O,"float32"),B=h?[1,f,d,n.outChannels]:[1,n.outChannels,f,d],G=ee({inputs:{x:U},backend:r,attrs:{shape:B}});v.push(U);for(const j of v)r.disposeIntermediateTensorInfo(j);return G}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=r,d=rr(l),f=st(s.shape,o.shape,a,c,i,u,!1,d);let p;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))p=rC({x:s,filter:o,convInfo:f,backend:n});else if(z().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)p=sC({x:s,filter:o,convInfo:f,backend:n});else{const g=new nC(f);p=n.runWebGLProgram(g,[s,o],"float32")}const h=ee({inputs:{x:p},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(p),h}const $G={kernelName:uu,backendName:"webgl",kernelFunc:wG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bG{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class CG{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,a=e.dataFormat==="channelsLast",i=n-1-e.padInfo.top,l=r-1-e.padInfo.left,c=a?1:2,u=a?2:3,d=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class kG{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class SG{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=n-1-e.padInfo.front,c=r-1-e.padInfo.top,u=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:a,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,d=rr(l),f=st(s.shape,u,a,1,i,c,!1,d),p=new bG(f);return n.runWebGLProgram(p,[s,o],"float32")}const EG={kernelName:du,backendName:"webgl",kernelFunc:IG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TG(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:a,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=r,d=rr(c),f=st(a,o.shape,i,1,l,u,!1,d),p=new CG(f);return n.runWebGLProgram(p,[s,o],"float32")}const NG={kernelName:fu,backendName:"webgl",kernelFunc:TG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:i,dilations:l}=r,c=Vr(s.shape,o.shape,a,l,i),u=new yG(c);return n.runWebGLProgram(u,[s,o],"float32")}const DG={kernelName:pu,backendName:"webgl",kernelFunc:RG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:a,pad:i,filterShape:l}=r,c=Vr(s.shape,l,a,1,i),u=new kG(c);return n.runWebGLProgram(u,[s,o],"float32")}const AG={kernelName:dm,backendName:"webgl",kernelFunc:FG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _G(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{pad:a,strides:i,inputShape:l}=r,c=Vr(l,o.shape,i,1,a),u=new SG(c);return n.runWebGLProgram(u,[s,o],"float32")}const PG={kernelName:hu,backendName:"webgl",kernelFunc:_G};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG=Vb+`
  return cos(x);
`,MG=me({opSnippet:OG}),LG={kernelName:si,backendName:"webgl",kernelFunc:MG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BG=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,VG=me({opSnippet:BG}),WG={kernelName:oi,backendName:"webgl",kernelFunc:VG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zG{constructor(e,n,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,l,c]=e,[u]=n,[d,f]=r;this.outputShape=[u,d,f,c];const p=s==="bilinear"?1:0,[h,g]=[`${i-1}.0`,`${l-1}.0`],[m,x,y]=d>1?[`${(i-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[w,v,$]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${v};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${$};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:a}=e,{cropSize:i,method:l,extrapolationValue:c}=r,u=new zG(s.shape,o.shape,i,l,c);return n.runWebGLProgram(u,[s,o,a],"float32")},GG={kernelName:gu,backendName:"webgl",kernelFunc:UG};class oC{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const s=e.length,o=n?"0.0":`getX(${aC(s,"coords")})`,a=e[e.length-1];let i="",l="";n?(i=r?`end != ${a-1}`:"end != 0",l=r?"end + 1":"end - 1"):(i=r?`end + pow2 < ${a}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ce(s)} coords = getOutputCoords();
        int end = ${iC(s,"coords")};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${i}) {
          int idx = ${l};
          ${iC(s,"coords")} = idx;
          val += getX(${aC(s,"coords")});
        }
        setOutput(val);
      }
    `}}function aC(t,e){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function iC(t,e){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:a,reverse:i}=r,l=s.shape.length,c=Ye([o],l);let u=s;c!=null&&(u=Rt({inputs:{x:s},backend:n,attrs:{perm:c}}));const d=Qe(1,l)[0];if(d!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);const f=u.shape[d];let p=jt({inputs:{x:u},backend:n});for(let h=0;h<=Math.ceil(Math.log2(f))-1;h++){const g=new oC(u.shape,!1,i),m=[[h]],x=p;p=n.runWebGLProgram(g,[p],p.dtype,m),n.disposeIntermediateTensorInfo(x)}if(a){const h=new oC(u.shape,a,i),g=p;p=n.runWebGLProgram(h,[p],p.dtype),n.disposeIntermediateTensorInfo(g)}if(c!=null){const h=Yd(c),g=Rt({inputs:{x:p},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(u),g}return p}const jG={kernelName:mu,backendName:"webgl",kernelFunc:HG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:a,binaryOutput:i}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),c=n.readSync(o.dataId),u=Ib(l,c,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,u)}else if(s.shape.length===2){const l=n.bufferSync(s),c=n.bufferSync(o),u=aW(l,c,a,i);return n.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const qG={kernelName:xu,backendName:"webgl",kernelFunc:KG};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XG{constructor(e,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:a}=r,i=s.shape[0],l=a==="NHWC"?s.shape[1]:s.shape[2],c=a==="NHWC"?s.shape[2]:s.shape[3],u=a==="NHWC"?s.shape[3]:s.shape[1],d=l*o,f=c*o,p=u/(o*o),h=a==="NHWC"?[i,d,f,p]:[i,p,d,f],g=new XG(h,o,a);return n.runWebGLProgram(g,[s],s.dtype)}const QG={kernelName:yu,backendName:"webgl",kernelFunc:YG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lC{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=en(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cC{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=en(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,f=d;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<d;x++)p+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let x=0;x<d;x++)p+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(f+1)/2;x++){const y=x*2;if(p+=`
          xC = xCCorner + ${y*c};
          `,l===1){if(y<d&&(i%2==1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,c===1&&y>0?p+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<d)){const w=i%2==0?Zh(c):c;c%2==0&&i%2==1||c%2!=0&&i%2!=1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,c>1&&(p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                      xTexelC${y} = getX(batch, xR, xCOffset, d1);
                      xTexelC${y}Ready = 1;
                    }
                    `),p+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                  `):w===1?p+=`
                    xC${y+1} = xTexelC${y};
                    `:p+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<d&&(i%2==1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<d&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<d&&(p+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<d&&(p+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<d&&(p+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let h="",g="";r&&(s?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:h=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:i,dilations:l,dimRoundingMode:c}=r;let u=l;u==null&&(u=[1,1]),S(vt(a,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const d=st(s.shape,o.shape,a,u,i,c,!0);let f;z().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?f=new cC(d):f=new lC(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(f,[s,o],"float32",p)}const JG={kernelName:vu,backendName:"webgl",kernelFunc:ZG};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eH{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class tH{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,a=n-1-e.padInfo.top,i=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nH(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=r,d=st(s.shape,u,a,i,l,c,!0),f=new eH(d);return n.runWebGLProgram(f,[s,o],"float32")}const rH={kernelName:wu,backendName:"webgl",kernelFunc:nH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=r,d=st(u,o.shape,a,i,l,c,!0),f=new tH(d);return n.runWebGLProgram(f,[s,o],"float32")}const oH={kernelName:$u,backendName:"webgl",kernelFunc:sH};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aH{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iH(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=L(r.shape),a=ee({inputs:{x:r},backend:n,attrs:{shape:[o]}}),i=new aH(o),l=n.runWebGLProgram(i,[a],a.dtype),c=ee({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),c}const lH={kernelName:bu,backendName:"webgl",kernelFunc:iH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cH{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:o,strideWidth:a,filterHeight:i,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:d,left:f}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${d}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uH(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:i,dilations:l}=r,c=ll(s.shape,o.shape,a,i,"NHWC",l);let u;const d=new cH(c);u=n.runWebGLProgram(d,[s,o],"float32");const f=ee({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),f}const dH={kernelName:Cu,backendName:"webgl",kernelFunc:uH};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fH(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:a,summedDims:i,idDims:l}=zg(s,o.length);Gg(a.length,l,o);const{path:c,steps:u}=Hg(i,l),d=u.length;let f=null,p=a.length;const h=[];for(let g=0;g<d;++g){for(const m of u[g]){const{permutationIndices:x,expandDims:y}=Ug(p,l[m]);let w;jg(x)?w=o[m]:(w=Rt({inputs:{x:o[m]},backend:n,attrs:{perm:x}}),h.push(w));const v=w.shape.slice();for(let $=0;$<y.length;++$)v.splice(y[$],0,1);Ie(w.shape,v)||(w=ee({inputs:{x:w},backend:n,attrs:{shape:v}}),h.push(w)),f===null?f=w:(f=vx({inputs:{a:w,b:f},backend:n}),h.push(f))}g<d-1&&(c[g]>=0&&(f=Pf({inputs:{x:f},backend:n,attrs:{axis:c[g]-(a.length-p),keepDims:!1}}),h.push(f)),p--)}for(const g of h)g!==f&&n.disposeIntermediateTensorInfo(g);return f}const pH={kernelName:ku,backendName:"webgl",kernelFunc:fH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hH="return (x >= 0.0) ? x : (exp(x) - 1.0);",mH=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,gH=me({opSnippet:hH,packedOpSnippet:mH}),xH={kernelName:ii,backendName:"webgl",kernelFunc:gH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yH="return (b >= 1.0) ? a : a * (b + 1.0);",vH=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,wH=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,o=z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rl(vH,r.shape,s.shape):new qo(yH,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)},$H={kernelName:hm,backendName:"webgl",kernelFunc:wH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bH=`
  return vec4(equal(a, b));
`,CH="return float(a == b);",kH=ht({opSnippet:CH,packedOpSnippet:bH,dtype:"bool",cpuKernelImpl:cW}),SH={kernelName:ci,backendName:"webgl",kernelFunc:kH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IH=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${_g};
  float a1 = ${Pg};
  float a2 = ${Og};
  float a3 = ${Mg};
  float a4 = ${Lg};
  float a5 = ${Bg};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,EH=me({opSnippet:IH}),TH={kernelName:li,backendName:"webgl",kernelFunc:EH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uC="return exp(x);",dC=me({opSnippet:uC,packedOpSnippet:uC,cpuKernelImpl:uW,dtype:"float32"}),NH={kernelName:ui,backendName:"webgl",kernelFunc:dC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cx(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,a=o.shape.length,i=o.shape.slice();let l=s;return s<0&&(S(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),i.splice(l,0,1),ee({inputs:{x:o},backend:r,attrs:{shape:i}})}const RH={kernelName:Su,backendName:"webgl",kernelFunc:Cx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fC="return exp(x) - 1.0;",DH=me({opSnippet:fC,packedOpSnippet:fC,cpuKernelImpl:dW}),FH={kernelName:di,backendName:"webgl",kernelFunc:DH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pC{constructor(e,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=r?`${s}.0`:"1.0";let i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hC(t,e,n){const r=n.texData.get(t.dataId),s=L(t.shape),o=t.shape[t.shape.length-1],a=s/o,i=ee({inputs:{x:t},backend:n,attrs:{shape:[a,o]}}),l=i.shape,c=new pC("real",l,e),u=new pC("imag",l,e),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=n.runWebGLProgram(c,d,"float32"),p=n.runWebGLProgram(u,d,"float32"),h=Kr({inputs:{real:f,imag:p},backend:n});n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p);const g=ee({inputs:{x:h},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(h),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AH(t){const{inputs:e,backend:n}=t,{input:r}=e;return hC(r,!1,n)}const _H={kernelName:Iu,backendName:"webgl",kernelFunc:AH};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PH{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Al(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||vo(s),o==="string"){const a=St(o,L(r));return a.fill(s),e.makeTensorInfo(r,o,a)}else{const a=new PH(r,s),i=[[s]];return e.runWebGLProgram(a,[],o,i)}}const OH={kernelName:Eu,backendName:"webgl",kernelFunc:Al};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MH{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LH={kernelName:Tu,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new MH(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mC="return floor(x);",BH=me({opSnippet:mC,packedOpSnippet:mC,cpuKernelImpl:fW}),VH={kernelName:fi,backendName:"webgl",kernelFunc:BH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WH=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,zH=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,UH=ht({opSnippet:WH,packedOpSnippet:zH,dtype:"int32"}),GH={kernelName:pi,backendName:"webgl",kernelFunc:UH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HH{constructor(e){this.variableNames=["A"];const n=Tt(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jH{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Tt(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KH={kernelName:Rd,backendName:"webgl",kernelFunc:qH};let Qo;function qH(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:o}=r,a=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,[l,c]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],d=[c,l,o];(i||a)&&(Qo==null&&(Qo=document.createElement("canvas").getContext("2d")),Qo.canvas.width=l,Qo.canvas.height=c,Qo.drawImage(s,0,0,l,c),s=Qo.canvas);const f=n.makeTensorInfo(u,"int32");n.texData.get(f.dataId).usage=Jt.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),s);const p=z().getBool("WEBGL_PACK")?new jH(d):new HH(d),h=n.runWebGLProgram(p,[f],"int32");return n.disposeData(f.dataId),h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XH(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:h}=r,g=rr(u),m=st(s.shape,o.shape,l,d,c,f,!1,g);let x;const y=[];if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))x=rC({x:s,filter:o,convInfo:m,backend:n,bias:a,activation:p,preluActivationWeights:i,leakyreluAlpha:h});else if(z().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)x=sC({x:s,filter:o,convInfo:m,backend:n,bias:a,activation:p,preluActivationWeights:i,leakyreluAlpha:h});else{const v=a!=null,$=i!=null,b=p==="leakyrelu",C=p?Af(p,!1):null,I=new nC(m,v,C,$,b),E=[s,o];if(a&&E.push(a),i&&E.push(i),b){const T=n.makeTensorInfo([],"float32",er(h,"float32"));E.push(T),y.push(T)}x=n.runWebGLProgram(I,E,"float32")}const w=ee({inputs:{x},backend:n,attrs:{shape:m.outShape}});return y.push(x),y.forEach(v=>n.disposeIntermediateTensorInfo(v)),w}const YH={kernelName:Zi,backendName:"webgl",kernelFunc:XH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QH(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:f,leakyreluAlpha:p}=r,h=[];let g=u;g==null&&(g=[1,1]),S(vt(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=st(s.shape,o.shape,l,g,c,d,!0),x=z().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,y=f?Af(f,x):null,w=[s,o],v=a!=null,$=i!=null,b=f==="leakyrelu";if(v&&w.push(a),$&&w.push(i),b){const T=n.makeTensorInfo([],"float32",er(p,"float32"));w.push(T),h.push(T)}let C;x?C=new cC(m,v,y,$,b):C=new lC(m,v,y,$,b);const I=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],E=n.runWebGLProgram(C,w,"float32",I);return h.forEach(T=>n.disposeIntermediateTensorInfo(T)),E}const ZH={kernelName:Ji,backendName:"webgl",kernelFunc:QH};class JH{constructor(e,n,r){this.sliceDim=e,this.strides=n,this.variableNames=["x","indices"],this.outputShape=r;const s=Ce(n.length),o=Ce(r.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${s} strides = ${s}(${this.strides});
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e6(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,a=o[o.length-1],i=L(r.shape),[l,c,u,d]=zd(r,s),f=ee({inputs:{x:s},backend:n,attrs:{shape:[c,a]}}),p=ee({inputs:{x:r},backend:n,attrs:{shape:[L(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const x=n.readSync(s.dataId),y=n.bufferSync(r),w=pW(x,y,r.dtype,c,a,u,d,r.shape,i);return n.makeTensorInfo(l,r.dtype,w.values)}const h=new JH(a,d,[c,u]),g=n.runWebGLProgram(h,[p,f],p.dtype),m=ee({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}const t6={kernelName:Du,backendName:"webgl",kernelFunc:e6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n6{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Ce(this.rank),s=r6(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}}function r6(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)s===2?r.push("int(getIndices(resRC.x, resRC.z))"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gC(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:a,batchDims:i}=r,l=ge(a,s.shape)[0],c=n.readSync(o.dataId),u=s.shape[l];for(let v=0;v<c.length;++v){const $=c[v];S($<=u-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${u-1}]`)}const d=qg(s,o,l,i),f=L(o.shape),p=[],h=ee({inputs:{x:s},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=ee({inputs:{x:o},backend:n,attrs:{shape:[d.batchSize,f/d.batchSize]}});p.push(h),p.push(g);const m=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const v=n.bufferSync(g),$=n.bufferSync(h),b=hW($,v,m);return p.forEach(C=>n.disposeIntermediateTensorInfo(C)),n.makeTensorInfo(d.outputShape,b.dtype,b.values)}const x=new n6(h.shape,m),y=n.runWebGLProgram(x,[h,g],h.dtype);p.push(y);const w=ee({inputs:{x:y},backend:n,attrs:{shape:d.outputShape}});return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),w}const s6={kernelName:Ru,backendName:"webgl",kernelFunc:gC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o6="return float(a > b);",a6=`
  return vec4(greaterThan(a, b));
`,i6=ht({opSnippet:o6,packedOpSnippet:a6,cpuKernelImpl:mW,dtype:"bool"}),l6={kernelName:hi,backendName:"webgl",kernelFunc:i6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c6="return float(a >= b);",u6=`
  return vec4(greaterThanEqual(a, b));
`,d6=ht({opSnippet:c6,packedOpSnippet:u6,dtype:"bool",cpuKernelImpl:gW}),f6={kernelName:mi,backendName:"webgl",kernelFunc:d6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p6(t){const{inputs:e,backend:n}=t,{input:r}=e;return hC(r,!0,n)}const h6={kernelName:Fu,backendName:"webgl",kernelFunc:p6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m6="return float(!isnan(x) && !isinf(x));",g6=me({opSnippet:m6,dtype:"bool"}),x6={kernelName:xi,backendName:"webgl",kernelFunc:g6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y6="return float(isinf(x));",v6=me({opSnippet:y6,dtype:"bool"}),w6={kernelName:yi,backendName:"webgl",kernelFunc:v6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $6="return float(isnan(x));",b6=me({opSnippet:$6,dtype:"bool"}),C6={kernelName:vi,backendName:"webgl",kernelFunc:b6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k6="return float(a < b);",S6=`
  return vec4(lessThan(a, b));
`,I6=ht({opSnippet:k6,packedOpSnippet:S6,cpuKernelImpl:xW,dtype:"bool"}),E6={kernelName:wi,backendName:"webgl",kernelFunc:I6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T6="return float(a <= b);",N6=`
  return vec4(lessThanEqual(a, b));
`,R6=ht({opSnippet:T6,packedOpSnippet:N6,cpuKernelImpl:yW,dtype:"bool"}),D6={kernelName:$i,backendName:"webgl",kernelFunc:R6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F6(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,a=vW(r,s,o);return e.makeTensorInfo([a.length],"float32",a)}const A6={kernelName:Pu,backendName:"webgl",kernelFunc:F6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _6=`if (x < 0.0) return NAN;
  return log(x);`,P6=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,O6=me({opSnippet:_6,packedOpSnippet:P6,cpuKernelImpl:wW}),M6={kernelName:bi,backendName:"webgl",kernelFunc:O6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L6="return log(1.0 + x);",B6=me({opSnippet:L6}),V6={kernelName:Ci,backendName:"webgl",kernelFunc:B6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W6="return float(a >= 1.0 && b >= 1.0);",z6=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,U6=ht({opSnippet:W6,packedOpSnippet:z6,dtype:"bool"}),G6={kernelName:ki,backendName:"webgl",kernelFunc:U6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H6="return float(!(x >= 1.0));",j6=me({opSnippet:H6}),K6={kernelName:Si,backendName:"webgl",kernelFunc:j6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q6="return float(a >= 1.0 || b >= 1.0);",X6=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Y6=ht({opSnippet:q6,packedOpSnippet:X6,dtype:"bool"}),Q6={kernelName:Ii,backendName:"webgl",kernelFunc:Y6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z6{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[];const a=n,i=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J6{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=n,i=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ej=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:a,alpha:i,beta:l}=r,c=z().getBool("WEBGL_PACK_NORMALIZATION")?new J6(s.shape,o,a,i,l):new Z6(s.shape,o,a,i,l);return n.runWebGLProgram(c,[s],s.dtype)},tj={kernelName:Ou,backendName:"webgl",kernelFunc:ej};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nj{constructor(e,n,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rj=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:a}=e,{depthRadius:i,bias:l,alpha:c,beta:u}=r,d=new nj(s.shape,i,l,c,u);return n.runWebGLProgram(d,[s,o,a],s.dtype)},sj={kernelName:mm,backendName:"webgl",kernelFunc:rj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oj(t,e,n,r){const s=L(e),a=L(t.shape)/s,i=ee({inputs:{x:t},attrs:{shape:[a,s]},backend:r}),l=Ls(i,t.dtype,"max",r),c=ee({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xC(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:a}=r,i=s.shape.length,l=ge(o,s.shape);let c=l;const u=Ye(c,i),d=u!=null,f=n.shouldExecuteOnCPU([s]);let p=s;if(d){if(f){const w=n.texData.get(p.dataId).values,v=new Array(i);for(let C=0;C<v.length;C++)v[C]=s.shape[u[C]];const $=yx(w,s.shape,s.dtype,u,v);p=n.makeTensorInfo(v,s.dtype);const b=n.texData.get(p.dataId);b.values=$}else p=_f(s,u,n);c=Qe(c.length,i)}ft("max",c,i);const[h,g]=dt(p.shape,c);let m=h;a&&(m=tt(h,l));let x;if(f){const w=n.texData.get(p.dataId).values,v=$W(w,L(g),m,s.dtype);x=n.makeTensorInfo(m,s.dtype);const $=n.texData.get(x.dataId);$.values=v}else x=oj(p,g,m,n);return d&&n.disposeIntermediateTensorInfo(p),x}const aj={kernelName:Mu,backendName:"webgl",kernelFunc:xC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ij=Pb+`
  return max(a, b);
`,lj=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Ff+`
  return result;
`,cj=ht({opSnippet:ij,packedOpSnippet:lj,cpuKernelImpl:bW}),uj={kernelName:Ei,backendName:"webgl",kernelFunc:cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dj(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;Tl(s,"maxPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,c=1;S(vt(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const u=hn(s.shape,o,a,c,i,l);if(u.filterWidth===1&&u.filterHeight===1&&Ie(u.inShape,u.outShape))return jt({inputs:{x:s},backend:n});const d=new Dl(u,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}const fj={kernelName:Lu,backendName:"webgl",kernelFunc:dj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pj(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:a,pad:i,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],d=nr(s.shape,o,a,u,i,c,l),f=new wx(d,"max",!1);return n.runWebGLProgram(f,[s],s.dtype)}const hj={kernelName:Bu,backendName:"webgl",kernelFunc:pj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mj{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=o-1-e.padInfo.top,l=a-1-e.padInfo.left,c=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class gj{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=l-1-e.padInfo.front,f=c-1-e.padInfo.top,p=u-1-e.padInfo.left,h=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${f}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xj(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,a=o,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=r,d=[1,1,1],f=nr(a.shape,i,l,d,c,u),p=new wx(f,"max",!0),h=n.runWebGLProgram(p,[a],a.dtype),g=new gj(f),m=n.runWebGLProgram(g,[s,h],a.dtype);return n.disposeIntermediateTensorInfo(h),m}const yj={kernelName:xm,backendName:"webgl",kernelFunc:xj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vj(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:a}=e,i=o;Tl([o,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,f=hn(i.shape,l,c,1,u,d),p=!0,h=new Dl(f,"max",p),g=n.runWebGLProgram(h,[i],i.dtype),m=new mj(f),x=n.runWebGLProgram(m,[s,g],i.dtype);return n.disposeIntermediateTensorInfo(g),x}const wj={kernelName:gm,backendName:"webgl",kernelFunc:vj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $j(t,e,n,r){let s=new Dl(n,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");s=new Dl(n,"max",!0,!0,e);const a=r.runWebGLProgram(s,[t],"float32");return[o,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bj={kernelName:Vu,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:o,pad:a,includeBatchInIndex:i}=e,l=n;S(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];S(vt(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=hn(r.shape,s,o,c,a),[d,f]=$j(r,i,u,l);return[d,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cj(t,e,n,r){const s=L(e),a=L(t.shape)/s,i=ee({inputs:{x:t},attrs:{shape:[a,s]},backend:r}),l=Ls(i,"float32","mean",r),c=ee({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kj={kernelName:Wu,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:o}=e,a=n,i=r.shape.length,l=ge(o,r.shape);let c=l;const u=Ye(c,i),d=u!=null,f=a.shouldExecuteOnCPU([r]),p=[];let h=r;if(d){if(f){const v=a.texData.get(h.dataId).values,$=new Array(i);for(let I=0;I<$.length;I++)$[I]=r.shape[u[I]];const b=yx(v,r.shape,r.dtype,u,$);h=a.makeTensorInfo($,r.dtype);const C=a.texData.get(h.dataId);C.values=b}else h=_f(r,u,a);p.push(h),c=Qe(c.length,i)}ft("sum",c,i);const[g,m]=dt(h.shape,c);let x=g;s&&(x=tt(g,l));const y=Cj(h,m,x,a);for(const w of p)a.disposeIntermediateTensorInfo(w);return y}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,i=s.shape.length,l=ge(o,s.shape);let c=l;const u=Ye(c,i);let d=s;u!=null&&(d=Rt({inputs:{x:s},backend:n,attrs:{perm:u}}),c=Qe(c.length,s.shape.length)),ft("min",c,i);const[f,p]=dt(d.shape,c),h=L(p),g=ee({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}}),m=Ls(g,g.dtype,"min",n);let x;if(a){const y=tt(f,l);x=ee({inputs:{x:m},backend:n,attrs:{shape:y}})}else x=ee({inputs:{x:m},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),u!=null&&n.disposeIntermediateTensorInfo(d),x}const Ij={kernelName:zu,backendName:"webgl",kernelFunc:Sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ej=Pb+`
  return min(a, b);
`,Tj=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Ff+`
  return result;
`,Nj=ht({opSnippet:Ej,packedOpSnippet:Tj,cpuKernelImpl:CW}),Rj={kernelName:Ti,backendName:"webgl",kernelFunc:Nj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dj{constructor(e,n,r){this.variableNames=["x"],this.outputShape=n.map((u,d)=>u[0]+e[d]+u[1]);const s=e.length,o=Ce(s),a=n.map(u=>u[0]).join(","),i=n.map((u,d)=>u[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fj{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((h,g)=>h[0]+e[g]+h[1]);const s=e.length,o=Ce(s),a=n.map(h=>h[0]).join(","),i=n.map((h,g)=>h[0]+e[g]).join(","),l=Nt("rc",s),c=Nt("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${c.slice(-2).join()})`,f=r==="reflect"?0:1;let p="";if(s===1){const h=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[s-1]} += 1;
        if(${u}) {
          ${h}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const h=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[s-1]} += 1;
        if(${u}) {
          ${h}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${h}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${l[s-1]} += 1;
          if(${u}) {
            ${h}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aj=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:o}=n,a=z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fj(r.shape,s,o):new Dj(r.shape,s,o);return e.runWebGLProgram(a,[r],r.dtype)},_j={kernelName:Uu,backendName:"webgl",kernelFunc:Aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pj=`if (b == 0.0) return NAN;
  return mod(a, b);`,Oj=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+Ff+`
  return result;
`,Mj=ht({opSnippet:Pj,packedOpSnippet:Oj}),Lj={kernelName:Ni,backendName:"webgl",kernelFunc:Mj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bj{constructor(e,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vj=`
if (a == b) {
  return 1.0;
};
return a / b;`,Wj=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,yC=ht({opSnippet:Vj,packedOpSnippet:Wj,checkOutOfBounds:!0}),zj={kernelName:ai,backendName:"webgl",kernelFunc:yC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vC="return a - b;",wC=ht({opSnippet:vC,packedOpSnippet:vC,supportsComplex:!0,cpuKernelImpl:BW}),Uj={kernelName:ji,backendName:"webgl",kernelFunc:wC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $C(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,a=ge([o],s.shape),i=xC({inputs:{x:s},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=tt(i.shape,a),c=ee({inputs:{x:i},backend:n,attrs:{shape:l}}),u=wC({inputs:{a:s,b:c},backend:n}),d=dC({inputs:{x:u},backend:n}),f=Pf({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:!1}}),p=ee({inputs:{x:f},backend:n,attrs:{shape:l}}),h=yC({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),h}const Gj={kernelName:pd,backendName:"webgl",kernelFunc:$C};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hj(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:a,normalized:i}=r,l=i?s:$C({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=l.shape[0],u=l.shape[1],d=new Bj(c,u,o),f=[[a]],p=n.runWebGLProgram(d,[l],"int32",f);return i||n.disposeIntermediateTensorInfo(l),p}const jj={kernelName:Gu,backendName:"webgl",kernelFunc:Hj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bC="return -x;";function Kj(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const o=n.texData.get(r.dataId),[a,i]=SW(o.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}let s;return z().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Ko(r.shape,bC):s=new jr(r.shape,bC),n.runWebGLProgram(s,[r],r.dtype)}const qj={kernelName:Hu,backendName:"webgl",kernelFunc:Kj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xj=lf;function Yj(t){At("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=r,c=n.readSync(s.dataId),u=n.readSync(o.dataId),{selectedIndices:d}=Xj(c,u,a,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const Qj={kernelName:ju,backendName:"webgl",kernelFunc:Yj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zj=cf;function Jj(t){At("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=r,u=n.readSync(s.dataId),d=n.readSync(o.dataId),{selectedIndices:f,validOutputs:p}=Zj(u,d,a,i,l,c);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const e5={kernelName:Ku,backendName:"webgl",kernelFunc:Jj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t5=uf;function n5(t){At("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=r,u=n.readSync(s.dataId),d=n.readSync(o.dataId),f=a,p=i,h=l,g=c,{selectedIndices:m,selectedScores:x}=t5(u,d,f,p,h,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const r5={kernelName:qu,backendName:"webgl",kernelFunc:n5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s5{constructor(e,n,r,s){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o5=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{depth:o,onValue:a,offValue:i}=r,l=L(s.shape),c=new s5(l,o,a,i),u=ee({inputs:{x:s},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(c,[u],s.dtype);n.disposeIntermediateTensorInfo(u);const f=[...s.shape,o],p=ee({inputs:{x:d},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(d),p},a5={kernelName:Yu,backendName:"webgl",kernelFunc:o5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=Fl({inputs:{input:r},backend:n}),o=Vf({inputs:{x:s},backend:n}),a=Bf({inputs:{input:r},backend:n}),i=Vf({inputs:{x:a},backend:n}),l=Kr({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return Al({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const i5={kernelName:Nd,backendName:"webgl",kernelFunc:Vf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CC(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=Fl({inputs:{input:r},backend:n}),o=CC({inputs:{x:s},backend:n}),a=Bf({inputs:{input:r},backend:n}),i=Vf({inputs:{x:a},backend:n}),l=Kr({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return Al({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const l5={kernelName:Xu,backendName:"webgl",kernelFunc:CC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c5(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Cx({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,a=e[0].dtype;e.forEach(u=>{ct(o,u.shape,"All tensors passed to stack must have matching shapes"),S(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],l=e.map(u=>{const d=Cx({inputs:{input:u},backend:n,attrs:{dim:s}});return i.push(d),d}),c=tC({inputs:l,backend:n,attrs:{axis:s}});return i.forEach(u=>n.disposeIntermediateTensorInfo(u)),c}const u5={kernelName:Qu,backendName:"webgl",kernelFunc:c5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d5{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,u)=>c[0]+e[u]+c[1]);const s=e.length,o=Ce(s),a=n.map(c=>c[0]).join(","),i=n.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f5{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((g,m)=>g[0]+e[m]+g[1]);const s=e.length,o=Ce(s),a=n.map(g=>g[0]).join(","),i=n.map((g,m)=>g[0]+e[m]).join(","),l=Nt("rc",s),c=Nt("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${u}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${u}) {`],p=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let g=0,m=s===1?2:4;g<m;g++)h+=`
        ${f[g]}
        if (${p}) {
          result[${g}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${g}] = getChannel(getX(${c.join()}), ${d});
        }
      `;h+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kC=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:a}=r;if(L(s.shape)===0){const c=o.map((u,d)=>u[0]+s.shape[d]+u[1]);return Al({backend:n,attrs:{shape:c,value:a,dtype:s.dtype}})}const i=z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new f5(s.shape,o,a):new d5(s.shape,o,a),l=[[a]];return n.runWebGLProgram(i,[s],s.dtype,l)},p5={kernelName:Zu,backendName:"webgl",kernelFunc:kC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h5=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,m5=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+Ff+`
  return result;
`,g5=ht({opSnippet:h5,packedOpSnippet:m5}),x5={kernelName:Fi,backendName:"webgl",kernelFunc:g5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,i=s.shape.length,l=[],c=ge(o,s.shape);let u=c;const d=Ye(u,i);let f=s;d!=null&&(f=Rt({inputs:{x:s},backend:n,attrs:{perm:d}}),u=Qe(u.length,i),l.push(f)),ft("prod",u,i);let p;if(n.shouldExecuteOnCPU([f])){const h=n.texData.get(f.dataId).values,{outVals:g,outShape:m,outDtype:x}=EW(f.shape,f.dtype,h,u);p=n.makeTensorInfo(m,x,g)}else{const[h,g]=dt(f.shape,u),m=L(g),x=ee({inputs:{x:f},backend:n,attrs:{shape:[-1,m]}}),y=Ld(s.dtype),w=Ls(x,y,"prod",n);p=ee({inputs:{x:w},backend:n,attrs:{shape:h}}),l.push(x),l.push(w)}if(a){l.push(p);const h=tt(p.shape,c);p=ee({inputs:{x:p},backend:n,attrs:{shape:h}})}return l.forEach(h=>n.disposeIntermediateTensorInfo(h)),p}const v5={kernelName:ed,backendName:"webgl",kernelFunc:y5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SC=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:o,dtype:a}=n,i=TW(r,s,o,a);return e.makeTensorInfo([i.length],a,i)},w5={kernelName:td,backendName:"webgl",kernelFunc:SC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $5="return 1.0 / x;",b5=me({opSnippet:$5}),C5={kernelName:Ai,backendName:"webgl",kernelFunc:b5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k5=Sn+`
  return (x < 0.0) ? 0.0 : x;
`,S5=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,I5=me({opSnippet:k5,packedOpSnippet:S5}),E5={kernelName:_i,backendName:"webgl",kernelFunc:I5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T5=Sn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,N5=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,R5=me({opSnippet:T5,packedOpSnippet:N5}),D5={kernelName:Pi,backendName:"webgl",kernelFunc:R5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F5{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[a,i,l,c]=e;this.outputShape=[a,n,r,c];const u=[s&&n>1?i-1:i,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let f;o?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A5{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,l,c]=e;this.outputShape=[a,n,r,c];const u=[s&&n>1?i-1:i,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let f;o?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:a,size:i}=r,[l,c]=i,u=z().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new A5(s.shape,l,c,o,a):new F5(s.shape,l,c,o,a);return n.runWebGLProgram(u,[s],"float32")}const P5={kernelName:od,backendName:"webgl",kernelFunc:_5};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O5{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,a,i]=e,l=[r&&a>1?s-1:s,r&&i>1?o-1:o],c=[r&&a>1?a-1:a,r&&i>1?i-1:i],u=l[0]/c[0],d=l[1]/c[1],f=1/u,p=1/d,h=Math.ceil(f)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${p});

        const int winHeight = int(${h});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M5(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:a}=r,i=new O5(o.shape,s.shape,a);return n.runWebGLProgram(i,[o],o.dtype)}const L5={kernelName:vm,backendName:"webgl",kernelFunc:M5};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B5{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[a,i,l,c]=e;this.outputShape=[a,n,r,c];const u=[s&&n>1?i-1:i,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],f=s?"0.5":"0.0";let p;o?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V5{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,l,c]=e;this.outputShape=[a,n,r,c];const u=[s&&n>1?i-1:i,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],f=s?"0.5":"0.0";let p;o?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W5(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:a,size:i}=r,[l,c]=i,u=z().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new V5(s.shape,l,c,o,a):new B5(s.shape,l,c,o,a);return n.runWebGLProgram(u,[s],s.dtype)}const z5={kernelName:sd,backendName:"webgl",kernelFunc:W5};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U5{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,a,i]=e,l=[r&&a>1?s-1:s,r&&i>1?o-1:o],c=[r&&a>1?a-1:a,r&&i>1?i-1:i],u=l[0]/c[0],d=l[1]/c[1],f=1/u,p=1/d,h=Math.ceil(f)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${p});

        const int winHeight = int(${h});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G5(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:a}=r,i=new U5(o.shape,s.shape,a);return n.runWebGLProgram(i,[o],o.dtype)}const H5={kernelName:ym,backendName:"webgl",kernelFunc:G5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j5{constructor(e,n){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=i=>n.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,o=e.map((i,l)=>s(l)).join(","),a=Ce(r);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K5{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=Nt("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,a=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,i=Ce(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${o}){
            result.g = ${c(s.slice())};
          }
          if(${a}) {
            result.b = ${u(s.slice())};
            if(${o}) {
              result.a = ${d(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(h){return f(h)}function c(h){return h[r-1]="("+h[r-1]+" + 1)",f(h)}function u(h){return h[r-2]="("+h[r-2]+" + 1)",f(h)}function d(h){return h[r-1]="("+h[r-1]+" + 1)",h[r-2]="("+h[r-2]+" + 1)",f(h)}function f(h){const g=e.map((y,w)=>p(w,h)),m=g.join(","),x=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${x}))`}function p(h,g){return n.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - ${g[h]} - 1`:`${g[h]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q5(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,a=s.shape.length,i=ge(o,s.shape);if(a===0)return jt({inputs:{x:s},backend:n});const l=z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new K5(s.shape,i):new j5(s.shape,i);return n.runWebGLProgram(l,[s],s.dtype)}const X5={kernelName:ad,backendName:"webgl",kernelFunc:q5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y5{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";typeof n=="number"?o=`float outputValue = ${n.toFixed(2)};`:o=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q5={kernelName:Dd,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:a}=e,i=n,l=new Y5(r.shape,o),[c,u]=Ng(a,r.shape[1],r.shape[2]),d=[[c,u,Math.sin(s),Math.cos(s)]];return i.runWebGLProgram(l,[r],r.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z5=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,J5=me({opSnippet:Z5}),eK={kernelName:Oi,backendName:"webgl",kernelFunc:J5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tK="return inversesqrt(x);",nK=me({opSnippet:tK,cpuKernelImpl:NW}),rK={kernelName:Mi,backendName:"webgl",kernelFunc:nK};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IC{constructor(e,n,r,s,o,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=Ce(o.length),c=Ce(a.length);let u="";r===1?u="i":r===2&&(u="i, j");const d=`getIndices(${u})`;let f="";s===1?f="i":s===2&&(f="i, coords[1]");const p=`getUpdates(${f})`,h=n>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${h};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sK(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:a}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Ro(o,s,a),f=[d/c,c];if(d===0)return n.makeTensorInfo(a,s.dtype);const p=ee({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),h=ee({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),m=new IC(l,i,p.shape.length,h.shape.length,u,f),x=n.runWebGLProgram(m,[h,p,g],h.dtype),y=ee({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),y}const oK={kernelName:id,backendName:"webgl",kernelFunc:sK};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aK{constructor(e,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<n.length;u++)c.push(`${i[u]}`),u<e&&l.push(`${i[u]}`);s=l.join(),o=c.join()}const a=Ce(r);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iK(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e,a=new aK(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(a,[r,s,o],zt(s.dtype,o.dtype))}const lK={kernelName:ld,backendName:"webgl",kernelFunc:iK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cK=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Fg};
  float scale = ${Ag};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,uK=me({opSnippet:cK}),dK={kernelName:Li,backendName:"webgl",kernelFunc:uK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EC="return 1.0 / (1.0 + exp(-1.0 * x));",fK=me({opSnippet:EC,packedOpSnippet:EC,cpuKernelImpl:RW}),pK={kernelName:zi,backendName:"webgl",kernelFunc:fK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hK=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,mK=me({opSnippet:hK}),gK={kernelName:Wi,backendName:"webgl",kernelFunc:mK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xK=Vb+`
  return sin(x);
`,yK=me({opSnippet:xK}),vK={kernelName:Bi,backendName:"webgl",kernelFunc:yK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wK=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,$K=me({opSnippet:wK}),bK={kernelName:Vi,backendName:"webgl",kernelFunc:$K};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CK=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,kK=me({opSnippet:CK}),SK={kernelName:Ui,backendName:"webgl",kernelFunc:kK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IK=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:a}=r;S(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((x,y)=>x*y),l=[[0,0]];l.push(...a);for(let x=1+o.length;x<s.shape.length;++x)l.push([0,0]);const c=[],u=kC({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=vl(u.shape,o,i,!1),f=wl(d.length,o.length,!1),p=$l(u.shape,o,i,!1),h=ee({inputs:{x:u},backend:n,attrs:{shape:d}}),g=Rt({inputs:{x:h},backend:n,attrs:{perm:f}}),m=ee({inputs:{x:g},backend:n,attrs:{shape:p}});return c.push(u),c.push(h),c.push(g),c.forEach(x=>n.disposeIntermediateTensorInfo(x)),m},EK={kernelName:dd,backendName:"webgl",kernelFunc:IK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TK(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const i=n.readSync(r.dataId),l=n.readSync(s.dataId),c=n.readSync(o.dataId),u=n.readSync(a.dataId)[0],[d,f,p,h,g]=FW(i,r.shape,r.dtype,l,s.dtype,c,u);return[n.makeTensorInfo(f,r.dtype,d),n.makeTensorInfo([f[0]],s.dtype,p),n.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(m=>Number(m)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const NK={kernelName:hd,backendName:"webgl",kernelFunc:TK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RK(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(n.readSync(s.dataId)),i=n.readSync(r.dataId),l=Array.from(n.readSync(o.dataId)),[c,u,d]=AW(i,r.shape,r.dtype,a,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}const DK={kernelName:md,backendName:"webgl",kernelFunc:RK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FK(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const a=n.readSync(r.dataId),i=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,u]=Tb(a,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(u,r.dtype,c)}const AK={kernelName:gd,backendName:"webgl",kernelFunc:FK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _K(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const a=n.readSync(r.dataId),i=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,u]=Tb(a,r.shape,r.dtype,i,l);return n.makeTensorInfo(u,r.dtype,c)}const PK={kernelName:xd,backendName:"webgl",kernelFunc:_K};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OK(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:a}=e,{outputShape:i}=r,{sliceRank:l,numUpdates:c,strides:u,outputSize:d}=Ro(o,s,i),f=!1,p=new IC(c,l,s.shape.length,o.shape.length,u,[d,1],f),h=n.runWebGLProgram(p,[o,s,a],o.dtype),g=ee({inputs:{x:h},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),g}const MK={kernelName:yd,backendName:"webgl",kernelFunc:OK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LK(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:a}=r,i=ge(a,s.shape)[0],l=Kg(s,o,i),c=s.shape.length,u=new Array(c).fill(0),d=s.shape.slice();return l.map(f=>{const p=[...d];p[i]=f;const h=Xo({inputs:{x:s},backend:n,attrs:{begin:u,size:p}});return u[i]+=f,h})}const BK={kernelName:fd,backendName:"webgl",kernelFunc:LK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TC="return sqrt(x);",VK=me({opSnippet:TC,packedOpSnippet:TC,cpuKernelImpl:_W}),WK={kernelName:Gi,backendName:"webgl",kernelFunc:VK};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zK="return x * x;",UK=me({opSnippet:zK}),GK={kernelName:wm,backendName:"webgl",kernelFunc:UK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NC="return (a - b) * (a - b);",HK=ht({opSnippet:NC,packedOpSnippet:NC}),jK={kernelName:Hi,backendName:"webgl",kernelFunc:HK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KK({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=Sn+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new jr(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const qK={kernelName:Yi,backendName:"webgl",kernelFunc:KK};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XK{constructor(e,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Ce(r.length),a=Ce(r.length);let i="";if(s===1)i="coords * strides + begin";else{let l=0;i=r.map((c,u)=>(l++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${n});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YK(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:a,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:f}=r,{finalShapeSparse:p,finalShape:h,isIdentity:g,sliceDim0:m,isSimpleSlice:x,begin:y,end:w,strides:v}=og(s.shape,o,a,i,l,c,u,d,f);let $;if(g)$=ee({inputs:{x:s},backend:n,attrs:{shape:h}});else if(m||x){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=tg(y,w,v),I=Xo({inputs:{x:s},backend:n,attrs:{begin:y,size:C}});$=ee({inputs:{x:I},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(I)}else if(n.shouldExecuteOnCPU([s])){const I=n.readSync(s.dataId),E=de(s.shape,s.dtype,I),T=PW(p,E,v,y);$=n.makeTensorInfo(h,s.dtype,T.values)}else{const I=new XK(y,v,p);$=n.runWebGLProgram(I,[s],s.dtype)}const b=ee({inputs:{x:$},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo($),b}const QK={kernelName:vd,backendName:"webgl",kernelFunc:YK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZK(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=e,f=n.readSync(u.dataId),p=n.readSync(d.dataId),[h,g]=OW(f,p,s,o,a,i,l,c);return[n.makeTensorInfo([h.length],"string",h),n.makeTensorInfo(d.shape,"int32",g)]}const JK={kernelName:wd,backendName:"webgl",kernelFunc:ZK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eq(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const i=n.readSync(o.dataId),l=n.readSync(a.dataId)[0],[c,u,d]=MW(i,l,s),f=u.length;return[n.makeTensorInfo([f,2],"int32",c),n.makeTensorInfo([f],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const tq={kernelName:$d,backendName:"webgl",kernelFunc:eq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nq(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=n.readSync(o.dataId),i=LW(a,s);return n.makeTensorInfo(o.shape,"int32",i)}const rq={kernelName:bd,backendName:"webgl",kernelFunc:nq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sq="return tan(x);",oq=me({opSnippet:sq}),aq={kernelName:Ki,backendName:"webgl",kernelFunc:oq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iq=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,lq=me({opSnippet:iq}),cq={kernelName:qi,backendName:"webgl",kernelFunc:lq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uq{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let a=0;a<r.length;a++)r[a]=e[a]*n[a];this.outputShape=r,this.rank=r.length;const s=Ce(this.rank),o=dq(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function dq(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RC(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const l=n.readSync(s.dataId),c=s.dtype==="string"?l.map(f=>gs(f)):l,u=de(s.shape,s.dtype,c),d=VW(u,o);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const a=new uq(s.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}const fq={kernelName:Xi,backendName:"webgl",kernelFunc:RC};class pq{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class hq{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bs(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function DC(t){let e=1;for(;e<t;)e*=2;return e}function mq(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:a}=r,i=z().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=z().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([s])||u<i||o>l){const T=n.readSync(s.dataId),[D,F]=WW(T,c,s.dtype,o,a);return[n.makeTensorInfo(D.shape,D.dtype,D.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(o===0)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(u===1)return[s,Al({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),f=d!==null&&d.isPacked,p=f?n.unpackTensor(s):s,g=L(c)/u,m=ee({inputs:{x:p},attrs:{shape:[g,u]},backend:n});f&&Bs(n,p);const x=DC(o),y=DC(u);let w=null;const v=()=>w===null?[m,m]:[m,w],$=(T,D,F)=>{const A=v(),P=new pq(F),O=[[u],[w===null?1:0],[Number.NEGATIVE_INFINITY],[T],[D]],U=w;w=n.runWebGLProgram(P,A,"int32",O),Bs(n,U)};for(let T=1;T<x;T*=2){const D=T*2;for(let F=T;F>=1;F/=2)$(D,F,[g,y])}for(let T=y;T>x;T/=2){const D=v(),F=new hq([g,T/2]),P=[[u],[w===null?1:0],[x]],M=w;w=n.runWebGLProgram(F,D,"int32",P),Bs(n,M);const O=x/2,U=O*2;for(let B=O;B>=1;B/=2)$(U,B,w.shape)}let b=w;w=Xo({inputs:{x:w},backend:n,attrs:{begin:0,size:[g,o]}}),Bs(n,b);let C=gC({inputs:{x:m,indices:w},backend:n,attrs:{axis:1,batchDims:1}});Bs(n,m);const I=c.slice(0,-1);I.push(o),b=w,w=ee({inputs:{x:w},attrs:{shape:I},backend:n}),Bs(n,b);const E=C;return C=ee({inputs:{x:C},attrs:{shape:I},backend:n}),Bs(n,E),[C,w]}const gq={kernelName:Cd,backendName:"webgl",kernelFunc:mq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xq{constructor(e,n,r,s,o,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yq(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:o}=e,{interpolation:a,fillMode:i,fillValue:l,outputShape:c}=r,[u,d,f,p]=s.shape,[h,g]=c!=null?c:[d,f],m=[u,h,g,p],x=new xq(d,f,a,i,l,m);return n.runWebGLProgram(x,[s,o],"float32")}const vq={kernelName:kd,backendName:"webgl",kernelFunc:yq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wq(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:o}=e;Tl(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(o.dataId),{outputValues:i,outputShape:l,indices:c}=zW(a,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}const $q={kernelName:Id,backendName:"webgl",kernelFunc:wq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bq(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const a=s,i=a.shape.length,l=s.shape[o],c=new Array(i-1);let u=0;for(let g=0;g<i;g++)g!==o&&(c[u++]=a.shape[g]);const d=[],f=new Array(i).fill(0),p=a.shape.slice();p[o]=1;const h=new Array(l);for(let g=0;g<h.length;g++){f[o]=g;const m=Xo({inputs:{x:a},backend:n,attrs:{begin:f,size:p}}),x=ee({inputs:{x:m},backend:n,attrs:{shape:c}});h[g]=x,d.push(m)}return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),h}const Cq={kernelName:Ed,backendName:"webgl",kernelFunc:bq};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kq{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,a=e.numSegments,i=a*Math.ceil(o/r);this.outputShape=[s,i];const l="0.0",c="sumValue",u=Math.floor(r/4)*4,d=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let p="";o%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let h="";o%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sq(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:a}=r,i=s.shape.length,l=[];let c=0;const u=Ye([c],i);let d=s;u!=null&&(d=Rt({inputs:{x:s},backend:n,attrs:{perm:u}}),l.push(d),c=Qe(1,i)[0]);const f=Qw(d.shape,c,a),p=L([d.shape[c]]),h=ee({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(h);const g=Ld(s.dtype),m=(v,$,b,C,I)=>{const E=v.shape[0],T=v.shape[1],D=Yw(T,I),F={windowSize:D,inSize:T,batchSize:E,numSegments:I},A=new kq(F,$),P=n.compileAndRun(A,[v,b],C);if(l.push(P),P.shape[1]===I)return P;const M=SC({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),O=RC({inputs:{x:M},backend:n,attrs:{reps:[T/D]}});return l.push(M),l.push(O),m(P,$,O,C,I)},x=m(h,"unsortedSegmentSum",o,g,a),y=ee({inputs:{x},backend:n,attrs:{shape:f}});let w=y;if(u!=null){l.push(y);const v=Yd(u);w=Rt({inputs:{x:w},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),w}const Iq={kernelName:Td,backendName:"webgl",kernelFunc:Sq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eq=[tj,sj,Bz,Wz,Gz,Kz,Xz,Zz,eU,nU,aU,lU,dU,hU,$U,xU,kU,TU,IU,FU,_U,OU,VU,KU,XU,QU,rG,oG,cG,fG,wz,xG,EG,NG,$G,AG,PG,DG,LG,WG,GG,jG,qG,QG,rH,oH,JG,lH,dH,pH,xH,$H,SH,TH,NH,RH,FH,_H,OH,LH,VH,GH,KH,YH,ZH,t6,s6,l6,f6,vz,h6,mG,x6,w6,C6,bz,E6,D6,A6,V6,M6,G6,K6,Q6,aj,hj,fj,yj,wj,bj,uj,kj,Ij,Rj,_j,Lj,jj,Ez,qj,Qj,e5,r5,JU,a5,l5,u5,p5,x5,kz,v5,w5,eG,zj,C5,D5,E5,Nz,P5,L5,z5,H5,X5,Q5,eK,rK,oK,lK,dK,pK,gK,vK,bK,HU,Gj,SK,EK,NK,DK,AK,PK,MK,BK,WK,GK,jK,qK,QK,JK,tq,rq,Uj,Oz,aq,cq,fq,gq,vq,Mz,$q,Cq,Iq,i5];for(const t of Eq)_d(t);function Wf(){return Wf=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},Wf.apply(this,arguments)}var Vs,kx=Vs||(Vs={});kx.Pop="POP";kx.Push="PUSH";kx.Replace="REPLACE";var FC=function(t){return t};function AC(t){t.preventDefault(),t.returnValue=""}function _C(){var t=[];return{get length(){return t.length},push:function(e){return t.push(e),function(){t=t.filter(function(n){return n!==e})}},call:function(e){t.forEach(function(n){return n&&n(e)})}}}function Tq(){return Math.random().toString(36).substr(2,8)}function Sx(t){var e=t.pathname,n=t.search;return t=t.hash,(e===void 0?"/":e)+(n===void 0?"":n)+(t===void 0?"":t)}function Ws(t){var e={};if(t){var n=t.indexOf("#");0<=n&&(e.hash=t.substr(n),t=t.substr(0,n)),n=t.indexOf("?"),0<=n&&(e.search=t.substr(n),t=t.substr(0,n)),t&&(e.pathname=t)}return e}function Nq(t){function e(){var m=l.location,x=c.state||{};return[x.idx,FC({pathname:m.pathname,search:m.search,hash:m.hash,state:x.usr||null,key:x.key||"default"})]}function n(m){return typeof m=="string"?m:Sx(m)}function r(m,x){return x===void 0&&(x=null),FC(Wf({pathname:p.pathname,hash:"",search:""},typeof m=="string"?Ws(m):m,{state:x,key:Tq()}))}function s(m){d=m,m=e(),f=m[0],p=m[1],h.call({action:d,location:p})}function o(m,x){function y(){o(m,x)}var w=Vs.Push,v=r(m,x);if(!g.length||(g.call({action:w,location:v,retry:y}),!1)){var $=[{usr:v.state,key:v.key,idx:f+1},n(v)];v=$[0],$=$[1];try{c.pushState(v,"",$)}catch{l.location.assign($)}s(w)}}function a(m,x){function y(){a(m,x)}var w=Vs.Replace,v=r(m,x);g.length&&(g.call({action:w,location:v,retry:y}),1)||(v=[{usr:v.state,key:v.key,idx:f},n(v)],c.replaceState(v[0],"",v[1]),s(w))}function i(m){c.go(m)}t===void 0&&(t={}),t=t.window;var l=t===void 0?document.defaultView:t,c=l.history,u=null;l.addEventListener("popstate",function(){if(u)g.call(u),u=null;else{var m=Vs.Pop,x=e(),y=x[0];if(x=x[1],g.length){if(y!=null){var w=f-y;w&&(u={action:m,location:x,retry:function(){i(-1*w)}},i(w))}}else s(m)}});var d=Vs.Pop;t=e();var f=t[0],p=t[1],h=_C(),g=_C();return f==null&&(f=0,c.replaceState(Wf({},c.state,{idx:f}),"")),{get action(){return d},get location(){return p},createHref:n,push:o,replace:a,go:i,back:function(){i(-1)},forward:function(){i(1)},listen:function(m){return h.push(m)},block:function(m){var x=g.push(m);return g.length===1&&l.addEventListener("beforeunload",AC),function(){x(),g.length||l.removeEventListener("beforeunload",AC)}}}}/**
 * React Router v6.0.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Wn(t,e){if(!t)throw new Error(e)}const Ix=he.exports.createContext(null),Ex=he.exports.createContext(null),_l=he.exports.createContext({outlet:null,matches:[]});function Rq(t){return Pq()}function Dq(t){Wn(!1)}function Fq(t){let{basename:e="/",children:n=null,location:r,navigationType:s=Vs.Pop,navigator:o,static:a=!1}=t;Pl()&&Wn(!1);let i=tX(e),l=he.exports.useMemo(()=>({basename:i,navigator:o,static:a}),[i,o,a]);typeof r=="string"&&(r=Ws(r));let{pathname:c="/",search:u="",hash:d="",state:f=null,key:p="default"}=r,h=he.exports.useMemo(()=>{let g=LC(c,i);return g==null?null:{pathname:g,search:u,hash:d,state:f,key:p}},[i,c,u,d,f,p]);return h==null?null:he.exports.createElement(Ix.Provider,{value:l},he.exports.createElement(Ex.Provider,{children:n,value:{location:h,navigationType:s}}))}function yX(t){let{children:e,location:n}=t;return Oq(Nx(e),n)}function Aq(t){Pl()||Wn(!1);let{basename:e,navigator:n}=he.exports.useContext(Ix),{hash:r,pathname:s,search:o}=Tx(t),a=s;if(e!=="/"){let i=eX(t),l=i!=null&&i.endsWith("/");a=s==="/"?e+(l?"/":""):qr([e,s])}return n.createHref({pathname:a,search:o,hash:r})}function Pl(){return he.exports.useContext(Ex)!=null}function Ol(){return Pl()||Wn(!1),he.exports.useContext(Ex).location}function _q(){Pl()||Wn(!1);let{basename:t,navigator:e}=he.exports.useContext(Ix),{matches:n}=he.exports.useContext(_l),{pathname:r}=Ol(),s=JSON.stringify(n.map(i=>i.pathnameBase)),o=he.exports.useRef(!1);return he.exports.useEffect(()=>{o.current=!0}),he.exports.useCallback(function(i,l){if(l===void 0&&(l={}),!o.current)return;if(typeof i=="number"){e.go(i);return}let c=MC(i,JSON.parse(s),r);t!=="/"&&(c.pathname=qr([t,c.pathname])),(l.replace?e.replace:e.push)(c,l.state)},[t,e,s,r])}function Pq(){return he.exports.useContext(_l).outlet}function Tx(t){let{matches:e}=he.exports.useContext(_l),{pathname:n}=Ol(),r=JSON.stringify(e.map(s=>s.pathnameBase));return he.exports.useMemo(()=>MC(t,JSON.parse(r),n),[t,r,n])}function Oq(t,e){Pl()||Wn(!1);let{matches:n}=he.exports.useContext(_l),r=n[n.length-1],s=r?r.params:{};r&&r.pathname;let o=r?r.pathnameBase:"/";r&&r.route;let a=Ol(),i;if(e){var l;let f=typeof e=="string"?Ws(e):e;o==="/"||((l=f.pathname)==null?void 0:l.startsWith(o))||Wn(!1),i=f}else i=a;let c=i.pathname||"/",u=o==="/"?c:c.slice(o.length)||"/",d=Mq(t,{pathname:u});return qq(d&&d.map(f=>Object.assign({},f,{params:Object.assign({},s,f.params),pathname:qr([o,f.pathname]),pathnameBase:f.pathnameBase==="/"?o:qr([o,f.pathnameBase])})),n)}function Nx(t){let e=[];return he.exports.Children.forEach(t,n=>{if(!he.exports.isValidElement(n))return;if(n.type===he.exports.Fragment){e.push.apply(e,Nx(n.props.children));return}n.type!==Dq&&Wn(!1);let r={caseSensitive:n.props.caseSensitive,element:n.props.element,index:n.props.index,path:n.props.path};n.props.children&&(r.children=Nx(n.props.children)),e.push(r)}),e}function Mq(t,e,n){n===void 0&&(n="/");let r=typeof e=="string"?Ws(e):e,s=LC(r.pathname||"/",n);if(s==null)return null;let o=PC(t);Lq(o);let a=null;for(let i=0;a==null&&i<o.length;++i)a=Kq(o[i],t,s);return a}function PC(t,e,n,r){return e===void 0&&(e=[]),n===void 0&&(n=[]),r===void 0&&(r=""),t.forEach((s,o)=>{let a={relativePath:s.path||"",caseSensitive:s.caseSensitive===!0,childrenIndex:o};a.relativePath.startsWith("/")&&(a.relativePath.startsWith(r)||Wn(!1),a.relativePath=a.relativePath.slice(r.length));let i=qr([r,a.relativePath]),l=n.concat(a);s.children&&s.children.length>0&&(s.index===!0&&Wn(!1),PC(s.children,e,l,i)),!(s.path==null&&!s.index)&&e.push({path:i,score:Hq(i,s.index),routesMeta:l})}),e}function Lq(t){t.sort((e,n)=>e.score!==n.score?n.score-e.score:jq(e.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}const Bq=/^:\w+$/,Vq=3,Wq=2,zq=1,Uq=10,Gq=-2,OC=t=>t==="*";function Hq(t,e){let n=t.split("/"),r=n.length;return n.some(OC)&&(r+=Gq),e&&(r+=Wq),n.filter(s=>!OC(s)).reduce((s,o)=>s+(Bq.test(o)?Vq:o===""?zq:Uq),r)}function jq(t,e){return t.length===e.length&&t.slice(0,-1).every((r,s)=>r===e[s])?t[t.length-1]-e[e.length-1]:0}function Kq(t,e,n){let r=e,{routesMeta:s}=t,o={},a="/",i=[];for(let l=0;l<s.length;++l){let c=s[l],u=l===s.length-1,d=a==="/"?n:n.slice(a.length)||"/",f=Xq({path:c.relativePath,caseSensitive:c.caseSensitive,end:u},d);if(!f)return null;Object.assign(o,f.params);let p=r[c.childrenIndex];i.push({params:o,pathname:qr([a,f.pathname]),pathnameBase:qr([a,f.pathnameBase]),route:p}),f.pathnameBase!=="/"&&(a=qr([a,f.pathnameBase])),r=p.children}return i}function qq(t,e){return e===void 0&&(e=[]),t==null?null:t.reduceRight((n,r,s)=>he.exports.createElement(_l.Provider,{children:r.route.element!==void 0?r.route.element:he.exports.createElement(Rq,null),value:{outlet:n,matches:e.concat(t.slice(0,s+1))}}),null)}function Xq(t,e){typeof t=="string"&&(t={path:t,caseSensitive:!1,end:!0});let[n,r]=Yq(t.path,t.caseSensitive,t.end),s=e.match(n);if(!s)return null;let o=s[0],a=o.replace(/(.)\/+$/,"$1"),i=s.slice(1);return{params:r.reduce((c,u,d)=>{if(u==="*"){let f=i[d]||"";a=o.slice(0,o.length-f.length).replace(/(.)\/+$/,"$1")}return c[u]=Qq(i[d]||""),c},{}),pathname:o,pathnameBase:a,pattern:t}}function Yq(t,e,n){e===void 0&&(e=!1),n===void 0&&(n=!0);let r=[],s="^"+t.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(a,i)=>(r.push(i),"([^\\/]+)"));return t.endsWith("*")?(r.push("*"),s+=t==="*"||t==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):s+=n?"\\/*$":"(?:\\b|$)",[new RegExp(s,e?void 0:"i"),r]}function Qq(t,e){try{return decodeURIComponent(t)}catch{return t}}function Zq(t,e){e===void 0&&(e="/");let{pathname:n,search:r="",hash:s=""}=typeof t=="string"?Ws(t):t;return{pathname:n?n.startsWith("/")?n:Jq(n,e):e,search:nX(r),hash:rX(s)}}function Jq(t,e){let n=e.replace(/\/+$/,"").split("/");return t.split("/").forEach(s=>{s===".."?n.length>1&&n.pop():s!=="."&&n.push(s)}),n.length>1?n.join("/"):"/"}function MC(t,e,n){let r=typeof t=="string"?Ws(t):t,s=t===""||r.pathname===""?"/":r.pathname,o;if(s==null)o=n;else{let i=e.length-1;if(s.startsWith("..")){let l=s.split("/");for(;l[0]==="..";)l.shift(),i-=1;r.pathname=l.join("/")}o=i>=0?e[i]:"/"}let a=Zq(r,o);return s&&s!=="/"&&s.endsWith("/")&&!a.pathname.endsWith("/")&&(a.pathname+="/"),a}function eX(t){return t===""||t.pathname===""?"/":typeof t=="string"?Ws(t).pathname:t.pathname}function LC(t,e){if(e==="/")return t;if(!t.toLowerCase().startsWith(e.toLowerCase()))return null;let n=t.charAt(e.length);return n&&n!=="/"?null:t.slice(e.length)||"/"}const qr=t=>t.join("/").replace(/\/\/+/g,"/"),tX=t=>t.replace(/\/+$/,"").replace(/^\/*/,"/"),nX=t=>!t||t==="?"?"":t.startsWith("?")?t:"?"+t,rX=t=>!t||t==="#"?"":t.startsWith("#")?t:"#"+t;/**
 * React Router DOM v6.0.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function zf(){return zf=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},zf.apply(this,arguments)}function BC(t,e){if(t==null)return{};var n={},r=Object.keys(t),s,o;for(o=0;o<r.length;o++)s=r[o],!(e.indexOf(s)>=0)&&(n[s]=t[s]);return n}const sX=["onClick","reloadDocument","replace","state","target","to"],oX=["aria-current","caseSensitive","className","end","style","to"];function vX(t){let{basename:e,children:n,window:r}=t,s=he.exports.useRef();s.current==null&&(s.current=Nq({window:r}));let o=s.current,[a,i]=he.exports.useState({action:o.action,location:o.location});return he.exports.useLayoutEffect(()=>o.listen(i),[o]),he.exports.createElement(Fq,{basename:e,children:n,location:a.location,navigationType:a.action,navigator:o})}function aX(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}const iX=he.exports.forwardRef(function(e,n){let{onClick:r,reloadDocument:s,replace:o=!1,state:a,target:i,to:l}=e,c=BC(e,sX),u=Aq(l),d=lX(l,{replace:o,state:a,target:i});function f(p){r&&r(p),!p.defaultPrevented&&!s&&d(p)}return he.exports.createElement("a",zf({},c,{href:u,onClick:f,ref:n,target:i}))}),wX=he.exports.forwardRef(function(e,n){let{"aria-current":r="page",caseSensitive:s=!1,className:o="",end:a=!1,style:i,to:l}=e,c=BC(e,oX),u=Ol(),d=Tx(l),f=u.pathname,p=d.pathname;s||(f=f.toLowerCase(),p=p.toLowerCase());let h=f===p||!a&&f.startsWith(p)&&f.charAt(p.length)==="/",g=h?r:void 0,m;typeof o=="function"?m=o({isActive:h}):m=[o,h?"active":null].filter(Boolean).join(" ");let x=typeof i=="function"?i({isActive:h}):i;return he.exports.createElement(iX,zf({},c,{"aria-current":g,className:m,ref:n,style:x,to:l}))});function lX(t,e){let{target:n,replace:r,state:s}=e===void 0?{}:e,o=_q(),a=Ol(),i=Tx(t);return he.exports.useCallback(l=>{if(l.button===0&&(!n||n==="_self")&&!aX(l)){l.preventDefault();let c=!!r||Sx(a)===Sx(i);o(t,{replace:c,state:s})}},[a,o,i,r,s,n,t])}var cX={exports:{}},Ml={};/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var uX=he.exports,VC=60103;Ml.Fragment=60107;if(typeof Symbol=="function"&&Symbol.for){var WC=Symbol.for;VC=WC("react.element"),Ml.Fragment=WC("react.fragment")}var dX=uX.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,fX=Object.prototype.hasOwnProperty,pX={key:!0,ref:!0,__self:!0,__source:!0};function zC(t,e,n){var r,s={},o=null,a=null;n!==void 0&&(o=""+n),e.key!==void 0&&(o=""+e.key),e.ref!==void 0&&(a=e.ref);for(r in e)fX.call(e,r)&&!pX.hasOwnProperty(r)&&(s[r]=e[r]);if(t&&t.defaultProps)for(r in e=t.defaultProps,e)s[r]===void 0&&(s[r]=e[r]);return{$$typeof:VC,type:t,key:o,ref:a,props:s,_owner:dX.current}}Ml.jsx=zC;Ml.jsxs=zC;cX.exports=Ml;export{eF as $,Aw as A,vX as B,pl as C,xw as D,yw as E,Yv as F,kN as G,OR as H,UE as I,qN as J,$w as K,lw as L,fD as M,wX as N,Rq as O,GD as P,Rw as Q,yX as R,LT as S,qe as T,IF as U,fg as V,Cn as W,sr as X,dw as Y,nF as Z,ZD as _,Dq as a,Qd as a$,jD as a0,Dw as a1,ef as a2,Jd as a3,RD as a4,Wr as a5,hg as a6,cw as a7,dl as a8,ow as a9,gw as aA,Qv as aB,eN as aC,pg as aD,ZT as aE,pA as aF,iA as aG,jd as aH,XT as aI,Qt as aJ,Es as aK,AF as aL,hl as aM,Nw as aN,jR as aO,Ts as aP,Ym as aQ,UR as aR,JN as aS,Kd as aT,YD as aU,Pw as aV,PF as aW,DF as aX,_o as aY,mw as aZ,hw as a_,PN as aa,Ss as ab,DN as ac,rw as ad,lN as ae,aN as af,xs as ag,OT as ah,iT as ai,oT as aj,rT as ak,tT as al,JE as am,WE as an,BE as ao,Yt as ap,S as aq,ve as ar,Xv as as,Eo as at,gl as au,Cg as av,vN as aw,SR as ax,mT as ay,ER as az,gX as b,mg as b0,QN as b1,iw as b2,qd as b3,vw as b4,nw as b5,mA as b6,Wd as b7,TN as b8,$e as b9,$g as bA,tf as bB,wg as bC,X_ as bD,AT as bE,Hd as bF,hN as bG,Zv as bH,ww as bI,fl as bJ,_R as bK,om as bL,OI as bM,rI as bN,xv as bO,nI as bP,EE as bQ,kS as bR,hX as bS,xX as bT,tn as bU,YF as ba,gR as bb,fF as bc,tR as bd,Gd as be,fN as bf,Jv as bg,uN as bh,QE as bi,XE as bj,KE as bk,HE as bl,_e as bm,xg as bn,Zd as bo,Po as bp,ZF as bq,KF as br,ml as bs,ul as bt,Ie as bu,kF as bv,Rs as bw,aw as bx,q_ as by,Fw as bz,mX as c,kn as d,Ae as e,Me as f,Xe as g,fe as h,H_ as i,cX as j,bg as k,zT as l,Z as m,Fo as n,le as o,JI as p,Is as q,he as r,SE as s,xl as t,Ue as u,Gt as v,H as w,un as x,$s as y,z};
//# sourceMappingURL=vendor.a4162548.js.map
